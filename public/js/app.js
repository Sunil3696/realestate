(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["/js/app"],{

/***/ "./resources/assets/js/dashboard.js":
/*!******************************************!*\
  !*** ./resources/assets/js/dashboard.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {(function ($) {
  'use strict';

  $(function () {
    if ($('#cash-deposits-chart').length) {
      var cashDepositsCanvas = $("#cash-deposits-chart").get(0).getContext("2d");
      var data = {
        labels: ["0", "1", "2", "3", "4", "5", "6", "7", "8"],
        datasets: [{
          label: 'Returns',
          data: [27, 35, 30, 40, 52, 48, 54, 46, 70],
          borderColor: ['#ff4747'],
          borderWidth: 2,
          fill: false,
          pointBackgroundColor: "#fff"
        }, {
          label: 'Sales',
          data: [29, 40, 37, 48, 64, 58, 70, 57, 80],
          borderColor: ['#4d83ff'],
          borderWidth: 2,
          fill: false,
          pointBackgroundColor: "#fff"
        }, {
          label: 'Loss',
          data: [90, 62, 80, 63, 72, 62, 40, 50, 38],
          borderColor: ['#ffc100'],
          borderWidth: 2,
          fill: false,
          pointBackgroundColor: "#fff"
        }]
      };
      var options = {
        scales: {
          yAxes: [{
            display: true,
            gridLines: {
              drawBorder: false,
              lineWidth: 1,
              color: "#e9e9e9",
              zeroLineColor: "#e9e9e9"
            },
            ticks: {
              min: 0,
              max: 100,
              stepSize: 20,
              fontColor: "#6c7383",
              fontSize: 16,
              fontStyle: 300,
              padding: 15
            }
          }],
          xAxes: [{
            display: true,
            gridLines: {
              drawBorder: false,
              lineWidth: 1,
              color: "#e9e9e9"
            },
            ticks: {
              fontColor: "#6c7383",
              fontSize: 16,
              fontStyle: 300,
              padding: 15
            }
          }]
        },
        legend: {
          display: false
        },
        legendCallback: function legendCallback(chart) {
          var text = [];
          text.push('<ul class="dashboard-chart-legend">');

          for (var i = 0; i < chart.data.datasets.length; i++) {
            text.push('<li><span style="background-color: ' + chart.data.datasets[i].borderColor[0] + ' "></span>');

            if (chart.data.datasets[i].label) {
              text.push(chart.data.datasets[i].label);
            }
          }

          text.push('</ul>');
          return text.join("");
        },
        elements: {
          point: {
            radius: 3
          },
          line: {
            tension: 0
          }
        },
        stepsize: 1,
        layout: {
          padding: {
            top: 0,
            bottom: -10,
            left: -10,
            right: 0
          }
        }
      };
      var cashDeposits = new Chart(cashDepositsCanvas, {
        type: 'line',
        data: data,
        options: options
      });
      document.getElementById('cash-deposits-chart-legend').innerHTML = cashDeposits.generateLegend();
    }

    if ($('#total-sales-chart').length) {
      var totalSalesChartCanvas = $("#total-sales-chart").get(0).getContext("2d");
      var data = {
        labels: ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40'],
        datasets: [{
          label: '2019',
          data: [42, 42, 30, 30, 18, 22, 16, 21, 22, 22, 22, 20, 24, 20, 18, 22, 30, 34, 32, 33, 33, 24, 32, 34, 30, 34, 19, 34, 18, 10, 22, 24, 20, 22, 20, 21, 10, 10, 5, 9, 14],
          borderColor: ['transparent'],
          borderWidth: 2,
          fill: true,
          backgroundColor: "rgba(47,91,191,0.77)"
        }, {
          label: '2018',
          data: [35, 28, 32, 42, 44, 46, 42, 50, 48, 30, 35, 48, 42, 40, 54, 58, 56, 55, 59, 58, 57, 60, 66, 54, 38, 40, 42, 44, 42, 43, 42, 38, 43, 41, 43, 50, 58, 58, 68, 72, 72],
          borderColor: ['transparent'],
          borderWidth: 2,
          fill: true,
          backgroundColor: "rgba(77,131,255,0.77)"
        }, {
          label: 'Past years',
          data: [98, 88, 92, 90, 98, 98, 90, 92, 78, 88, 84, 76, 80, 72, 74, 74, 88, 80, 72, 62, 62, 72, 72, 78, 78, 72, 75, 78, 68, 68, 60, 68, 70, 75, 70, 80, 82, 78, 78, 84, 82],
          borderColor: ['transparent'],
          borderWidth: 2,
          fill: true,
          backgroundColor: "rgba(77,131,255,0.43)"
        }]
      };
      var options = {
        scales: {
          yAxes: [{
            display: false,
            gridLines: {
              drawBorder: false,
              lineWidth: 1,
              color: "#e9e9e9",
              zeroLineColor: "#e9e9e9"
            },
            ticks: {
              display: true,
              min: 0,
              max: 100,
              stepSize: 10,
              fontColor: "#6c7383",
              fontSize: 16,
              fontStyle: 300,
              padding: 15
            }
          }],
          xAxes: [{
            display: false,
            gridLines: {
              drawBorder: false,
              lineWidth: 1,
              color: "#e9e9e9"
            },
            ticks: {
              display: true,
              fontColor: "#6c7383",
              fontSize: 16,
              fontStyle: 300,
              padding: 15
            }
          }]
        },
        legend: {
          display: false
        },
        legendCallback: function legendCallback(chart) {
          var text = [];
          text.push('<ul class="dashboard-chart-legend mb-0 mt-4">');

          for (var i = 0; i < chart.data.datasets.length; i++) {
            text.push('<li><span style="background-color: ' + chart.data.datasets[i].backgroundColor + ' "></span>');

            if (chart.data.datasets[i].label) {
              text.push(chart.data.datasets[i].label);
            }
          }

          text.push('</ul>');
          return text.join("");
        },
        elements: {
          point: {
            radius: 0
          },
          line: {
            tension: 0
          }
        },
        stepsize: 1,
        layout: {
          padding: {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0
          }
        }
      };
      var totalSalesChart = new Chart(totalSalesChartCanvas, {
        type: 'line',
        data: data,
        options: options
      });
      document.getElementById('total-sales-chart-legend').innerHTML = totalSalesChart.generateLegend();
    }

    $('#recent-purchases-listing').DataTable({
      "aLengthMenu": [[5, 10, 15, -1], [5, 10, 15, "All"]],
      "iDisplayLength": 10,
      "language": {
        search: ""
      },
      searching: false,
      paging: false,
      info: false
    });
  });
})(jQuery);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./resources/assets/js/data-table.js":
/*!*******************************************!*\
  !*** ./resources/assets/js/data-table.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {(function ($) {
  'use strict';

  $(function () {
    $('#order-listing').DataTable({
      "aLengthMenu": [[5, 10, 15, -1], [5, 10, 15, "All"]],
      "iDisplayLength": 10,
      "language": {
        search: ""
      }
    });
    $('#order-listing').each(function () {
      var datatable = $(this); // SEARCH - Add the placeholder for Search and Turn this into in-line form control

      var search_input = datatable.closest('.dataTables_wrapper').find('div[id$=_filter] input');
      search_input.attr('placeholder', 'Search');
      search_input.removeClass('form-control-sm'); // LENGTH - Inline-Form control

      var length_sel = datatable.closest('.dataTables_wrapper').find('div[id$=_length] select');
      length_sel.removeClass('form-control-sm');
    });
  });
})(jQuery);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./resources/assets/js/hoverable-collapse.js":
/*!***************************************************!*\
  !*** ./resources/assets/js/hoverable-collapse.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {(function ($) {
  'use strict'; //Open submenu on hover in compact sidebar mode and horizontal menu mode

  $(document).on('mouseenter mouseleave', '.sidebar .nav-item', function (ev) {
    var body = $('body');
    var sidebarIconOnly = body.hasClass("sidebar-icon-only");
    var sidebarFixed = body.hasClass("sidebar-fixed");

    if (!('ontouchstart' in document.documentElement)) {
      if (sidebarIconOnly) {
        if (sidebarFixed) {
          if (ev.type === 'mouseenter') {
            body.removeClass('sidebar-icon-only');
          }
        } else {
          var $menuItem = $(this);

          if (ev.type === 'mouseenter') {
            $menuItem.addClass('hover-open');
          } else {
            $menuItem.removeClass('hover-open');
          }
        }
      }
    }
  });
})(jQuery);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./resources/assets/js/jquery.dataTables.js":
/*!**************************************************!*\
  !*** ./resources/assets/js/jquery.dataTables.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*! DataTables 1.10.16
 * ©2008-2017 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     DataTables
 * @description Paginate, search and order HTML tables
 * @version     1.10.16
 * @file        jquery.dataTables.js
 * @author      SpryMedia Ltd
 * @contact     www.datatables.net
 * @copyright   Copyright 2008-2017 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

/*jslint evil: true, undef: true, browser: true */

/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidate,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/
(function (factory) {
  "use strict";

  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($) {
      return factory($, window, document);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(function ($, window, document, undefined) {
  "use strict";
  /**
   * DataTables is a plug-in for the jQuery Javascript library. It is a highly
   * flexible tool, based upon the foundations of progressive enhancement,
   * which will add advanced interaction controls to any HTML table. For a
   * full list of features please refer to
   * [DataTables.net](href="http://datatables.net).
   *
   * Note that the `DataTable` object is not a global variable but is aliased
   * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may
   * be  accessed.
   *
   *  @class
   *  @param {object} [init={}] Configuration object for DataTables. Options
   *    are defined by {@link DataTable.defaults}
   *  @requires jQuery 1.7+
   *
   *  @example
   *    // Basic initialisation
   *    $(document).ready( function {
   *      $('#example').dataTable();
   *    } );
   *
   *  @example
   *    // Initialisation with configuration options - in this case, disable
   *    // pagination and sorting.
   *    $(document).ready( function {
   *      $('#example').dataTable( {
   *        "paginate": false,
   *        "sort": false
   *      } );
   *    } );
   */

  var DataTable = function DataTable(options) {
    /**
     * Perform a jQuery selector action on the table's TR elements (from the tbody) and
     * return the resulting jQuery object.
     *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
     *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
     *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
     *    criterion ("applied") or all TR elements (i.e. no filter).
     *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
     *    Can be either 'current', whereby the current sorting of the table is used, or
     *    'original' whereby the original order the data was read into the table is used.
     *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
     *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
     *    'current' and filter is 'applied', regardless of what they might be given as.
     *  @returns {object} jQuery object, filtered by the given selector.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Highlight every second row
     *      oTable.$('tr:odd').css('backgroundColor', 'blue');
     *    } );
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Filter to rows with 'Webkit' in them, add a background colour and then
     *      // remove the filter, thus highlighting the 'Webkit' rows only.
     *      oTable.fnFilter('Webkit');
     *      oTable.$('tr', {"search": "applied"}).css('backgroundColor', 'blue');
     *      oTable.fnFilter('');
     *    } );
     */
    this.$ = function (sSelector, oOpts) {
      return this.api(true).$(sSelector, oOpts);
    };
    /**
     * Almost identical to $ in operation, but in this case returns the data for the matched
     * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
     * rather than any descendants, so the data can be obtained for the row/cell. If matching
     * rows are found, the data returned is the original data array/object that was used to
     * create the row (or a generated array if from a DOM source).
     *
     * This method is often useful in-combination with $ where both functions are given the
     * same parameters and the array indexes will match identically.
     *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
     *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
     *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
     *    criterion ("applied") or all elements (i.e. no filter).
     *  @param {string} [oOpts.order=current] Order of the data in the processed array.
     *    Can be either 'current', whereby the current sorting of the table is used, or
     *    'original' whereby the original order the data was read into the table is used.
     *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
     *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
     *    'current' and filter is 'applied', regardless of what they might be given as.
     *  @returns {array} Data for the matched elements. If any elements, as a result of the
     *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
     *    entry in the array.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Get the data from the first row in the table
     *      var data = oTable._('tr:first');
     *
     *      // Do something useful with the data
     *      alert( "First cell is: "+data[0] );
     *    } );
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Filter to 'Webkit' and get all data for
     *      oTable.fnFilter('Webkit');
     *      var data = oTable._('tr', {"search": "applied"});
     *
     *      // Do something with the data
     *      alert( data.length+" rows matched the search" );
     *    } );
     */


    this._ = function (sSelector, oOpts) {
      return this.api(true).rows(sSelector, oOpts).data();
    };
    /**
     * Create a DataTables Api instance, with the currently selected tables for
     * the Api's context.
     * @param {boolean} [traditional=false] Set the API instance's context to be
     *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was
     *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),
     *   or if all tables captured in the jQuery object should be used.
     * @return {DataTables.Api}
     */


    this.api = function (traditional) {
      return traditional ? new _Api2(_fnSettingsFromNode(this[_ext.iApiIndex])) : new _Api2(this);
    };
    /**
     * Add a single new row or multiple rows of data to the table. Please note
     * that this is suitable for client-side processing only - if you are using
     * server-side processing (i.e. "bServerSide": true), then to add data, you
     * must add it to the data source, i.e. the server-side, through an Ajax call.
     *  @param {array|object} data The data to be added to the table. This can be:
     *    <ul>
     *      <li>1D array of data - add a single row with the data provided</li>
     *      <li>2D array of arrays - add multiple rows in a single call</li>
     *      <li>object - data object when using <i>mData</i></li>
     *      <li>array of objects - multiple data objects when using <i>mData</i></li>
     *    </ul>
     *  @param {bool} [redraw=true] redraw the table or not
     *  @returns {array} An array of integers, representing the list of indexes in
     *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
     *    the table.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    // Global var for counter
     *    var giCount = 2;
     *
     *    $(document).ready(function() {
     *      $('#example').dataTable();
     *    } );
     *
     *    function fnClickAddRow() {
     *      $('#example').dataTable().fnAddData( [
     *        giCount+".1",
     *        giCount+".2",
     *        giCount+".3",
     *        giCount+".4" ]
     *      );
     *
     *      giCount++;
     *    }
     */


    this.fnAddData = function (data, redraw) {
      var api = this.api(true);
      /* Check if we want to add multiple rows or not */

      var rows = $.isArray(data) && ($.isArray(data[0]) || $.isPlainObject(data[0])) ? api.rows.add(data) : api.row.add(data);

      if (redraw === undefined || redraw) {
        api.draw();
      }

      return rows.flatten().toArray();
    };
    /**
     * This function will make DataTables recalculate the column sizes, based on the data
     * contained in the table and the sizes applied to the columns (in the DOM, CSS or
     * through the sWidth parameter). This can be useful when the width of the table's
     * parent element changes (for example a window resize).
     *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable( {
     *        "sScrollY": "200px",
     *        "bPaginate": false
     *      } );
     *
     *      $(window).on('resize', function () {
     *        oTable.fnAdjustColumnSizing();
     *      } );
     *    } );
     */


    this.fnAdjustColumnSizing = function (bRedraw) {
      var api = this.api(true).columns.adjust();
      var settings = api.settings()[0];
      var scroll = settings.oScroll;

      if (bRedraw === undefined || bRedraw) {
        api.draw(false);
      } else if (scroll.sX !== "" || scroll.sY !== "") {
        /* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
        _fnScrollDraw(settings);
      }
    };
    /**
     * Quickly and simply clear a table
     *  @param {bool} [bRedraw=true] redraw the table or not
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
     *      oTable.fnClearTable();
     *    } );
     */


    this.fnClearTable = function (bRedraw) {
      var api = this.api(true).clear();

      if (bRedraw === undefined || bRedraw) {
        api.draw();
      }
    };
    /**
     * The exact opposite of 'opening' a row, this function will close any rows which
     * are currently 'open'.
     *  @param {node} nTr the table row to 'close'
     *  @returns {int} 0 on success, or 1 if failed (can't find the row)
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable;
     *
     *      // 'open' an information row when a row is clicked on
     *      $('#example tbody tr').click( function () {
     *        if ( oTable.fnIsOpen(this) ) {
     *          oTable.fnClose( this );
     *        } else {
     *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
     *        }
     *      } );
     *
     *      oTable = $('#example').dataTable();
     *    } );
     */


    this.fnClose = function (nTr) {
      this.api(true).row(nTr).child.hide();
    };
    /**
     * Remove a row for the table
     *  @param {mixed} target The index of the row from aoData to be deleted, or
     *    the TR element you want to delete
     *  @param {function|null} [callBack] Callback function
     *  @param {bool} [redraw=true] Redraw the table or not
     *  @returns {array} The row that was deleted
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Immediately remove the first row
     *      oTable.fnDeleteRow( 0 );
     *    } );
     */


    this.fnDeleteRow = function (target, callback, redraw) {
      var api = this.api(true);
      var rows = api.rows(target);
      var settings = rows.settings()[0];
      var data = settings.aoData[rows[0][0]];
      rows.remove();

      if (callback) {
        callback.call(this, settings, data);
      }

      if (redraw === undefined || redraw) {
        api.draw();
      }

      return data;
    };
    /**
     * Restore the table to it's original state in the DOM by removing all of DataTables
     * enhancements, alterations to the DOM structure of the table and event listeners.
     *  @param {boolean} [remove=false] Completely remove the table from the DOM
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
     *      var oTable = $('#example').dataTable();
     *      oTable.fnDestroy();
     *    } );
     */


    this.fnDestroy = function (remove) {
      this.api(true).destroy(remove);
    };
    /**
     * Redraw the table
     *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
     *      oTable.fnDraw();
     *    } );
     */


    this.fnDraw = function (complete) {
      // Note that this isn't an exact match to the old call to _fnDraw - it takes
      // into account the new data, but can hold position.
      this.api(true).draw(complete);
    };
    /**
     * Filter the input based on data
     *  @param {string} sInput String to filter the table on
     *  @param {int|null} [iColumn] Column to limit filtering to
     *  @param {bool} [bRegex=false] Treat as regular expression or not
     *  @param {bool} [bSmart=true] Perform smart filtering or not
     *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
     *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Sometime later - filter...
     *      oTable.fnFilter( 'test string' );
     *    } );
     */


    this.fnFilter = function (sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive) {
      var api = this.api(true);

      if (iColumn === null || iColumn === undefined) {
        api.search(sInput, bRegex, bSmart, bCaseInsensitive);
      } else {
        api.column(iColumn).search(sInput, bRegex, bSmart, bCaseInsensitive);
      }

      api.draw();
    };
    /**
     * Get the data for the whole table, an individual row or an individual cell based on the
     * provided parameters.
     *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as
     *    a TR node then the data source for the whole row will be returned. If given as a
     *    TD/TH cell node then iCol will be automatically calculated and the data for the
     *    cell returned. If given as an integer, then this is treated as the aoData internal
     *    data index for the row (see fnGetPosition) and the data for that row used.
     *  @param {int} [col] Optional column index that you want the data of.
     *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
     *    returned. If mRow is defined, just data for that row, and is iCol is
     *    defined, only data for the designated cell is returned.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    // Row data
     *    $(document).ready(function() {
     *      oTable = $('#example').dataTable();
     *
     *      oTable.$('tr').click( function () {
     *        var data = oTable.fnGetData( this );
     *        // ... do something with the array / object of data for the row
     *      } );
     *    } );
     *
     *  @example
     *    // Individual cell data
     *    $(document).ready(function() {
     *      oTable = $('#example').dataTable();
     *
     *      oTable.$('td').click( function () {
     *        var sData = oTable.fnGetData( this );
     *        alert( 'The cell clicked on had the value of '+sData );
     *      } );
     *    } );
     */


    this.fnGetData = function (src, col) {
      var api = this.api(true);

      if (src !== undefined) {
        var type = src.nodeName ? src.nodeName.toLowerCase() : '';
        return col !== undefined || type == 'td' || type == 'th' ? api.cell(src, col).data() : api.row(src).data() || null;
      }

      return api.data().toArray();
    };
    /**
     * Get an array of the TR nodes that are used in the table's body. Note that you will
     * typically want to use the '$' API method in preference to this as it is more
     * flexible.
     *  @param {int} [iRow] Optional row index for the TR element you want
     *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
     *    in the table's body, or iRow is defined, just the TR element requested.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Get the nodes from the table
     *      var nNodes = oTable.fnGetNodes( );
     *    } );
     */


    this.fnGetNodes = function (iRow) {
      var api = this.api(true);
      return iRow !== undefined ? api.row(iRow).node() : api.rows().nodes().flatten().toArray();
    };
    /**
     * Get the array indexes of a particular cell from it's DOM element
     * and column index including hidden columns
     *  @param {node} node this can either be a TR, TD or TH in the table's body
     *  @returns {int} If nNode is given as a TR, then a single index is returned, or
     *    if given as a cell, an array of [row index, column index (visible),
     *    column index (all)] is given.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      $('#example tbody td').click( function () {
     *        // Get the position of the current data from the node
     *        var aPos = oTable.fnGetPosition( this );
     *
     *        // Get the data array for this row
     *        var aData = oTable.fnGetData( aPos[0] );
     *
     *        // Update the data array and return the value
     *        aData[ aPos[1] ] = 'clicked';
     *        this.innerHTML = 'clicked';
     *      } );
     *
     *      // Init DataTables
     *      oTable = $('#example').dataTable();
     *    } );
     */


    this.fnGetPosition = function (node) {
      var api = this.api(true);
      var nodeName = node.nodeName.toUpperCase();

      if (nodeName == 'TR') {
        return api.row(node).index();
      } else if (nodeName == 'TD' || nodeName == 'TH') {
        var cell = api.cell(node).index();
        return [cell.row, cell.columnVisible, cell.column];
      }

      return null;
    };
    /**
     * Check to see if a row is 'open' or not.
     *  @param {node} nTr the table row to check
     *  @returns {boolean} true if the row is currently open, false otherwise
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable;
     *
     *      // 'open' an information row when a row is clicked on
     *      $('#example tbody tr').click( function () {
     *        if ( oTable.fnIsOpen(this) ) {
     *          oTable.fnClose( this );
     *        } else {
     *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
     *        }
     *      } );
     *
     *      oTable = $('#example').dataTable();
     *    } );
     */


    this.fnIsOpen = function (nTr) {
      return this.api(true).row(nTr).child.isShown();
    };
    /**
     * This function will place a new row directly after a row which is currently
     * on display on the page, with the HTML contents that is passed into the
     * function. This can be used, for example, to ask for confirmation that a
     * particular record should be deleted.
     *  @param {node} nTr The table row to 'open'
     *  @param {string|node|jQuery} mHtml The HTML to put into the row
     *  @param {string} sClass Class to give the new TD cell
     *  @returns {node} The row opened. Note that if the table row passed in as the
     *    first parameter, is not found in the table, this method will silently
     *    return.
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable;
     *
     *      // 'open' an information row when a row is clicked on
     *      $('#example tbody tr').click( function () {
     *        if ( oTable.fnIsOpen(this) ) {
     *          oTable.fnClose( this );
     *        } else {
     *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
     *        }
     *      } );
     *
     *      oTable = $('#example').dataTable();
     *    } );
     */


    this.fnOpen = function (nTr, mHtml, sClass) {
      return this.api(true).row(nTr).child(mHtml, sClass).show().child()[0];
    };
    /**
     * Change the pagination - provides the internal logic for pagination in a simple API
     * function. With this function you can have a DataTables table go to the next,
     * previous, first or last pages.
     *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
     *    or page number to jump to (integer), note that page 0 is the first page.
     *  @param {bool} [bRedraw=true] Redraw the table or not
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *      oTable.fnPageChange( 'next' );
     *    } );
     */


    this.fnPageChange = function (mAction, bRedraw) {
      var api = this.api(true).page(mAction);

      if (bRedraw === undefined || bRedraw) {
        api.draw(false);
      }
    };
    /**
     * Show a particular column
     *  @param {int} iCol The column whose display should be changed
     *  @param {bool} bShow Show (true) or hide (false) the column
     *  @param {bool} [bRedraw=true] Redraw the table or not
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Hide the second column after initialisation
     *      oTable.fnSetColumnVis( 1, false );
     *    } );
     */


    this.fnSetColumnVis = function (iCol, bShow, bRedraw) {
      var api = this.api(true).column(iCol).visible(bShow);

      if (bRedraw === undefined || bRedraw) {
        api.columns.adjust().draw();
      }
    };
    /**
     * Get the settings for a particular table for external manipulation
     *  @returns {object} DataTables settings object. See
     *    {@link DataTable.models.oSettings}
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *      var oSettings = oTable.fnSettings();
     *
     *      // Show an example parameter from the settings
     *      alert( oSettings._iDisplayStart );
     *    } );
     */


    this.fnSettings = function () {
      return _fnSettingsFromNode(this[_ext.iApiIndex]);
    };
    /**
     * Sort the table by a particular column
     *  @param {int} iCol the data index to sort on. Note that this will not match the
     *    'display index' if you have hidden data entries
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Sort immediately with columns 0 and 1
     *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
     *    } );
     */


    this.fnSort = function (aaSort) {
      this.api(true).order(aaSort).draw();
    };
    /**
     * Attach a sort listener to an element for a given column
     *  @param {node} nNode the element to attach the sort listener to
     *  @param {int} iColumn the column that a click on this node will sort on
     *  @param {function} [fnCallback] callback function when sort is run
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *
     *      // Sort on column 1, when 'sorter' is clicked on
     *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
     *    } );
     */


    this.fnSortListener = function (nNode, iColumn, fnCallback) {
      this.api(true).order.listener(nNode, iColumn, fnCallback);
    };
    /**
     * Update a table cell or row - this method will accept either a single value to
     * update the cell with, an array of values with one element for each column or
     * an object in the same format as the original data source. The function is
     * self-referencing in order to make the multi column updates easier.
     *  @param {object|array|string} mData Data to update the cell/row with
     *  @param {node|int} mRow TR element you want to update or the aoData index
     *  @param {int} [iColumn] The column to update, give as null or undefined to
     *    update a whole row.
     *  @param {bool} [bRedraw=true] Redraw the table or not
     *  @param {bool} [bAction=true] Perform pre-draw actions or not
     *  @returns {int} 0 on success, 1 on error
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
     *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row
     *    } );
     */


    this.fnUpdate = function (mData, mRow, iColumn, bRedraw, bAction) {
      var api = this.api(true);

      if (iColumn === undefined || iColumn === null) {
        api.row(mRow).data(mData);
      } else {
        api.cell(mRow, iColumn).data(mData);
      }

      if (bAction === undefined || bAction) {
        api.columns.adjust();
      }

      if (bRedraw === undefined || bRedraw) {
        api.draw();
      }

      return 0;
    };
    /**
     * Provide a common method for plug-ins to check the version of DataTables being used, in order
     * to ensure compatibility.
     *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
     *    formats "X" and "X.Y" are also acceptable.
     *  @returns {boolean} true if this version of DataTables is greater or equal to the required
     *    version, or false if this version of DataTales is not suitable
     *  @method
     *  @dtopt API
     *  @deprecated Since v1.10
     *
     *  @example
     *    $(document).ready(function() {
     *      var oTable = $('#example').dataTable();
     *      alert( oTable.fnVersionCheck( '1.9.0' ) );
     *    } );
     */


    this.fnVersionCheck = _ext.fnVersionCheck;

    var _that = this;

    var emptyInit = options === undefined;
    var len = this.length;

    if (emptyInit) {
      options = {};
    }

    this.oApi = this.internal = _ext.internal; // Extend with old style plug-in API methods

    for (var fn in DataTable.ext.internal) {
      if (fn) {
        this[fn] = _fnExternApiFunc(fn);
      }
    }

    this.each(function () {
      // For each initialisation we want to give it a clean initialisation
      // object that can be bashed around
      var o = {};
      var oInit = len > 1 ? // optimisation for single table case
      _fnExtend(o, options, true) : options;
      /*global oInit,_that,emptyInit*/

      var i = 0,
          iLen,
          j,
          jLen,
          k,
          kLen;
      var sId = this.getAttribute('id');
      var bInitHandedOff = false;
      var defaults = DataTable.defaults;
      var $this = $(this);
      /* Sanity check */

      if (this.nodeName.toLowerCase() != 'table') {
        _fnLog(null, 0, 'Non-table node initialisation (' + this.nodeName + ')', 2);

        return;
      }
      /* Backwards compatibility for the defaults */


      _fnCompatOpts(defaults);

      _fnCompatCols(defaults.column);
      /* Convert the camel-case defaults to Hungarian */


      _fnCamelToHungarian(defaults, defaults, true);

      _fnCamelToHungarian(defaults.column, defaults.column, true);
      /* Setting up the initialisation object */


      _fnCamelToHungarian(defaults, $.extend(oInit, $this.data()));
      /* Check to see if we are re-initialising a table */


      var allSettings = DataTable.settings;

      for (i = 0, iLen = allSettings.length; i < iLen; i++) {
        var s = allSettings[i];
        /* Base check on table node */

        if (s.nTable == this || s.nTHead.parentNode == this || s.nTFoot && s.nTFoot.parentNode == this) {
          var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
          var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;

          if (emptyInit || bRetrieve) {
            return s.oInstance;
          } else if (bDestroy) {
            s.oInstance.fnDestroy();
            break;
          } else {
            _fnLog(s, 0, 'Cannot reinitialise DataTable', 3);

            return;
          }
        }
        /* If the element we are initialising has the same ID as a table which was previously
         * initialised, but the table nodes don't match (from before) then we destroy the old
         * instance by simply deleting it. This is under the assumption that the table has been
         * destroyed by other methods. Anyone using non-id selectors will need to do this manually
         */


        if (s.sTableId == this.id) {
          allSettings.splice(i, 1);
          break;
        }
      }
      /* Ensure the table has an ID - required for accessibility */


      if (sId === null || sId === "") {
        sId = "DataTables_Table_" + DataTable.ext._unique++;
        this.id = sId;
      }
      /* Create the settings object for this table and set some of the default parameters */


      var oSettings = $.extend(true, {}, DataTable.models.oSettings, {
        "sDestroyWidth": $this[0].style.width,
        "sInstance": sId,
        "sTableId": sId
      });
      oSettings.nTable = this;
      oSettings.oApi = _that.internal;
      oSettings.oInit = oInit;
      allSettings.push(oSettings); // Need to add the instance after the instance after the settings object has been added
      // to the settings array, so we can self reference the table instance if more than one

      oSettings.oInstance = _that.length === 1 ? _that : $this.dataTable(); // Backwards compatibility, before we apply all the defaults

      _fnCompatOpts(oInit);

      if (oInit.oLanguage) {
        _fnLanguageCompat(oInit.oLanguage);
      } // If the length menu is given, but the init display length is not, use the length menu


      if (oInit.aLengthMenu && !oInit.iDisplayLength) {
        oInit.iDisplayLength = $.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
      } // Apply the defaults and init options to make a single init object will all
      // options defined from defaults and instance options.


      oInit = _fnExtend($.extend(true, {}, defaults), oInit); // Map the initialisation options onto the settings object

      _fnMap(oSettings.oFeatures, oInit, ["bPaginate", "bLengthChange", "bFilter", "bSort", "bSortMulti", "bInfo", "bProcessing", "bAutoWidth", "bSortClasses", "bServerSide", "bDeferRender"]);

      _fnMap(oSettings, oInit, ["asStripeClasses", "ajax", "fnServerData", "fnFormatNumber", "sServerMethod", "aaSorting", "aaSortingFixed", "aLengthMenu", "sPaginationType", "sAjaxSource", "sAjaxDataProp", "iStateDuration", "sDom", "bSortCellsTop", "iTabIndex", "fnStateLoadCallback", "fnStateSaveCallback", "renderer", "searchDelay", "rowId", ["iCookieDuration", "iStateDuration"], // backwards compat
      ["oSearch", "oPreviousSearch"], ["aoSearchCols", "aoPreSearchCols"], ["iDisplayLength", "_iDisplayLength"]]);

      _fnMap(oSettings.oScroll, oInit, [["sScrollX", "sX"], ["sScrollXInner", "sXInner"], ["sScrollY", "sY"], ["bScrollCollapse", "bCollapse"]]);

      _fnMap(oSettings.oLanguage, oInit, "fnInfoCallback");
      /* Callback functions which are array driven */


      _fnCallbackReg(oSettings, 'aoDrawCallback', oInit.fnDrawCallback, 'user');

      _fnCallbackReg(oSettings, 'aoServerParams', oInit.fnServerParams, 'user');

      _fnCallbackReg(oSettings, 'aoStateSaveParams', oInit.fnStateSaveParams, 'user');

      _fnCallbackReg(oSettings, 'aoStateLoadParams', oInit.fnStateLoadParams, 'user');

      _fnCallbackReg(oSettings, 'aoStateLoaded', oInit.fnStateLoaded, 'user');

      _fnCallbackReg(oSettings, 'aoRowCallback', oInit.fnRowCallback, 'user');

      _fnCallbackReg(oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow, 'user');

      _fnCallbackReg(oSettings, 'aoHeaderCallback', oInit.fnHeaderCallback, 'user');

      _fnCallbackReg(oSettings, 'aoFooterCallback', oInit.fnFooterCallback, 'user');

      _fnCallbackReg(oSettings, 'aoInitComplete', oInit.fnInitComplete, 'user');

      _fnCallbackReg(oSettings, 'aoPreDrawCallback', oInit.fnPreDrawCallback, 'user');

      oSettings.rowIdFn = _fnGetObjectDataFn(oInit.rowId);
      /* Browser support detection */

      _fnBrowserDetect(oSettings);

      var oClasses = oSettings.oClasses;
      $.extend(oClasses, DataTable.ext.classes, oInit.oClasses);
      $this.addClass(oClasses.sTable);

      if (oSettings.iInitDisplayStart === undefined) {
        /* Display start point, taking into account the save saving */
        oSettings.iInitDisplayStart = oInit.iDisplayStart;
        oSettings._iDisplayStart = oInit.iDisplayStart;
      }

      if (oInit.iDeferLoading !== null) {
        oSettings.bDeferLoading = true;
        var tmp = $.isArray(oInit.iDeferLoading);
        oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
        oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
      }
      /* Language definitions */


      var oLanguage = oSettings.oLanguage;
      $.extend(true, oLanguage, oInit.oLanguage);

      if (oLanguage.sUrl) {
        /* Get the language definitions from a file - because this Ajax call makes the language
         * get async to the remainder of this function we use bInitHandedOff to indicate that
         * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
         */
        $.ajax({
          dataType: 'json',
          url: oLanguage.sUrl,
          success: function success(json) {
            _fnLanguageCompat(json);

            _fnCamelToHungarian(defaults.oLanguage, json);

            $.extend(true, oLanguage, json);

            _fnInitialise(oSettings);
          },
          error: function error() {
            // Error occurred loading language file, continue on as best we can
            _fnInitialise(oSettings);
          }
        });
        bInitHandedOff = true;
      }
      /*
       * Stripes
       */


      if (oInit.asStripeClasses === null) {
        oSettings.asStripeClasses = [oClasses.sStripeOdd, oClasses.sStripeEven];
      }
      /* Remove row stripe classes if they are already on the table row */


      var stripeClasses = oSettings.asStripeClasses;
      var rowOne = $this.children('tbody').find('tr').eq(0);

      if ($.inArray(true, $.map(stripeClasses, function (el, i) {
        return rowOne.hasClass(el);
      })) !== -1) {
        $('tbody tr', this).removeClass(stripeClasses.join(' '));
        oSettings.asDestroyStripes = stripeClasses.slice();
      }
      /*
       * Columns
       * See if we should load columns automatically or use defined ones
       */


      var anThs = [];
      var aoColumnsInit;
      var nThead = this.getElementsByTagName('thead');

      if (nThead.length !== 0) {
        _fnDetectHeader(oSettings.aoHeader, nThead[0]);

        anThs = _fnGetUniqueThs(oSettings);
      }
      /* If not given a column array, generate one with nulls */


      if (oInit.aoColumns === null) {
        aoColumnsInit = [];

        for (i = 0, iLen = anThs.length; i < iLen; i++) {
          aoColumnsInit.push(null);
        }
      } else {
        aoColumnsInit = oInit.aoColumns;
      }
      /* Add the columns */


      for (i = 0, iLen = aoColumnsInit.length; i < iLen; i++) {
        _fnAddColumn(oSettings, anThs ? anThs[i] : null);
      }
      /* Apply the column definitions */


      _fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
        _fnColumnOptions(oSettings, iCol, oDef);
      });
      /* HTML5 attribute detection - build an mData object automatically if the
       * attributes are found
       */


      if (rowOne.length) {
        var a = function a(cell, name) {
          return cell.getAttribute('data-' + name) !== null ? name : null;
        };

        $(rowOne[0]).children('th, td').each(function (i, cell) {
          var col = oSettings.aoColumns[i];

          if (col.mData === i) {
            var sort = a(cell, 'sort') || a(cell, 'order');
            var filter = a(cell, 'filter') || a(cell, 'search');

            if (sort !== null || filter !== null) {
              col.mData = {
                _: i + '.display',
                sort: sort !== null ? i + '.@data-' + sort : undefined,
                type: sort !== null ? i + '.@data-' + sort : undefined,
                filter: filter !== null ? i + '.@data-' + filter : undefined
              };

              _fnColumnOptions(oSettings, i);
            }
          }
        });
      }

      var features = oSettings.oFeatures;

      var loadedInit = function loadedInit() {
        /*
         * Sorting
         * @todo For modularisation (1.11) this needs to do into a sort start up handler
         */
        // If aaSorting is not defined, then we use the first indicator in asSorting
        // in case that has been altered, so the default sort reflects that option
        if (oInit.aaSorting === undefined) {
          var sorting = oSettings.aaSorting;

          for (i = 0, iLen = sorting.length; i < iLen; i++) {
            sorting[i][1] = oSettings.aoColumns[i].asSorting[0];
          }
        }
        /* Do a first pass on the sorting classes (allows any size changes to be taken into
         * account, and also will apply sorting disabled classes if disabled
         */


        _fnSortingClasses(oSettings);

        if (features.bSort) {
          _fnCallbackReg(oSettings, 'aoDrawCallback', function () {
            if (oSettings.bSorted) {
              var aSort = _fnSortFlatten(oSettings);

              var sortedColumns = {};
              $.each(aSort, function (i, val) {
                sortedColumns[val.src] = val.dir;
              });

              _fnCallbackFire(oSettings, null, 'order', [oSettings, aSort, sortedColumns]);

              _fnSortAria(oSettings);
            }
          });
        }

        _fnCallbackReg(oSettings, 'aoDrawCallback', function () {
          if (oSettings.bSorted || _fnDataSource(oSettings) === 'ssp' || features.bDeferRender) {
            _fnSortingClasses(oSettings);
          }
        }, 'sc');
        /*
         * Final init
         * Cache the header, body and footer as required, creating them if needed
         */
        // Work around for Webkit bug 83867 - store the caption-side before removing from doc


        var captions = $this.children('caption').each(function () {
          this._captionSide = $(this).css('caption-side');
        });
        var thead = $this.children('thead');

        if (thead.length === 0) {
          thead = $('<thead/>').appendTo($this);
        }

        oSettings.nTHead = thead[0];
        var tbody = $this.children('tbody');

        if (tbody.length === 0) {
          tbody = $('<tbody/>').appendTo($this);
        }

        oSettings.nTBody = tbody[0];
        var tfoot = $this.children('tfoot');

        if (tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "")) {
          // If we are a scrolling table, and no footer has been given, then we need to create
          // a tfoot element for the caption element to be appended to
          tfoot = $('<tfoot/>').appendTo($this);
        }

        if (tfoot.length === 0 || tfoot.children().length === 0) {
          $this.addClass(oClasses.sNoFooter);
        } else if (tfoot.length > 0) {
          oSettings.nTFoot = tfoot[0];

          _fnDetectHeader(oSettings.aoFooter, oSettings.nTFoot);
        }
        /* Check if there is data passing into the constructor */


        if (oInit.aaData) {
          for (i = 0; i < oInit.aaData.length; i++) {
            _fnAddData(oSettings, oInit.aaData[i]);
          }
        } else if (oSettings.bDeferLoading || _fnDataSource(oSettings) == 'dom') {
          /* Grab the data from the page - only do this when deferred loading or no Ajax
           * source since there is no point in reading the DOM data if we are then going
           * to replace it with Ajax data
           */
          _fnAddTr(oSettings, $(oSettings.nTBody).children('tr'));
        }
        /* Copy the data index array */


        oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
        /* Initialisation complete - table can be drawn */

        oSettings.bInitialised = true;
        /* Check if we need to initialise the table (it might not have been handed off to the
         * language processor)
         */

        if (bInitHandedOff === false) {
          _fnInitialise(oSettings);
        }
      };
      /* Must be done after everything which can be overridden by the state saving! */


      if (oInit.bStateSave) {
        features.bStateSave = true;

        _fnCallbackReg(oSettings, 'aoDrawCallback', _fnSaveState, 'state_save');

        _fnLoadState(oSettings, oInit, loadedInit);
      } else {
        loadedInit();
      }
    });
    _that = null;
    return this;
  };
  /*
   * It is useful to have variables which are scoped locally so only the
   * DataTables functions can access them and they don't leak into global space.
   * At the same time these functions are often useful over multiple files in the
   * core and API, so we list, or at least document, all variables which are used
   * by DataTables as private variables here. This also ensures that there is no
   * clashing of variable names and that they can easily referenced for reuse.
   */
  // Defined else where
  //  _selector_run
  //  _selector_opts
  //  _selector_first
  //  _selector_row_indexes


  var _ext; // DataTable.ext


  var _Api2; // DataTable.Api


  var _api_register; // DataTable.Api.register


  var _api_registerPlural; // DataTable.Api.registerPlural


  var _re_dic = {};
  var _re_new_lines = /[\r\n]/g;
  var _re_html = /<.*?>/g; // This is not strict ISO8601 - Date.parse() is quite lax, although
  // implementations differ between browsers.

  var _re_date = /^\d{2,4}[\.\/\-]\d{1,2}[\.\/\-]\d{1,2}([T ]{1}\d{1,2}[:\.]\d{2}([\.:]\d{2})?)?$/; // Escape regular expression special characters

  var _re_escape_regex = new RegExp('(\\' + ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-'].join('|\\') + ')', 'g'); // http://en.wikipedia.org/wiki/Foreign_exchange_market
  // - \u20BD - Russian ruble.
  // - \u20a9 - South Korean Won
  // - \u20BA - Turkish Lira
  // - \u20B9 - Indian Rupee
  // - R - Brazil (R$) and South Africa
  // - fr - Swiss Franc
  // - kr - Swedish krona, Norwegian krone and Danish krone
  // - \u2009 is thin space and \u202F is narrow no-break space, both used in many
  //   standards as thousands separators.


  var _re_formatted_numeric = /[',$£€¥%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;

  var _empty = function _empty(d) {
    return !d || d === true || d === '-' ? true : false;
  };

  var _intVal = function _intVal(s) {
    var integer = parseInt(s, 10);
    return !isNaN(integer) && isFinite(s) ? integer : null;
  }; // Convert from a formatted number with characters other than `.` as the
  // decimal place, to a Javascript number


  var _numToDecimal = function _numToDecimal(num, decimalPoint) {
    // Cache created regular expressions for speed as this function is called often
    if (!_re_dic[decimalPoint]) {
      _re_dic[decimalPoint] = new RegExp(_fnEscapeRegex(decimalPoint), 'g');
    }

    return typeof num === 'string' && decimalPoint !== '.' ? num.replace(/\./g, '').replace(_re_dic[decimalPoint], '.') : num;
  };

  var _isNumber = function _isNumber(d, decimalPoint, formatted) {
    var strType = typeof d === 'string'; // If empty return immediately so there must be a number if it is a
    // formatted string (this stops the string "k", or "kr", etc being detected
    // as a formatted number for currency

    if (_empty(d)) {
      return true;
    }

    if (decimalPoint && strType) {
      d = _numToDecimal(d, decimalPoint);
    }

    if (formatted && strType) {
      d = d.replace(_re_formatted_numeric, '');
    }

    return !isNaN(parseFloat(d)) && isFinite(d);
  }; // A string without HTML in it can be considered to be HTML still


  var _isHtml = function _isHtml(d) {
    return _empty(d) || typeof d === 'string';
  };

  var _htmlNumeric = function _htmlNumeric(d, decimalPoint, formatted) {
    if (_empty(d)) {
      return true;
    }

    var html = _isHtml(d);

    return !html ? null : _isNumber(_stripHtml(d), decimalPoint, formatted) ? true : null;
  };

  var _pluck = function _pluck(a, prop, prop2) {
    var out = [];
    var i = 0,
        ien = a.length; // Could have the test in the loop for slightly smaller code, but speed
    // is essential here

    if (prop2 !== undefined) {
      for (; i < ien; i++) {
        if (a[i] && a[i][prop]) {
          out.push(a[i][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        if (a[i]) {
          out.push(a[i][prop]);
        }
      }
    }

    return out;
  }; // Basically the same as _pluck, but rather than looping over `a` we use `order`
  // as the indexes to pick from `a`


  var _pluck_order = function _pluck_order(a, order, prop, prop2) {
    var out = [];
    var i = 0,
        ien = order.length; // Could have the test in the loop for slightly smaller code, but speed
    // is essential here

    if (prop2 !== undefined) {
      for (; i < ien; i++) {
        if (a[order[i]][prop]) {
          out.push(a[order[i]][prop][prop2]);
        }
      }
    } else {
      for (; i < ien; i++) {
        out.push(a[order[i]][prop]);
      }
    }

    return out;
  };

  var _range = function _range(len, start) {
    var out = [];
    var end;

    if (start === undefined) {
      start = 0;
      end = len;
    } else {
      end = start;
      start = len;
    }

    for (var i = start; i < end; i++) {
      out.push(i);
    }

    return out;
  };

  var _removeEmpty = function _removeEmpty(a) {
    var out = [];

    for (var i = 0, ien = a.length; i < ien; i++) {
      if (a[i]) {
        // careful - will remove all falsy values!
        out.push(a[i]);
      }
    }

    return out;
  };

  var _stripHtml = function _stripHtml(d) {
    return d.replace(_re_html, '');
  };
  /**
   * Determine if all values in the array are unique. This means we can short
   * cut the _unique method at the cost of a single loop. A sorted array is used
   * to easily check the values.
   *
   * @param  {array} src Source array
   * @return {boolean} true if all unique, false otherwise
   * @ignore
   */


  var _areAllUnique = function _areAllUnique(src) {
    if (src.length < 2) {
      return true;
    }

    var sorted = src.slice().sort();
    var last = sorted[0];

    for (var i = 1, ien = sorted.length; i < ien; i++) {
      if (sorted[i] === last) {
        return false;
      }

      last = sorted[i];
    }

    return true;
  };
  /**
   * Find the unique elements in a source array.
   *
   * @param  {array} src Source array
   * @return {array} Array of unique items
   * @ignore
   */


  var _unique = function _unique(src) {
    if (_areAllUnique(src)) {
      return src.slice();
    } // A faster unique method is to use object keys to identify used values,
    // but this doesn't work with arrays or objects, which we must also
    // consider. See jsperf.com/compare-array-unique-versions/4 for more
    // information.


    var out = [],
        val,
        i,
        ien = src.length,
        j,
        k = 0;

    again: for (i = 0; i < ien; i++) {
      val = src[i];

      for (j = 0; j < k; j++) {
        if (out[j] === val) {
          continue again;
        }
      }

      out.push(val);
      k++;
    }

    return out;
  };
  /**
   * DataTables utility methods
   * 
   * This namespace provides helper methods that DataTables uses internally to
   * create a DataTable, but which are not exclusively used only for DataTables.
   * These methods can be used by extension authors to save the duplication of
   * code.
   *
   *  @namespace
   */


  DataTable.util = {
    /**
     * Throttle the calls to a function. Arguments and context are maintained
     * for the throttled function.
     *
     * @param {function} fn Function to be called
     * @param {integer} freq Call frequency in mS
     * @return {function} Wrapped function
     */
    throttle: function throttle(fn, freq) {
      var frequency = freq !== undefined ? freq : 200,
          last,
          timer;
      return function () {
        var that = this,
            now = +new Date(),
            args = arguments;

        if (last && now < last + frequency) {
          clearTimeout(timer);
          timer = setTimeout(function () {
            last = undefined;
            fn.apply(that, args);
          }, frequency);
        } else {
          last = now;
          fn.apply(that, args);
        }
      };
    },

    /**
     * Escape a string such that it can be used in a regular expression
     *
     *  @param {string} val string to escape
     *  @returns {string} escaped string
     */
    escapeRegex: function escapeRegex(val) {
      return val.replace(_re_escape_regex, '\\$1');
    }
  };
  /**
   * Create a mapping object that allows camel case parameters to be looked up
   * for their Hungarian counterparts. The mapping is stored in a private
   * parameter called `_hungarianMap` which can be accessed on the source object.
   *  @param {object} o
   *  @memberof DataTable#oApi
   */

  function _fnHungarianMap(o) {
    var hungarian = 'a aa ai ao as b fn i m o s ',
        match,
        newKey,
        map = {};
    $.each(o, function (key, val) {
      match = key.match(/^([^A-Z]+?)([A-Z])/);

      if (match && hungarian.indexOf(match[1] + ' ') !== -1) {
        newKey = key.replace(match[0], match[2].toLowerCase());
        map[newKey] = key;

        if (match[1] === 'o') {
          _fnHungarianMap(o[key]);
        }
      }
    });
    o._hungarianMap = map;
  }
  /**
   * Convert from camel case parameters to Hungarian, based on a Hungarian map
   * created by _fnHungarianMap.
   *  @param {object} src The model object which holds all parameters that can be
   *    mapped.
   *  @param {object} user The object to convert from camel case to Hungarian.
   *  @param {boolean} force When set to `true`, properties which already have a
   *    Hungarian value in the `user` object will be overwritten. Otherwise they
   *    won't be.
   *  @memberof DataTable#oApi
   */


  function _fnCamelToHungarian(src, user, force) {
    if (!src._hungarianMap) {
      _fnHungarianMap(src);
    }

    var hungarianKey;
    $.each(user, function (key, val) {
      hungarianKey = src._hungarianMap[key];

      if (hungarianKey !== undefined && (force || user[hungarianKey] === undefined)) {
        // For objects, we need to buzz down into the object to copy parameters
        if (hungarianKey.charAt(0) === 'o') {
          // Copy the camelCase options over to the hungarian
          if (!user[hungarianKey]) {
            user[hungarianKey] = {};
          }

          $.extend(true, user[hungarianKey], user[key]);

          _fnCamelToHungarian(src[hungarianKey], user[hungarianKey], force);
        } else {
          user[hungarianKey] = user[key];
        }
      }
    });
  }
  /**
   * Language compatibility - when certain options are given, and others aren't, we
   * need to duplicate the values over, in order to provide backwards compatibility
   * with older language files.
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnLanguageCompat(lang) {
    var defaults = DataTable.defaults.oLanguage;
    var zeroRecords = lang.sZeroRecords;
    /* Backwards compatibility - if there is no sEmptyTable given, then use the same as
     * sZeroRecords - assuming that is given.
     */

    if (!lang.sEmptyTable && zeroRecords && defaults.sEmptyTable === "No data available in table") {
      _fnMap(lang, lang, 'sZeroRecords', 'sEmptyTable');
    }
    /* Likewise with loading records */


    if (!lang.sLoadingRecords && zeroRecords && defaults.sLoadingRecords === "Loading...") {
      _fnMap(lang, lang, 'sZeroRecords', 'sLoadingRecords');
    } // Old parameter name of the thousands separator mapped onto the new


    if (lang.sInfoThousands) {
      lang.sThousands = lang.sInfoThousands;
    }

    var decimal = lang.sDecimal;

    if (decimal) {
      _addNumericSort(decimal);
    }
  }
  /**
   * Map one parameter onto another
   *  @param {object} o Object to map
   *  @param {*} knew The new parameter name
   *  @param {*} old The old parameter name
   */


  var _fnCompatMap = function _fnCompatMap(o, knew, old) {
    if (o[knew] !== undefined) {
      o[old] = o[knew];
    }
  };
  /**
   * Provide backwards compatibility for the main DT options. Note that the new
   * options are mapped onto the old parameters, so this is an external interface
   * change only.
   *  @param {object} init Object to map
   */


  function _fnCompatOpts(init) {
    _fnCompatMap(init, 'ordering', 'bSort');

    _fnCompatMap(init, 'orderMulti', 'bSortMulti');

    _fnCompatMap(init, 'orderClasses', 'bSortClasses');

    _fnCompatMap(init, 'orderCellsTop', 'bSortCellsTop');

    _fnCompatMap(init, 'order', 'aaSorting');

    _fnCompatMap(init, 'orderFixed', 'aaSortingFixed');

    _fnCompatMap(init, 'paging', 'bPaginate');

    _fnCompatMap(init, 'pagingType', 'sPaginationType');

    _fnCompatMap(init, 'pageLength', 'iDisplayLength');

    _fnCompatMap(init, 'searching', 'bFilter'); // Boolean initialisation of x-scrolling


    if (typeof init.sScrollX === 'boolean') {
      init.sScrollX = init.sScrollX ? '100%' : '';
    }

    if (typeof init.scrollX === 'boolean') {
      init.scrollX = init.scrollX ? '100%' : '';
    } // Column search objects are in an array, so it needs to be converted
    // element by element


    var searchCols = init.aoSearchCols;

    if (searchCols) {
      for (var i = 0, ien = searchCols.length; i < ien; i++) {
        if (searchCols[i]) {
          _fnCamelToHungarian(DataTable.models.oSearch, searchCols[i]);
        }
      }
    }
  }
  /**
   * Provide backwards compatibility for column options. Note that the new options
   * are mapped onto the old parameters, so this is an external interface change
   * only.
   *  @param {object} init Object to map
   */


  function _fnCompatCols(init) {
    _fnCompatMap(init, 'orderable', 'bSortable');

    _fnCompatMap(init, 'orderData', 'aDataSort');

    _fnCompatMap(init, 'orderSequence', 'asSorting');

    _fnCompatMap(init, 'orderDataType', 'sortDataType'); // orderData can be given as an integer


    var dataSort = init.aDataSort;

    if (typeof dataSort === 'number' && !$.isArray(dataSort)) {
      init.aDataSort = [dataSort];
    }
  }
  /**
   * Browser feature detection for capabilities, quirks
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnBrowserDetect(settings) {
    // We don't need to do this every time DataTables is constructed, the values
    // calculated are specific to the browser and OS configuration which we
    // don't expect to change between initialisations
    if (!DataTable.__browser) {
      var browser = {};
      DataTable.__browser = browser; // Scrolling feature / quirks detection

      var n = $('<div/>').css({
        position: 'fixed',
        top: 0,
        left: $(window).scrollLeft() * -1,
        // allow for scrolling
        height: 1,
        width: 1,
        overflow: 'hidden'
      }).append($('<div/>').css({
        position: 'absolute',
        top: 1,
        left: 1,
        width: 100,
        overflow: 'scroll'
      }).append($('<div/>').css({
        width: '100%',
        height: 10
      }))).appendTo('body');
      var outer = n.children();
      var inner = outer.children(); // Numbers below, in order, are:
      // inner.offsetWidth, inner.clientWidth, outer.offsetWidth, outer.clientWidth
      //
      // IE6 XP:                           100 100 100  83
      // IE7 Vista:                        100 100 100  83
      // IE 8+ Windows:                     83  83 100  83
      // Evergreen Windows:                 83  83 100  83
      // Evergreen Mac with scrollbars:     85  85 100  85
      // Evergreen Mac without scrollbars: 100 100 100 100
      // Get scrollbar width

      browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth; // IE6/7 will oversize a width 100% element inside a scrolling element, to
      // include the width of the scrollbar, while other browsers ensure the inner
      // element is contained without forcing scrolling

      browser.bScrollOversize = inner[0].offsetWidth === 100 && outer[0].clientWidth !== 100; // In rtl text layout, some browsers (most, but not all) will place the
      // scrollbar on the left, rather than the right.

      browser.bScrollbarLeft = Math.round(inner.offset().left) !== 1; // IE8- don't provide height and width for getBoundingClientRect

      browser.bBounding = n[0].getBoundingClientRect().width ? true : false;
      n.remove();
    }

    $.extend(settings.oBrowser, DataTable.__browser);
    settings.oScroll.iBarWidth = DataTable.__browser.barWidth;
  }
  /**
   * Array.prototype reduce[Right] method, used for browsers which don't support
   * JS 1.6. Done this way to reduce code size, since we iterate either way
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnReduce(that, fn, init, start, end, inc) {
    var i = start,
        value,
        isSet = false;

    if (init !== undefined) {
      value = init;
      isSet = true;
    }

    while (i !== end) {
      if (!that.hasOwnProperty(i)) {
        continue;
      }

      value = isSet ? fn(value, that[i], i, that) : that[i];
      isSet = true;
      i += inc;
    }

    return value;
  }
  /**
   * Add a column to the list used for the table with default values
   *  @param {object} oSettings dataTables settings object
   *  @param {node} nTh The th element for this column
   *  @memberof DataTable#oApi
   */


  function _fnAddColumn(oSettings, nTh) {
    // Add column to aoColumns array
    var oDefaults = DataTable.defaults.column;
    var iCol = oSettings.aoColumns.length;
    var oCol = $.extend({}, DataTable.models.oColumn, oDefaults, {
      "nTh": nTh ? nTh : document.createElement('th'),
      "sTitle": oDefaults.sTitle ? oDefaults.sTitle : nTh ? nTh.innerHTML : '',
      "aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
      "mData": oDefaults.mData ? oDefaults.mData : iCol,
      idx: iCol
    });
    oSettings.aoColumns.push(oCol); // Add search object for column specific search. Note that the `searchCols[ iCol ]`
    // passed into extend can be undefined. This allows the user to give a default
    // with only some of the parameters defined, and also not give a default

    var searchCols = oSettings.aoPreSearchCols;
    searchCols[iCol] = $.extend({}, DataTable.models.oSearch, searchCols[iCol]); // Use the default column options function to initialise classes etc

    _fnColumnOptions(oSettings, iCol, $(nTh).data());
  }
  /**
   * Apply options for a column
   *  @param {object} oSettings dataTables settings object
   *  @param {int} iCol column index to consider
   *  @param {object} oOptions object with sType, bVisible and bSearchable etc
   *  @memberof DataTable#oApi
   */


  function _fnColumnOptions(oSettings, iCol, oOptions) {
    var oCol = oSettings.aoColumns[iCol];
    var oClasses = oSettings.oClasses;
    var th = $(oCol.nTh); // Try to get width information from the DOM. We can't get it from CSS
    // as we'd need to parse the CSS stylesheet. `width` option can override

    if (!oCol.sWidthOrig) {
      // Width attribute
      oCol.sWidthOrig = th.attr('width') || null; // Style attribute

      var t = (th.attr('style') || '').match(/width:\s*(\d+[pxem%]+)/);

      if (t) {
        oCol.sWidthOrig = t[1];
      }
    }
    /* User specified column options */


    if (oOptions !== undefined && oOptions !== null) {
      // Backwards compatibility
      _fnCompatCols(oOptions); // Map camel case parameters to their Hungarian counterparts


      _fnCamelToHungarian(DataTable.defaults.column, oOptions);
      /* Backwards compatibility for mDataProp */


      if (oOptions.mDataProp !== undefined && !oOptions.mData) {
        oOptions.mData = oOptions.mDataProp;
      }

      if (oOptions.sType) {
        oCol._sManualType = oOptions.sType;
      } // `class` is a reserved word in Javascript, so we need to provide
      // the ability to use a valid name for the camel case input


      if (oOptions.className && !oOptions.sClass) {
        oOptions.sClass = oOptions.className;
      }

      if (oOptions.sClass) {
        th.addClass(oOptions.sClass);
      }

      $.extend(oCol, oOptions);

      _fnMap(oCol, oOptions, "sWidth", "sWidthOrig");
      /* iDataSort to be applied (backwards compatibility), but aDataSort will take
       * priority if defined
       */


      if (oOptions.iDataSort !== undefined) {
        oCol.aDataSort = [oOptions.iDataSort];
      }

      _fnMap(oCol, oOptions, "aDataSort");
    }
    /* Cache the data get and set functions for speed */


    var mDataSrc = oCol.mData;

    var mData = _fnGetObjectDataFn(mDataSrc);

    var mRender = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null;

    var attrTest = function attrTest(src) {
      return typeof src === 'string' && src.indexOf('@') !== -1;
    };

    oCol._bAttrSrc = $.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter));
    oCol._setter = null;

    oCol.fnGetData = function (rowData, type, meta) {
      var innerData = mData(rowData, type, undefined, meta);
      return mRender && type ? mRender(innerData, type, rowData, meta) : innerData;
    };

    oCol.fnSetData = function (rowData, val, meta) {
      return _fnSetObjectDataFn(mDataSrc)(rowData, val, meta);
    }; // Indicate if DataTables should read DOM data as an object or array
    // Used in _fnGetRowElements


    if (typeof mDataSrc !== 'number') {
      oSettings._rowReadObject = true;
    }
    /* Feature sorting overrides column specific when off */


    if (!oSettings.oFeatures.bSort) {
      oCol.bSortable = false;
      th.addClass(oClasses.sSortableNone); // Have to add class here as order event isn't called
    }
    /* Check that the class assignment is correct for sorting */


    var bAsc = $.inArray('asc', oCol.asSorting) !== -1;
    var bDesc = $.inArray('desc', oCol.asSorting) !== -1;

    if (!oCol.bSortable || !bAsc && !bDesc) {
      oCol.sSortingClass = oClasses.sSortableNone;
      oCol.sSortingClassJUI = "";
    } else if (bAsc && !bDesc) {
      oCol.sSortingClass = oClasses.sSortableAsc;
      oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
    } else if (!bAsc && bDesc) {
      oCol.sSortingClass = oClasses.sSortableDesc;
      oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
    } else {
      oCol.sSortingClass = oClasses.sSortable;
      oCol.sSortingClassJUI = oClasses.sSortJUI;
    }
  }
  /**
   * Adjust the table column widths for new data. Note: you would probably want to
   * do a redraw after calling this function!
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnAdjustColumnSizing(settings) {
    /* Not interested in doing column width calculation if auto-width is disabled */
    if (settings.oFeatures.bAutoWidth !== false) {
      var columns = settings.aoColumns;

      _fnCalculateColumnWidths(settings);

      for (var i = 0, iLen = columns.length; i < iLen; i++) {
        columns[i].nTh.style.width = columns[i].sWidth;
      }
    }

    var scroll = settings.oScroll;

    if (scroll.sY !== '' || scroll.sX !== '') {
      _fnScrollDraw(settings);
    }

    _fnCallbackFire(settings, null, 'column-sizing', [settings]);
  }
  /**
   * Covert the index of a visible column to the index in the data array (take account
   * of hidden columns)
   *  @param {object} oSettings dataTables settings object
   *  @param {int} iMatch Visible column index to lookup
   *  @returns {int} i the data index
   *  @memberof DataTable#oApi
   */


  function _fnVisibleToColumnIndex(oSettings, iMatch) {
    var aiVis = _fnGetColumns(oSettings, 'bVisible');

    return typeof aiVis[iMatch] === 'number' ? aiVis[iMatch] : null;
  }
  /**
   * Covert the index of an index in the data array and convert it to the visible
   *   column index (take account of hidden columns)
   *  @param {int} iMatch Column index to lookup
   *  @param {object} oSettings dataTables settings object
   *  @returns {int} i the data index
   *  @memberof DataTable#oApi
   */


  function _fnColumnIndexToVisible(oSettings, iMatch) {
    var aiVis = _fnGetColumns(oSettings, 'bVisible');

    var iPos = $.inArray(iMatch, aiVis);
    return iPos !== -1 ? iPos : null;
  }
  /**
   * Get the number of visible columns
   *  @param {object} oSettings dataTables settings object
   *  @returns {int} i the number of visible columns
   *  @memberof DataTable#oApi
   */


  function _fnVisbleColumns(oSettings) {
    var vis = 0; // No reduce in IE8, use a loop for now

    $.each(oSettings.aoColumns, function (i, col) {
      if (col.bVisible && $(col.nTh).css('display') !== 'none') {
        vis++;
      }
    });
    return vis;
  }
  /**
   * Get an array of column indexes that match a given property
   *  @param {object} oSettings dataTables settings object
   *  @param {string} sParam Parameter in aoColumns to look for - typically
   *    bVisible or bSearchable
   *  @returns {array} Array of indexes with matched properties
   *  @memberof DataTable#oApi
   */


  function _fnGetColumns(oSettings, sParam) {
    var a = [];
    $.map(oSettings.aoColumns, function (val, i) {
      if (val[sParam]) {
        a.push(i);
      }
    });
    return a;
  }
  /**
   * Calculate the 'type' of a column
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnColumnTypes(settings) {
    var columns = settings.aoColumns;
    var data = settings.aoData;
    var types = DataTable.ext.type.detect;
    var i, ien, j, jen, k, ken;
    var col, cell, detectedType, cache; // For each column, spin over the 

    for (i = 0, ien = columns.length; i < ien; i++) {
      col = columns[i];
      cache = [];

      if (!col.sType && col._sManualType) {
        col.sType = col._sManualType;
      } else if (!col.sType) {
        for (j = 0, jen = types.length; j < jen; j++) {
          for (k = 0, ken = data.length; k < ken; k++) {
            // Use a cache array so we only need to get the type data
            // from the formatter once (when using multiple detectors)
            if (cache[k] === undefined) {
              cache[k] = _fnGetCellData(settings, k, i, 'type');
            }

            detectedType = types[j](cache[k], settings); // If null, then this type can't apply to this column, so
            // rather than testing all cells, break out. There is an
            // exception for the last type which is `html`. We need to
            // scan all rows since it is possible to mix string and HTML
            // types

            if (!detectedType && j !== types.length - 1) {
              break;
            } // Only a single match is needed for html type since it is
            // bottom of the pile and very similar to string


            if (detectedType === 'html') {
              break;
            }
          } // Type is valid for all data points in the column - use this
          // type


          if (detectedType) {
            col.sType = detectedType;
            break;
          }
        } // Fall back - if no type was detected, always use string


        if (!col.sType) {
          col.sType = 'string';
        }
      }
    }
  }
  /**
   * Take the column definitions and static columns arrays and calculate how
   * they relate to column indexes. The callback function will then apply the
   * definition found for a column to a suitable configuration object.
   *  @param {object} oSettings dataTables settings object
   *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
   *  @param {array} aoCols The aoColumns array that defines columns individually
   *  @param {function} fn Callback function - takes two parameters, the calculated
   *    column index and the definition for that column.
   *  @memberof DataTable#oApi
   */


  function _fnApplyColumnDefs(oSettings, aoColDefs, aoCols, fn) {
    var i, iLen, j, jLen, k, kLen, def;
    var columns = oSettings.aoColumns; // Column definitions with aTargets

    if (aoColDefs) {
      /* Loop over the definitions array - loop in reverse so first instance has priority */
      for (i = aoColDefs.length - 1; i >= 0; i--) {
        def = aoColDefs[i];
        /* Each definition can target multiple columns, as it is an array */

        var aTargets = def.targets !== undefined ? def.targets : def.aTargets;

        if (!$.isArray(aTargets)) {
          aTargets = [aTargets];
        }

        for (j = 0, jLen = aTargets.length; j < jLen; j++) {
          if (typeof aTargets[j] === 'number' && aTargets[j] >= 0) {
            /* Add columns that we don't yet know about */
            while (columns.length <= aTargets[j]) {
              _fnAddColumn(oSettings);
            }
            /* Integer, basic index */


            fn(aTargets[j], def);
          } else if (typeof aTargets[j] === 'number' && aTargets[j] < 0) {
            /* Negative integer, right to left column counting */
            fn(columns.length + aTargets[j], def);
          } else if (typeof aTargets[j] === 'string') {
            /* Class name matching on TH element */
            for (k = 0, kLen = columns.length; k < kLen; k++) {
              if (aTargets[j] == "_all" || $(columns[k].nTh).hasClass(aTargets[j])) {
                fn(k, def);
              }
            }
          }
        }
      }
    } // Statically defined columns array


    if (aoCols) {
      for (i = 0, iLen = aoCols.length; i < iLen; i++) {
        fn(i, aoCols[i]);
      }
    }
  }
  /**
   * Add a data array to the table, creating DOM node etc. This is the parallel to
   * _fnGatherData, but for adding rows from a Javascript source, rather than a
   * DOM source.
   *  @param {object} oSettings dataTables settings object
   *  @param {array} aData data array to be added
   *  @param {node} [nTr] TR element to add to the table - optional. If not given,
   *    DataTables will create a row automatically
   *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
   *    if nTr is.
   *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
   *  @memberof DataTable#oApi
   */


  function _fnAddData(oSettings, aDataIn, nTr, anTds) {
    /* Create the object for storing information about this new row */
    var iRow = oSettings.aoData.length;
    var oData = $.extend(true, {}, DataTable.models.oRow, {
      src: nTr ? 'dom' : 'data',
      idx: iRow
    });
    oData._aData = aDataIn;
    oSettings.aoData.push(oData);
    /* Create the cells */

    var nTd, sThisType;
    var columns = oSettings.aoColumns; // Invalidate the column types as the new data needs to be revalidated

    for (var i = 0, iLen = columns.length; i < iLen; i++) {
      columns[i].sType = null;
    }
    /* Add to the display array */


    oSettings.aiDisplayMaster.push(iRow);
    var id = oSettings.rowIdFn(aDataIn);

    if (id !== undefined) {
      oSettings.aIds[id] = oData;
    }
    /* Create the DOM information, or register it if already present */


    if (nTr || !oSettings.oFeatures.bDeferRender) {
      _fnCreateTr(oSettings, iRow, nTr, anTds);
    }

    return iRow;
  }
  /**
   * Add one or more TR elements to the table. Generally we'd expect to
   * use this for reading data from a DOM sourced table, but it could be
   * used for an TR element. Note that if a TR is given, it is used (i.e.
   * it is not cloned).
   *  @param {object} settings dataTables settings object
   *  @param {array|node|jQuery} trs The TR element(s) to add to the table
   *  @returns {array} Array of indexes for the added rows
   *  @memberof DataTable#oApi
   */


  function _fnAddTr(settings, trs) {
    var row; // Allow an individual node to be passed in

    if (!(trs instanceof $)) {
      trs = $(trs);
    }

    return trs.map(function (i, el) {
      row = _fnGetRowElements(settings, el);
      return _fnAddData(settings, row.data, el, row.cells);
    });
  }
  /**
   * Take a TR element and convert it to an index in aoData
   *  @param {object} oSettings dataTables settings object
   *  @param {node} n the TR element to find
   *  @returns {int} index if the node is found, null if not
   *  @memberof DataTable#oApi
   */


  function _fnNodeToDataIndex(oSettings, n) {
    return n._DT_RowIndex !== undefined ? n._DT_RowIndex : null;
  }
  /**
   * Take a TD element and convert it into a column data index (not the visible index)
   *  @param {object} oSettings dataTables settings object
   *  @param {int} iRow The row number the TD/TH can be found in
   *  @param {node} n The TD/TH element to find
   *  @returns {int} index if the node is found, -1 if not
   *  @memberof DataTable#oApi
   */


  function _fnNodeToColumnIndex(oSettings, iRow, n) {
    return $.inArray(n, oSettings.aoData[iRow].anCells);
  }
  /**
   * Get the data for a given cell from the internal cache, taking into account data mapping
   *  @param {object} settings dataTables settings object
   *  @param {int} rowIdx aoData row id
   *  @param {int} colIdx Column index
   *  @param {string} type data get type ('display', 'type' 'filter' 'sort')
   *  @returns {*} Cell data
   *  @memberof DataTable#oApi
   */


  function _fnGetCellData(settings, rowIdx, colIdx, type) {
    var draw = settings.iDraw;
    var col = settings.aoColumns[colIdx];
    var rowData = settings.aoData[rowIdx]._aData;
    var defaultContent = col.sDefaultContent;
    var cellData = col.fnGetData(rowData, type, {
      settings: settings,
      row: rowIdx,
      col: colIdx
    });

    if (cellData === undefined) {
      if (settings.iDrawError != draw && defaultContent === null) {
        _fnLog(settings, 0, "Requested unknown parameter " + (typeof col.mData == 'function' ? '{function}' : "'" + col.mData + "'") + " for row " + rowIdx + ", column " + colIdx, 4);

        settings.iDrawError = draw;
      }

      return defaultContent;
    } // When the data source is null and a specific data type is requested (i.e.
    // not the original data), we can use default column data


    if ((cellData === rowData || cellData === null) && defaultContent !== null && type !== undefined) {
      cellData = defaultContent;
    } else if (typeof cellData === 'function') {
      // If the data source is a function, then we run it and use the return,
      // executing in the scope of the data object (for instances)
      return cellData.call(rowData);
    }

    if (cellData === null && type == 'display') {
      return '';
    }

    return cellData;
  }
  /**
   * Set the value for a specific cell, into the internal data cache
   *  @param {object} settings dataTables settings object
   *  @param {int} rowIdx aoData row id
   *  @param {int} colIdx Column index
   *  @param {*} val Value to set
   *  @memberof DataTable#oApi
   */


  function _fnSetCellData(settings, rowIdx, colIdx, val) {
    var col = settings.aoColumns[colIdx];
    var rowData = settings.aoData[rowIdx]._aData;
    col.fnSetData(rowData, val, {
      settings: settings,
      row: rowIdx,
      col: colIdx
    });
  } // Private variable that is used to match action syntax in the data property object


  var __reArray = /\[.*?\]$/;
  var __reFn = /\(\)$/;
  /**
   * Split string on periods, taking into account escaped periods
   * @param  {string} str String to split
   * @return {array} Split string
   */

  function _fnSplitObjNotation(str) {
    return $.map(str.match(/(\\.|[^\.])+/g) || [''], function (s) {
      return s.replace(/\\\./g, '.');
    });
  }
  /**
   * Return a function that can be used to get data from a source object, taking
   * into account the ability to use nested objects as a source
   *  @param {string|int|function} mSource The data source for the object
   *  @returns {function} Data get function
   *  @memberof DataTable#oApi
   */


  function _fnGetObjectDataFn(mSource) {
    if ($.isPlainObject(mSource)) {
      /* Build an object of get functions, and wrap them in a single call */
      var o = {};
      $.each(mSource, function (key, val) {
        if (val) {
          o[key] = _fnGetObjectDataFn(val);
        }
      });
      return function (data, type, row, meta) {
        var t = o[type] || o._;
        return t !== undefined ? t(data, type, row, meta) : data;
      };
    } else if (mSource === null) {
      /* Give an empty string for rendering / sorting etc */
      return function (data) {
        // type, row and meta also passed, but not used
        return data;
      };
    } else if (typeof mSource === 'function') {
      return function (data, type, row, meta) {
        return mSource(data, type, row, meta);
      };
    } else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {
      /* If there is a . in the source string then the data source is in a
       * nested object so we loop over the data for each level to get the next
       * level down. On each loop we test for undefined, and if found immediately
       * return. This allows entire objects to be missing and sDefaultContent to
       * be used if defined, rather than throwing an error
       */
      var fetchData = function fetchData(data, type, src) {
        var arrayNotation, funcNotation, out, innerSrc;

        if (src !== "") {
          var a = _fnSplitObjNotation(src);

          for (var i = 0, iLen = a.length; i < iLen; i++) {
            // Check if we are dealing with special notation
            arrayNotation = a[i].match(__reArray);
            funcNotation = a[i].match(__reFn);

            if (arrayNotation) {
              // Array notation
              a[i] = a[i].replace(__reArray, ''); // Condition allows simply [] to be passed in

              if (a[i] !== "") {
                data = data[a[i]];
              }

              out = []; // Get the remainder of the nested object to get

              a.splice(0, i + 1);
              innerSrc = a.join('.'); // Traverse each entry in the array getting the properties requested

              if ($.isArray(data)) {
                for (var j = 0, jLen = data.length; j < jLen; j++) {
                  out.push(fetchData(data[j], type, innerSrc));
                }
              } // If a string is given in between the array notation indicators, that
              // is used to join the strings together, otherwise an array is returned


              var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
              data = join === "" ? out : out.join(join); // The inner call to fetchData has already traversed through the remainder
              // of the source requested, so we exit from the loop

              break;
            } else if (funcNotation) {
              // Function call
              a[i] = a[i].replace(__reFn, '');
              data = data[a[i]]();
              continue;
            }

            if (data === null || data[a[i]] === undefined) {
              return undefined;
            }

            data = data[a[i]];
          }
        }

        return data;
      };

      return function (data, type) {
        // row and meta also passed, but not used
        return fetchData(data, type, mSource);
      };
    } else {
      /* Array or flat object mapping */
      return function (data, type) {
        // row and meta also passed, but not used
        return data[mSource];
      };
    }
  }
  /**
   * Return a function that can be used to set data from a source object, taking
   * into account the ability to use nested objects as a source
   *  @param {string|int|function} mSource The data source for the object
   *  @returns {function} Data set function
   *  @memberof DataTable#oApi
   */


  function _fnSetObjectDataFn(mSource) {
    if ($.isPlainObject(mSource)) {
      /* Unlike get, only the underscore (global) option is used for for
       * setting data since we don't know the type here. This is why an object
       * option is not documented for `mData` (which is read/write), but it is
       * for `mRender` which is read only.
       */
      return _fnSetObjectDataFn(mSource._);
    } else if (mSource === null) {
      /* Nothing to do when the data source is null */
      return function () {};
    } else if (typeof mSource === 'function') {
      return function (data, val, meta) {
        mSource(data, 'set', val, meta);
      };
    } else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {
      /* Like the get, we need to get data from a nested object */
      var setData = function setData(data, val, src) {
        var a = _fnSplitObjNotation(src),
            b;

        var aLast = a[a.length - 1];
        var arrayNotation, funcNotation, o, innerSrc;

        for (var i = 0, iLen = a.length - 1; i < iLen; i++) {
          // Check if we are dealing with an array notation request
          arrayNotation = a[i].match(__reArray);
          funcNotation = a[i].match(__reFn);

          if (arrayNotation) {
            a[i] = a[i].replace(__reArray, '');
            data[a[i]] = []; // Get the remainder of the nested object to set so we can recurse

            b = a.slice();
            b.splice(0, i + 1);
            innerSrc = b.join('.'); // Traverse each entry in the array setting the properties requested

            if ($.isArray(val)) {
              for (var j = 0, jLen = val.length; j < jLen; j++) {
                o = {};
                setData(o, val[j], innerSrc);
                data[a[i]].push(o);
              }
            } else {
              // We've been asked to save data to an array, but it
              // isn't array data to be saved. Best that can be done
              // is to just save the value.
              data[a[i]] = val;
            } // The inner call to setData has already traversed through the remainder
            // of the source and has set the data, thus we can exit here


            return;
          } else if (funcNotation) {
            // Function call
            a[i] = a[i].replace(__reFn, '');
            data = data[a[i]](val);
          } // If the nested object doesn't currently exist - since we are
          // trying to set the value - create it


          if (data[a[i]] === null || data[a[i]] === undefined) {
            data[a[i]] = {};
          }

          data = data[a[i]];
        } // Last item in the input - i.e, the actual set


        if (aLast.match(__reFn)) {
          // Function call
          data = data[aLast.replace(__reFn, '')](val);
        } else {
          // If array notation is used, we just want to strip it and use the property name
          // and assign the value. If it isn't used, then we get the result we want anyway
          data[aLast.replace(__reArray, '')] = val;
        }
      };

      return function (data, val) {
        // meta is also passed in, but not used
        return setData(data, val, mSource);
      };
    } else {
      /* Array or flat object mapping */
      return function (data, val) {
        // meta is also passed in, but not used
        data[mSource] = val;
      };
    }
  }
  /**
   * Return an array with the full table data
   *  @param {object} oSettings dataTables settings object
   *  @returns array {array} aData Master data array
   *  @memberof DataTable#oApi
   */


  function _fnGetDataMaster(settings) {
    return _pluck(settings.aoData, '_aData');
  }
  /**
   * Nuke the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnClearTable(settings) {
    settings.aoData.length = 0;
    settings.aiDisplayMaster.length = 0;
    settings.aiDisplay.length = 0;
    settings.aIds = {};
  }
  /**
  * Take an array of integers (index array) and remove a target integer (value - not
  * the key!)
  *  @param {array} a Index array to target
  *  @param {int} iTarget value to find
  *  @memberof DataTable#oApi
  */


  function _fnDeleteIndex(a, iTarget, splice) {
    var iTargetIndex = -1;

    for (var i = 0, iLen = a.length; i < iLen; i++) {
      if (a[i] == iTarget) {
        iTargetIndex = i;
      } else if (a[i] > iTarget) {
        a[i]--;
      }
    }

    if (iTargetIndex != -1 && splice === undefined) {
      a.splice(iTargetIndex, 1);
    }
  }
  /**
   * Mark cached data as invalid such that a re-read of the data will occur when
   * the cached data is next requested. Also update from the data source object.
   *
   * @param {object} settings DataTables settings object
   * @param {int}    rowIdx   Row index to invalidate
   * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'
   *     or 'data'
   * @param {int}    [colIdx] Column index to invalidate. If undefined the whole
   *     row will be invalidated
   * @memberof DataTable#oApi
   *
   * @todo For the modularisation of v1.11 this will need to become a callback, so
   *   the sort and filter methods can subscribe to it. That will required
   *   initialisation options for sorting, which is why it is not already baked in
   */


  function _fnInvalidate(settings, rowIdx, src, colIdx) {
    var row = settings.aoData[rowIdx];
    var i, ien;

    var cellWrite = function cellWrite(cell, col) {
      // This is very frustrating, but in IE if you just write directly
      // to innerHTML, and elements that are overwritten are GC'ed,
      // even if there is a reference to them elsewhere
      while (cell.childNodes.length) {
        cell.removeChild(cell.firstChild);
      }

      cell.innerHTML = _fnGetCellData(settings, rowIdx, col, 'display');
    }; // Are we reading last data from DOM or the data object?


    if (src === 'dom' || (!src || src === 'auto') && row.src === 'dom') {
      // Read the data from the DOM
      row._aData = _fnGetRowElements(settings, row, colIdx, colIdx === undefined ? undefined : row._aData).data;
    } else {
      // Reading from data object, update the DOM
      var cells = row.anCells;

      if (cells) {
        if (colIdx !== undefined) {
          cellWrite(cells[colIdx], colIdx);
        } else {
          for (i = 0, ien = cells.length; i < ien; i++) {
            cellWrite(cells[i], i);
          }
        }
      }
    } // For both row and cell invalidation, the cached data for sorting and
    // filtering is nulled out


    row._aSortData = null;
    row._aFilterData = null; // Invalidate the type for a specific column (if given) or all columns since
    // the data might have changed

    var cols = settings.aoColumns;

    if (colIdx !== undefined) {
      cols[colIdx].sType = null;
    } else {
      for (i = 0, ien = cols.length; i < ien; i++) {
        cols[i].sType = null;
      } // Update DataTables special `DT_*` attributes for the row


      _fnRowAttributes(settings, row);
    }
  }
  /**
   * Build a data source object from an HTML row, reading the contents of the
   * cells that are in the row.
   *
   * @param {object} settings DataTables settings object
   * @param {node|object} TR element from which to read data or existing row
   *   object from which to re-read the data from the cells
   * @param {int} [colIdx] Optional column index
   * @param {array|object} [d] Data source object. If `colIdx` is given then this
   *   parameter should also be given and will be used to write the data into.
   *   Only the column in question will be written
   * @returns {object} Object with two parameters: `data` the data read, in
   *   document order, and `cells` and array of nodes (they can be useful to the
   *   caller, so rather than needing a second traversal to get them, just return
   *   them from here).
   * @memberof DataTable#oApi
   */


  function _fnGetRowElements(settings, row, colIdx, d) {
    var tds = [],
        td = row.firstChild,
        name,
        col,
        o,
        i = 0,
        contents,
        columns = settings.aoColumns,
        objectRead = settings._rowReadObject; // Allow the data object to be passed in, or construct

    d = d !== undefined ? d : objectRead ? {} : [];

    var attr = function attr(str, td) {
      if (typeof str === 'string') {
        var idx = str.indexOf('@');

        if (idx !== -1) {
          var attr = str.substring(idx + 1);

          var setter = _fnSetObjectDataFn(str);

          setter(d, td.getAttribute(attr));
        }
      }
    }; // Read data from a cell and store into the data object


    var cellProcess = function cellProcess(cell) {
      if (colIdx === undefined || colIdx === i) {
        col = columns[i];
        contents = $.trim(cell.innerHTML);

        if (col && col._bAttrSrc) {
          var setter = _fnSetObjectDataFn(col.mData._);

          setter(d, contents);
          attr(col.mData.sort, cell);
          attr(col.mData.type, cell);
          attr(col.mData.filter, cell);
        } else {
          // Depending on the `data` option for the columns the data can
          // be read to either an object or an array.
          if (objectRead) {
            if (!col._setter) {
              // Cache the setter function
              col._setter = _fnSetObjectDataFn(col.mData);
            }

            col._setter(d, contents);
          } else {
            d[i] = contents;
          }
        }
      }

      i++;
    };

    if (td) {
      // `tr` element was passed in
      while (td) {
        name = td.nodeName.toUpperCase();

        if (name == "TD" || name == "TH") {
          cellProcess(td);
          tds.push(td);
        }

        td = td.nextSibling;
      }
    } else {
      // Existing row object passed in
      tds = row.anCells;

      for (var j = 0, jen = tds.length; j < jen; j++) {
        cellProcess(tds[j]);
      }
    } // Read the ID from the DOM if present


    var rowNode = row.firstChild ? row : row.nTr;

    if (rowNode) {
      var id = rowNode.getAttribute('id');

      if (id) {
        _fnSetObjectDataFn(settings.rowId)(d, id);
      }
    }

    return {
      data: d,
      cells: tds
    };
  }
  /**
   * Create a new TR element (and it's TD children) for a row
   *  @param {object} oSettings dataTables settings object
   *  @param {int} iRow Row to consider
   *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
   *    DataTables will create a row automatically
   *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
   *    if nTr is.
   *  @memberof DataTable#oApi
   */


  function _fnCreateTr(oSettings, iRow, nTrIn, anTds) {
    var row = oSettings.aoData[iRow],
        rowData = row._aData,
        cells = [],
        nTr,
        nTd,
        oCol,
        i,
        iLen;

    if (row.nTr === null) {
      nTr = nTrIn || document.createElement('tr');
      row.nTr = nTr;
      row.anCells = cells;
      /* Use a private property on the node to allow reserve mapping from the node
       * to the aoData array for fast look up
       */

      nTr._DT_RowIndex = iRow;
      /* Special parameters can be given by the data source to be used on the row */

      _fnRowAttributes(oSettings, row);
      /* Process each column */


      for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
        oCol = oSettings.aoColumns[i];
        nTd = nTrIn ? anTds[i] : document.createElement(oCol.sCellType);
        nTd._DT_CellIndex = {
          row: iRow,
          column: i
        };
        cells.push(nTd); // Need to create the HTML if new, or if a rendering function is defined

        if ((!nTrIn || oCol.mRender || oCol.mData !== i) && (!$.isPlainObject(oCol.mData) || oCol.mData._ !== i + '.display')) {
          nTd.innerHTML = _fnGetCellData(oSettings, iRow, i, 'display');
        }
        /* Add user defined class */


        if (oCol.sClass) {
          nTd.className += ' ' + oCol.sClass;
        } // Visibility - add or remove as required


        if (oCol.bVisible && !nTrIn) {
          nTr.appendChild(nTd);
        } else if (!oCol.bVisible && nTrIn) {
          nTd.parentNode.removeChild(nTd);
        }

        if (oCol.fnCreatedCell) {
          oCol.fnCreatedCell.call(oSettings.oInstance, nTd, _fnGetCellData(oSettings, iRow, i), rowData, iRow, i);
        }
      }

      _fnCallbackFire(oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow]);
    } // Remove once webkit bug 131819 and Chromium bug 365619 have been resolved
    // and deployed


    row.nTr.setAttribute('role', 'row');
  }
  /**
   * Add attributes to a row based on the special `DT_*` parameters in a data
   * source object.
   *  @param {object} settings DataTables settings object
   *  @param {object} DataTables row object for the row to be modified
   *  @memberof DataTable#oApi
   */


  function _fnRowAttributes(settings, row) {
    var tr = row.nTr;
    var data = row._aData;

    if (tr) {
      var id = settings.rowIdFn(data);

      if (id) {
        tr.id = id;
      }

      if (data.DT_RowClass) {
        // Remove any classes added by DT_RowClass before
        var a = data.DT_RowClass.split(' ');
        row.__rowc = row.__rowc ? _unique(row.__rowc.concat(a)) : a;
        $(tr).removeClass(row.__rowc.join(' ')).addClass(data.DT_RowClass);
      }

      if (data.DT_RowAttr) {
        $(tr).attr(data.DT_RowAttr);
      }

      if (data.DT_RowData) {
        $(tr).data(data.DT_RowData);
      }
    }
  }
  /**
   * Create the HTML header for the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnBuildHead(oSettings) {
    var i, ien, cell, row, column;
    var thead = oSettings.nTHead;
    var tfoot = oSettings.nTFoot;
    var createHeader = $('th, td', thead).length === 0;
    var classes = oSettings.oClasses;
    var columns = oSettings.aoColumns;

    if (createHeader) {
      row = $('<tr/>').appendTo(thead);
    }

    for (i = 0, ien = columns.length; i < ien; i++) {
      column = columns[i];
      cell = $(column.nTh).addClass(column.sClass);

      if (createHeader) {
        cell.appendTo(row);
      } // 1.11 move into sorting


      if (oSettings.oFeatures.bSort) {
        cell.addClass(column.sSortingClass);

        if (column.bSortable !== false) {
          cell.attr('tabindex', oSettings.iTabIndex).attr('aria-controls', oSettings.sTableId);

          _fnSortAttachListener(oSettings, column.nTh, i);
        }
      }

      if (column.sTitle != cell[0].innerHTML) {
        cell.html(column.sTitle);
      }

      _fnRenderer(oSettings, 'header')(oSettings, cell, column, classes);
    }

    if (createHeader) {
      _fnDetectHeader(oSettings.aoHeader, thead);
    }
    /* ARIA role for the rows */


    $(thead).find('>tr').attr('role', 'row');
    /* Deal with the footer - add classes if required */

    $(thead).find('>tr>th, >tr>td').addClass(classes.sHeaderTH);
    $(tfoot).find('>tr>th, >tr>td').addClass(classes.sFooterTH); // Cache the footer cells. Note that we only take the cells from the first
    // row in the footer. If there is more than one row the user wants to
    // interact with, they need to use the table().foot() method. Note also this
    // allows cells to be used for multiple columns using colspan

    if (tfoot !== null) {
      var cells = oSettings.aoFooter[0];

      for (i = 0, ien = cells.length; i < ien; i++) {
        column = columns[i];
        column.nTf = cells[i].cell;

        if (column.sClass) {
          $(column.nTf).addClass(column.sClass);
        }
      }
    }
  }
  /**
   * Draw the header (or footer) element based on the column visibility states. The
   * methodology here is to use the layout array from _fnDetectHeader, modified for
   * the instantaneous column visibility, to construct the new layout. The grid is
   * traversed over cell at a time in a rows x columns grid fashion, although each
   * cell insert can cover multiple elements in the grid - which is tracks using the
   * aApplied array. Cell inserts in the grid will only occur where there isn't
   * already a cell in that position.
   *  @param {object} oSettings dataTables settings object
   *  @param array {objects} aoSource Layout array from _fnDetectHeader
   *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
   *  @memberof DataTable#oApi
   */


  function _fnDrawHead(oSettings, aoSource, bIncludeHidden) {
    var i, iLen, j, jLen, k, kLen, n, nLocalTr;
    var aoLocal = [];
    var aApplied = [];
    var iColumns = oSettings.aoColumns.length;
    var iRowspan, iColspan;

    if (!aoSource) {
      return;
    }

    if (bIncludeHidden === undefined) {
      bIncludeHidden = false;
    }
    /* Make a copy of the master layout array, but without the visible columns in it */


    for (i = 0, iLen = aoSource.length; i < iLen; i++) {
      aoLocal[i] = aoSource[i].slice();
      aoLocal[i].nTr = aoSource[i].nTr;
      /* Remove any columns which are currently hidden */

      for (j = iColumns - 1; j >= 0; j--) {
        if (!oSettings.aoColumns[j].bVisible && !bIncludeHidden) {
          aoLocal[i].splice(j, 1);
        }
      }
      /* Prep the applied array - it needs an element for each row */


      aApplied.push([]);
    }

    for (i = 0, iLen = aoLocal.length; i < iLen; i++) {
      nLocalTr = aoLocal[i].nTr;
      /* All cells are going to be replaced, so empty out the row */

      if (nLocalTr) {
        while (n = nLocalTr.firstChild) {
          nLocalTr.removeChild(n);
        }
      }

      for (j = 0, jLen = aoLocal[i].length; j < jLen; j++) {
        iRowspan = 1;
        iColspan = 1;
        /* Check to see if there is already a cell (row/colspan) covering our target
         * insert point. If there is, then there is nothing to do.
         */

        if (aApplied[i][j] === undefined) {
          nLocalTr.appendChild(aoLocal[i][j].cell);
          aApplied[i][j] = 1;
          /* Expand the cell to cover as many rows as needed */

          while (aoLocal[i + iRowspan] !== undefined && aoLocal[i][j].cell == aoLocal[i + iRowspan][j].cell) {
            aApplied[i + iRowspan][j] = 1;
            iRowspan++;
          }
          /* Expand the cell to cover as many columns as needed */


          while (aoLocal[i][j + iColspan] !== undefined && aoLocal[i][j].cell == aoLocal[i][j + iColspan].cell) {
            /* Must update the applied array over the rows for the columns */
            for (k = 0; k < iRowspan; k++) {
              aApplied[i + k][j + iColspan] = 1;
            }

            iColspan++;
          }
          /* Do the actual expansion in the DOM */


          $(aoLocal[i][j].cell).attr('rowspan', iRowspan).attr('colspan', iColspan);
        }
      }
    }
  }
  /**
   * Insert the required TR nodes into the table for display
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnDraw(oSettings) {
    /* Provide a pre-callback function which can be used to cancel the draw is false is returned */
    var aPreDraw = _fnCallbackFire(oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings]);

    if ($.inArray(false, aPreDraw) !== -1) {
      _fnProcessingDisplay(oSettings, false);

      return;
    }

    var i, iLen, n;
    var anRows = [];
    var iRowCount = 0;
    var asStripeClasses = oSettings.asStripeClasses;
    var iStripes = asStripeClasses.length;
    var iOpenRows = oSettings.aoOpenRows.length;
    var oLang = oSettings.oLanguage;
    var iInitDisplayStart = oSettings.iInitDisplayStart;
    var bServerSide = _fnDataSource(oSettings) == 'ssp';
    var aiDisplay = oSettings.aiDisplay;
    oSettings.bDrawing = true;
    /* Check and see if we have an initial draw position from state saving */

    if (iInitDisplayStart !== undefined && iInitDisplayStart !== -1) {
      oSettings._iDisplayStart = bServerSide ? iInitDisplayStart : iInitDisplayStart >= oSettings.fnRecordsDisplay() ? 0 : iInitDisplayStart;
      oSettings.iInitDisplayStart = -1;
    }

    var iDisplayStart = oSettings._iDisplayStart;
    var iDisplayEnd = oSettings.fnDisplayEnd();
    /* Server-side processing draw intercept */

    if (oSettings.bDeferLoading) {
      oSettings.bDeferLoading = false;
      oSettings.iDraw++;

      _fnProcessingDisplay(oSettings, false);
    } else if (!bServerSide) {
      oSettings.iDraw++;
    } else if (!oSettings.bDestroying && !_fnAjaxUpdate(oSettings)) {
      return;
    }

    if (aiDisplay.length !== 0) {
      var iStart = bServerSide ? 0 : iDisplayStart;
      var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;

      for (var j = iStart; j < iEnd; j++) {
        var iDataIndex = aiDisplay[j];
        var aoData = oSettings.aoData[iDataIndex];

        if (aoData.nTr === null) {
          _fnCreateTr(oSettings, iDataIndex);
        }

        var nRow = aoData.nTr;
        /* Remove the old striping classes and then add the new one */

        if (iStripes !== 0) {
          var sStripe = asStripeClasses[iRowCount % iStripes];

          if (aoData._sRowStripe != sStripe) {
            $(nRow).removeClass(aoData._sRowStripe).addClass(sStripe);
            aoData._sRowStripe = sStripe;
          }
        } // Row callback functions - might want to manipulate the row
        // iRowCount and j are not currently documented. Are they at all
        // useful?


        _fnCallbackFire(oSettings, 'aoRowCallback', null, [nRow, aoData._aData, iRowCount, j]);

        anRows.push(nRow);
        iRowCount++;
      }
    } else {
      /* Table is empty - create a row with an empty message in it */
      var sZero = oLang.sZeroRecords;

      if (oSettings.iDraw == 1 && _fnDataSource(oSettings) == 'ajax') {
        sZero = oLang.sLoadingRecords;
      } else if (oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0) {
        sZero = oLang.sEmptyTable;
      }

      anRows[0] = $('<tr/>', {
        'class': iStripes ? asStripeClasses[0] : ''
      }).append($('<td />', {
        'valign': 'top',
        'colSpan': _fnVisbleColumns(oSettings),
        'class': oSettings.oClasses.sRowEmpty
      }).html(sZero))[0];
    }
    /* Header and footer callbacks */


    _fnCallbackFire(oSettings, 'aoHeaderCallback', 'header', [$(oSettings.nTHead).children('tr')[0], _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);

    _fnCallbackFire(oSettings, 'aoFooterCallback', 'footer', [$(oSettings.nTFoot).children('tr')[0], _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);

    var body = $(oSettings.nTBody);
    body.children().detach();
    body.append($(anRows));
    /* Call all required callback functions for the end of a draw */

    _fnCallbackFire(oSettings, 'aoDrawCallback', 'draw', [oSettings]);
    /* Draw is complete, sorting and filtering must be as well */


    oSettings.bSorted = false;
    oSettings.bFiltered = false;
    oSettings.bDrawing = false;
  }
  /**
   * Redraw the table - taking account of the various features which are enabled
   *  @param {object} oSettings dataTables settings object
   *  @param {boolean} [holdPosition] Keep the current paging position. By default
   *    the paging is reset to the first page
   *  @memberof DataTable#oApi
   */


  function _fnReDraw(settings, holdPosition) {
    var features = settings.oFeatures,
        sort = features.bSort,
        filter = features.bFilter;

    if (sort) {
      _fnSort(settings);
    }

    if (filter) {
      _fnFilterComplete(settings, settings.oPreviousSearch);
    } else {
      // No filtering, so we want to just use the display master
      settings.aiDisplay = settings.aiDisplayMaster.slice();
    }

    if (holdPosition !== true) {
      settings._iDisplayStart = 0;
    } // Let any modules know about the draw hold position state (used by
    // scrolling internally)


    settings._drawHold = holdPosition;

    _fnDraw(settings);

    settings._drawHold = false;
  }
  /**
   * Add the options to the page HTML for the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnAddOptionsHtml(oSettings) {
    var classes = oSettings.oClasses;
    var table = $(oSettings.nTable);
    var holding = $('<div/>').insertBefore(table); // Holding element for speed

    var features = oSettings.oFeatures; // All DataTables are wrapped in a div

    var insert = $('<div/>', {
      id: oSettings.sTableId + '_wrapper',
      'class': classes.sWrapper + (oSettings.nTFoot ? '' : ' ' + classes.sNoFooter)
    });
    oSettings.nHolding = holding[0];
    oSettings.nTableWrapper = insert[0];
    oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;
    /* Loop over the user set positioning and place the elements as needed */

    var aDom = oSettings.sDom.split('');
    var featureNode, cOption, nNewNode, cNext, sAttr, j;

    for (var i = 0; i < aDom.length; i++) {
      featureNode = null;
      cOption = aDom[i];

      if (cOption == '<') {
        /* New container div */
        nNewNode = $('<div/>')[0];
        /* Check to see if we should append an id and/or a class name to the container */

        cNext = aDom[i + 1];

        if (cNext == "'" || cNext == '"') {
          sAttr = "";
          j = 2;

          while (aDom[i + j] != cNext) {
            sAttr += aDom[i + j];
            j++;
          }
          /* Replace jQuery UI constants @todo depreciated */


          if (sAttr == "H") {
            sAttr = classes.sJUIHeader;
          } else if (sAttr == "F") {
            sAttr = classes.sJUIFooter;
          }
          /* The attribute can be in the format of "#id.class", "#id" or "class" This logic
           * breaks the string into parts and applies them as needed
           */


          if (sAttr.indexOf('.') != -1) {
            var aSplit = sAttr.split('.');
            nNewNode.id = aSplit[0].substr(1, aSplit[0].length - 1);
            nNewNode.className = aSplit[1];
          } else if (sAttr.charAt(0) == "#") {
            nNewNode.id = sAttr.substr(1, sAttr.length - 1);
          } else {
            nNewNode.className = sAttr;
          }

          i += j;
          /* Move along the position array */
        }

        insert.append(nNewNode);
        insert = $(nNewNode);
      } else if (cOption == '>') {
        /* End container div */
        insert = insert.parent();
      } // @todo Move options into their own plugins?
      else if (cOption == 'l' && features.bPaginate && features.bLengthChange) {
          /* Length */
          featureNode = _fnFeatureHtmlLength(oSettings);
        } else if (cOption == 'f' && features.bFilter) {
          /* Filter */
          featureNode = _fnFeatureHtmlFilter(oSettings);
        } else if (cOption == 'r' && features.bProcessing) {
          /* pRocessing */
          featureNode = _fnFeatureHtmlProcessing(oSettings);
        } else if (cOption == 't') {
          /* Table */
          featureNode = _fnFeatureHtmlTable(oSettings);
        } else if (cOption == 'i' && features.bInfo) {
          /* Info */
          featureNode = _fnFeatureHtmlInfo(oSettings);
        } else if (cOption == 'p' && features.bPaginate) {
          /* Pagination */
          featureNode = _fnFeatureHtmlPaginate(oSettings);
        } else if (DataTable.ext.feature.length !== 0) {
          /* Plug-in features */
          var aoFeatures = DataTable.ext.feature;

          for (var k = 0, kLen = aoFeatures.length; k < kLen; k++) {
            if (cOption == aoFeatures[k].cFeature) {
              featureNode = aoFeatures[k].fnInit(oSettings);
              break;
            }
          }
        }
      /* Add to the 2D features array */


      if (featureNode) {
        var aanFeatures = oSettings.aanFeatures;

        if (!aanFeatures[cOption]) {
          aanFeatures[cOption] = [];
        }

        aanFeatures[cOption].push(featureNode);
        insert.append(featureNode);
      }
    }
    /* Built our DOM structure - replace the holding div with what we want */


    holding.replaceWith(insert);
    oSettings.nHolding = null;
  }
  /**
   * Use the DOM source to create up an array of header cells. The idea here is to
   * create a layout grid (array) of rows x columns, which contains a reference
   * to the cell that that point in the grid (regardless of col/rowspan), such that
   * any column / row could be removed and the new grid constructed
   *  @param array {object} aLayout Array to store the calculated layout in
   *  @param {node} nThead The header/footer element for the table
   *  @memberof DataTable#oApi
   */


  function _fnDetectHeader(aLayout, nThead) {
    var nTrs = $(nThead).children('tr');
    var nTr, nCell;
    var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
    var bUnique;

    var fnShiftCol = function fnShiftCol(a, i, j) {
      var k = a[i];

      while (k[j]) {
        j++;
      }

      return j;
    };

    aLayout.splice(0, aLayout.length);
    /* We know how many rows there are in the layout - so prep it */

    for (i = 0, iLen = nTrs.length; i < iLen; i++) {
      aLayout.push([]);
    }
    /* Calculate a layout array */


    for (i = 0, iLen = nTrs.length; i < iLen; i++) {
      nTr = nTrs[i];
      iColumn = 0;
      /* For every cell in the row... */

      nCell = nTr.firstChild;

      while (nCell) {
        if (nCell.nodeName.toUpperCase() == "TD" || nCell.nodeName.toUpperCase() == "TH") {
          /* Get the col and rowspan attributes from the DOM and sanitise them */
          iColspan = nCell.getAttribute('colspan') * 1;
          iRowspan = nCell.getAttribute('rowspan') * 1;
          iColspan = !iColspan || iColspan === 0 || iColspan === 1 ? 1 : iColspan;
          iRowspan = !iRowspan || iRowspan === 0 || iRowspan === 1 ? 1 : iRowspan;
          /* There might be colspan cells already in this row, so shift our target
           * accordingly
           */

          iColShifted = fnShiftCol(aLayout, i, iColumn);
          /* Cache calculation for unique columns */

          bUnique = iColspan === 1 ? true : false;
          /* If there is col / rowspan, copy the information into the layout grid */

          for (l = 0; l < iColspan; l++) {
            for (k = 0; k < iRowspan; k++) {
              aLayout[i + k][iColShifted + l] = {
                "cell": nCell,
                "unique": bUnique
              };
              aLayout[i + k].nTr = nTr;
            }
          }
        }

        nCell = nCell.nextSibling;
      }
    }
  }
  /**
   * Get an array of unique th elements, one for each column
   *  @param {object} oSettings dataTables settings object
   *  @param {node} nHeader automatically detect the layout from this node - optional
   *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
   *  @returns array {node} aReturn list of unique th's
   *  @memberof DataTable#oApi
   */


  function _fnGetUniqueThs(oSettings, nHeader, aLayout) {
    var aReturn = [];

    if (!aLayout) {
      aLayout = oSettings.aoHeader;

      if (nHeader) {
        aLayout = [];

        _fnDetectHeader(aLayout, nHeader);
      }
    }

    for (var i = 0, iLen = aLayout.length; i < iLen; i++) {
      for (var j = 0, jLen = aLayout[i].length; j < jLen; j++) {
        if (aLayout[i][j].unique && (!aReturn[j] || !oSettings.bSortCellsTop)) {
          aReturn[j] = aLayout[i][j].cell;
        }
      }
    }

    return aReturn;
  }
  /**
   * Create an Ajax call based on the table's settings, taking into account that
   * parameters can have multiple forms, and backwards compatibility.
   *
   * @param {object} oSettings dataTables settings object
   * @param {array} data Data to send to the server, required by
   *     DataTables - may be augmented by developer callbacks
   * @param {function} fn Callback function to run when data is obtained
   */


  function _fnBuildAjax(oSettings, data, fn) {
    // Compatibility with 1.9-, allow fnServerData and event to manipulate
    _fnCallbackFire(oSettings, 'aoServerParams', 'serverParams', [data]); // Convert to object based for 1.10+ if using the old array scheme which can
    // come from server-side processing or serverParams


    if (data && $.isArray(data)) {
      var tmp = {};
      var rbracket = /(.*?)\[\]$/;
      $.each(data, function (key, val) {
        var match = val.name.match(rbracket);

        if (match) {
          // Support for arrays
          var name = match[0];

          if (!tmp[name]) {
            tmp[name] = [];
          }

          tmp[name].push(val.value);
        } else {
          tmp[val.name] = val.value;
        }
      });
      data = tmp;
    }

    var ajaxData;
    var ajax = oSettings.ajax;
    var instance = oSettings.oInstance;

    var callback = function callback(json) {
      _fnCallbackFire(oSettings, null, 'xhr', [oSettings, json, oSettings.jqXHR]);

      fn(json);
    };

    if ($.isPlainObject(ajax) && ajax.data) {
      ajaxData = ajax.data;
      var newData = $.isFunction(ajaxData) ? ajaxData(data, oSettings) : // fn can manipulate data or return
      ajaxData; // an object object or array to merge
      // If the function returned something, use that alone

      data = $.isFunction(ajaxData) && newData ? newData : $.extend(true, data, newData); // Remove the data property as we've resolved it already and don't want
      // jQuery to do it again (it is restored at the end of the function)

      delete ajax.data;
    }

    var baseAjax = {
      "data": data,
      "success": function success(json) {
        var error = json.error || json.sError;

        if (error) {
          _fnLog(oSettings, 0, error);
        }

        oSettings.json = json;
        callback(json);
      },
      "dataType": "json",
      "cache": false,
      "type": oSettings.sServerMethod,
      "error": function error(xhr, _error, thrown) {
        var ret = _fnCallbackFire(oSettings, null, 'xhr', [oSettings, null, oSettings.jqXHR]);

        if ($.inArray(true, ret) === -1) {
          if (_error == "parsererror") {
            _fnLog(oSettings, 0, 'Invalid JSON response', 1);
          } else if (xhr.readyState === 4) {
            _fnLog(oSettings, 0, 'Ajax error', 7);
          }
        }

        _fnProcessingDisplay(oSettings, false);
      }
    }; // Store the data submitted for the API

    oSettings.oAjaxData = data; // Allow plug-ins and external processes to modify the data

    _fnCallbackFire(oSettings, null, 'preXhr', [oSettings, data]);

    if (oSettings.fnServerData) {
      // DataTables 1.9- compatibility
      oSettings.fnServerData.call(instance, oSettings.sAjaxSource, $.map(data, function (val, key) {
        // Need to convert back to 1.9 trad format
        return {
          name: key,
          value: val
        };
      }), callback, oSettings);
    } else if (oSettings.sAjaxSource || typeof ajax === 'string') {
      // DataTables 1.9- compatibility
      oSettings.jqXHR = $.ajax($.extend(baseAjax, {
        url: ajax || oSettings.sAjaxSource
      }));
    } else if ($.isFunction(ajax)) {
      // Is a function - let the caller define what needs to be done
      oSettings.jqXHR = ajax.call(instance, data, callback, oSettings);
    } else {
      // Object to extend the base settings
      oSettings.jqXHR = $.ajax($.extend(baseAjax, ajax)); // Restore for next time around

      ajax.data = ajaxData;
    }
  }
  /**
   * Update the table using an Ajax call
   *  @param {object} settings dataTables settings object
   *  @returns {boolean} Block the table drawing or not
   *  @memberof DataTable#oApi
   */


  function _fnAjaxUpdate(settings) {
    if (settings.bAjaxDataGet) {
      settings.iDraw++;

      _fnProcessingDisplay(settings, true);

      _fnBuildAjax(settings, _fnAjaxParameters(settings), function (json) {
        _fnAjaxUpdateDraw(settings, json);
      });

      return false;
    }

    return true;
  }
  /**
   * Build up the parameters in an object needed for a server-side processing
   * request. Note that this is basically done twice, is different ways - a modern
   * method which is used by default in DataTables 1.10 which uses objects and
   * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if
   * the sAjaxSource option is used in the initialisation, or the legacyAjax
   * option is set.
   *  @param {object} oSettings dataTables settings object
   *  @returns {bool} block the table drawing or not
   *  @memberof DataTable#oApi
   */


  function _fnAjaxParameters(settings) {
    var columns = settings.aoColumns,
        columnCount = columns.length,
        features = settings.oFeatures,
        preSearch = settings.oPreviousSearch,
        preColSearch = settings.aoPreSearchCols,
        i,
        data = [],
        dataProp,
        column,
        columnSearch,
        sort = _fnSortFlatten(settings),
        displayStart = settings._iDisplayStart,
        displayLength = features.bPaginate !== false ? settings._iDisplayLength : -1;

    var param = function param(name, value) {
      data.push({
        'name': name,
        'value': value
      });
    }; // DataTables 1.9- compatible method


    param('sEcho', settings.iDraw);
    param('iColumns', columnCount);
    param('sColumns', _pluck(columns, 'sName').join(','));
    param('iDisplayStart', displayStart);
    param('iDisplayLength', displayLength); // DataTables 1.10+ method

    var d = {
      draw: settings.iDraw,
      columns: [],
      order: [],
      start: displayStart,
      length: displayLength,
      search: {
        value: preSearch.sSearch,
        regex: preSearch.bRegex
      }
    };

    for (i = 0; i < columnCount; i++) {
      column = columns[i];
      columnSearch = preColSearch[i];
      dataProp = typeof column.mData == "function" ? 'function' : column.mData;
      d.columns.push({
        data: dataProp,
        name: column.sName,
        searchable: column.bSearchable,
        orderable: column.bSortable,
        search: {
          value: columnSearch.sSearch,
          regex: columnSearch.bRegex
        }
      });
      param("mDataProp_" + i, dataProp);

      if (features.bFilter) {
        param('sSearch_' + i, columnSearch.sSearch);
        param('bRegex_' + i, columnSearch.bRegex);
        param('bSearchable_' + i, column.bSearchable);
      }

      if (features.bSort) {
        param('bSortable_' + i, column.bSortable);
      }
    }

    if (features.bFilter) {
      param('sSearch', preSearch.sSearch);
      param('bRegex', preSearch.bRegex);
    }

    if (features.bSort) {
      $.each(sort, function (i, val) {
        d.order.push({
          column: val.col,
          dir: val.dir
        });
        param('iSortCol_' + i, val.col);
        param('sSortDir_' + i, val.dir);
      });
      param('iSortingCols', sort.length);
    } // If the legacy.ajax parameter is null, then we automatically decide which
    // form to use, based on sAjaxSource


    var legacy = DataTable.ext.legacy.ajax;

    if (legacy === null) {
      return settings.sAjaxSource ? data : d;
    } // Otherwise, if legacy has been specified then we use that to decide on the
    // form


    return legacy ? data : d;
  }
  /**
   * Data the data from the server (nuking the old) and redraw the table
   *  @param {object} oSettings dataTables settings object
   *  @param {object} json json data return from the server.
   *  @param {string} json.sEcho Tracking flag for DataTables to match requests
   *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
   *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
   *  @param {array} json.aaData The data to display on this page
   *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
   *  @memberof DataTable#oApi
   */


  function _fnAjaxUpdateDraw(settings, json) {
    // v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.
    // Support both
    var compat = function compat(old, modern) {
      return json[old] !== undefined ? json[old] : json[modern];
    };

    var data = _fnAjaxDataSrc(settings, json);

    var draw = compat('sEcho', 'draw');
    var recordsTotal = compat('iTotalRecords', 'recordsTotal');
    var recordsFiltered = compat('iTotalDisplayRecords', 'recordsFiltered');

    if (draw) {
      // Protect against out of sequence returns
      if (draw * 1 < settings.iDraw) {
        return;
      }

      settings.iDraw = draw * 1;
    }

    _fnClearTable(settings);

    settings._iRecordsTotal = parseInt(recordsTotal, 10);
    settings._iRecordsDisplay = parseInt(recordsFiltered, 10);

    for (var i = 0, ien = data.length; i < ien; i++) {
      _fnAddData(settings, data[i]);
    }

    settings.aiDisplay = settings.aiDisplayMaster.slice();
    settings.bAjaxDataGet = false;

    _fnDraw(settings);

    if (!settings._bInitComplete) {
      _fnInitComplete(settings, json);
    }

    settings.bAjaxDataGet = true;

    _fnProcessingDisplay(settings, false);
  }
  /**
   * Get the data from the JSON data source to use for drawing a table. Using
   * `_fnGetObjectDataFn` allows the data to be sourced from a property of the
   * source object, or from a processing function.
   *  @param {object} oSettings dataTables settings object
   *  @param  {object} json Data source object / array from the server
   *  @return {array} Array of data to use
   */


  function _fnAjaxDataSrc(oSettings, json) {
    var dataSrc = $.isPlainObject(oSettings.ajax) && oSettings.ajax.dataSrc !== undefined ? oSettings.ajax.dataSrc : oSettings.sAjaxDataProp; // Compatibility with 1.9-.
    // Compatibility with 1.9-. In order to read from aaData, check if the
    // default has been changed, if not, check for aaData

    if (dataSrc === 'data') {
      return json.aaData || json[dataSrc];
    }

    return dataSrc !== "" ? _fnGetObjectDataFn(dataSrc)(json) : json;
  }
  /**
   * Generate the node required for filtering text
   *  @returns {node} Filter control element
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnFeatureHtmlFilter(settings) {
    var classes = settings.oClasses;
    var tableId = settings.sTableId;
    var language = settings.oLanguage;
    var previousSearch = settings.oPreviousSearch;
    var features = settings.aanFeatures;
    var input = '<input type="search" class="' + classes.sFilterInput + '"/>';
    var str = language.sSearch;
    str = str.match(/_INPUT_/) ? str.replace('_INPUT_', input) : str + input;
    var filter = $('<div/>', {
      'id': !features.f ? tableId + '_filter' : null,
      'class': classes.sFilter
    }).append($('<label/>').append(str));

    var searchFn = function searchFn() {
      /* Update all other filter input elements for the new display */
      var n = features.f;
      var val = !this.value ? "" : this.value; // mental IE8 fix :-(

      /* Now do the filter */

      if (val != previousSearch.sSearch) {
        _fnFilterComplete(settings, {
          "sSearch": val,
          "bRegex": previousSearch.bRegex,
          "bSmart": previousSearch.bSmart,
          "bCaseInsensitive": previousSearch.bCaseInsensitive
        }); // Need to redraw, without resorting


        settings._iDisplayStart = 0;

        _fnDraw(settings);
      }
    };

    var searchDelay = settings.searchDelay !== null ? settings.searchDelay : _fnDataSource(settings) === 'ssp' ? 400 : 0;
    var jqFilter = $('input', filter).val(previousSearch.sSearch).attr('placeholder', language.sSearchPlaceholder).on('keyup.DT search.DT input.DT paste.DT cut.DT', searchDelay ? _fnThrottle(searchFn, searchDelay) : searchFn).on('keypress.DT', function (e) {
      /* Prevent form submission */
      if (e.keyCode == 13) {
        return false;
      }
    }).attr('aria-controls', tableId); // Update the input elements whenever the table is filtered

    $(settings.nTable).on('search.dt.DT', function (ev, s) {
      if (settings === s) {
        // IE9 throws an 'unknown error' if document.activeElement is used
        // inside an iframe or frame...
        try {
          if (jqFilter[0] !== document.activeElement) {
            jqFilter.val(previousSearch.sSearch);
          }
        } catch (e) {}
      }
    });
    return filter[0];
  }
  /**
   * Filter the table using both the global filter and column based filtering
   *  @param {object} oSettings dataTables settings object
   *  @param {object} oSearch search information
   *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
   *  @memberof DataTable#oApi
   */


  function _fnFilterComplete(oSettings, oInput, iForce) {
    var oPrevSearch = oSettings.oPreviousSearch;
    var aoPrevSearch = oSettings.aoPreSearchCols;

    var fnSaveFilter = function fnSaveFilter(oFilter) {
      /* Save the filtering values */
      oPrevSearch.sSearch = oFilter.sSearch;
      oPrevSearch.bRegex = oFilter.bRegex;
      oPrevSearch.bSmart = oFilter.bSmart;
      oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
    };

    var fnRegex = function fnRegex(o) {
      // Backwards compatibility with the bEscapeRegex option
      return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;
    }; // Resolve any column types that are unknown due to addition or invalidation
    // @todo As per sort - can this be moved into an event handler?


    _fnColumnTypes(oSettings);
    /* In server-side processing all filtering is done by the server, so no point hanging around here */


    if (_fnDataSource(oSettings) != 'ssp') {
      /* Global filter */
      _fnFilter(oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive);

      fnSaveFilter(oInput);
      /* Now do the individual column filter */

      for (var i = 0; i < aoPrevSearch.length; i++) {
        _fnFilterColumn(oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]), aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive);
      }
      /* Custom filtering */


      _fnFilterCustom(oSettings);
    } else {
      fnSaveFilter(oInput);
    }
    /* Tell the draw function we have been filtering */


    oSettings.bFiltered = true;

    _fnCallbackFire(oSettings, null, 'search', [oSettings]);
  }
  /**
   * Apply custom filtering functions
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnFilterCustom(settings) {
    var filters = DataTable.ext.search;
    var displayRows = settings.aiDisplay;
    var row, rowIdx;

    for (var i = 0, ien = filters.length; i < ien; i++) {
      var rows = []; // Loop over each row and see if it should be included

      for (var j = 0, jen = displayRows.length; j < jen; j++) {
        rowIdx = displayRows[j];
        row = settings.aoData[rowIdx];

        if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {
          rows.push(rowIdx);
        }
      } // So the array reference doesn't break set the results into the
      // existing array


      displayRows.length = 0;
      $.merge(displayRows, rows);
    }
  }
  /**
   * Filter the table on a per-column basis
   *  @param {object} oSettings dataTables settings object
   *  @param {string} sInput string to filter on
   *  @param {int} iColumn column to filter
   *  @param {bool} bRegex treat search string as a regular expression or not
   *  @param {bool} bSmart use smart filtering or not
   *  @param {bool} bCaseInsensitive Do case insenstive matching or not
   *  @memberof DataTable#oApi
   */


  function _fnFilterColumn(settings, searchStr, colIdx, regex, smart, caseInsensitive) {
    if (searchStr === '') {
      return;
    }

    var data;
    var out = [];
    var display = settings.aiDisplay;

    var rpSearch = _fnFilterCreateSearch(searchStr, regex, smart, caseInsensitive);

    for (var i = 0; i < display.length; i++) {
      data = settings.aoData[display[i]]._aFilterData[colIdx];

      if (rpSearch.test(data)) {
        out.push(display[i]);
      }
    }

    settings.aiDisplay = out;
  }
  /**
   * Filter the data table based on user input and draw the table
   *  @param {object} settings dataTables settings object
   *  @param {string} input string to filter on
   *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)
   *  @param {bool} regex treat as a regular expression or not
   *  @param {bool} smart perform smart filtering or not
   *  @param {bool} caseInsensitive Do case insenstive matching or not
   *  @memberof DataTable#oApi
   */


  function _fnFilter(settings, input, force, regex, smart, caseInsensitive) {
    var rpSearch = _fnFilterCreateSearch(input, regex, smart, caseInsensitive);

    var prevSearch = settings.oPreviousSearch.sSearch;
    var displayMaster = settings.aiDisplayMaster;
    var display, invalidated, i;
    var filtered = []; // Need to take account of custom filtering functions - always filter

    if (DataTable.ext.search.length !== 0) {
      force = true;
    } // Check if any of the rows were invalidated


    invalidated = _fnFilterData(settings); // If the input is blank - we just want the full data set

    if (input.length <= 0) {
      settings.aiDisplay = displayMaster.slice();
    } else {
      // New search - start from the master array
      if (invalidated || force || prevSearch.length > input.length || input.indexOf(prevSearch) !== 0 || settings.bSorted // On resort, the display master needs to be
      // re-filtered since indexes will have changed
      ) {
          settings.aiDisplay = displayMaster.slice();
        } // Search the display array


      display = settings.aiDisplay;

      for (i = 0; i < display.length; i++) {
        if (rpSearch.test(settings.aoData[display[i]]._sFilterRow)) {
          filtered.push(display[i]);
        }
      }

      settings.aiDisplay = filtered;
    }
  }
  /**
   * Build a regular expression object suitable for searching a table
   *  @param {string} sSearch string to search for
   *  @param {bool} bRegex treat as a regular expression or not
   *  @param {bool} bSmart perform smart filtering or not
   *  @param {bool} bCaseInsensitive Do case insensitive matching or not
   *  @returns {RegExp} constructed object
   *  @memberof DataTable#oApi
   */


  function _fnFilterCreateSearch(search, regex, smart, caseInsensitive) {
    search = regex ? search : _fnEscapeRegex(search);

    if (smart) {
      /* For smart filtering we want to allow the search to work regardless of
       * word order. We also want double quoted text to be preserved, so word
       * order is important - a la google. So this is what we want to
       * generate:
       * 
       * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
       */
      var a = $.map(search.match(/"[^"]+"|[^ ]+/g) || [''], function (word) {
        if (word.charAt(0) === '"') {
          var m = word.match(/^"(.*)"$/);
          word = m ? m[1] : word;
        }

        return word.replace('"', '');
      });
      search = '^(?=.*?' + a.join(')(?=.*?') + ').*$';
    }

    return new RegExp(search, caseInsensitive ? 'i' : '');
  }
  /**
   * Escape a string such that it can be used in a regular expression
   *  @param {string} sVal string to escape
   *  @returns {string} escaped string
   *  @memberof DataTable#oApi
   */


  var _fnEscapeRegex = DataTable.util.escapeRegex;
  var __filter_div = $('<div>')[0];

  var __filter_div_textContent = __filter_div.textContent !== undefined; // Update the filtering data for each row if needed (by invalidation or first run)


  function _fnFilterData(settings) {
    var columns = settings.aoColumns;
    var column;
    var i, j, ien, jen, filterData, cellData, row;
    var fomatters = DataTable.ext.type.search;
    var wasInvalidated = false;

    for (i = 0, ien = settings.aoData.length; i < ien; i++) {
      row = settings.aoData[i];

      if (!row._aFilterData) {
        filterData = [];

        for (j = 0, jen = columns.length; j < jen; j++) {
          column = columns[j];

          if (column.bSearchable) {
            cellData = _fnGetCellData(settings, i, j, 'filter');

            if (fomatters[column.sType]) {
              cellData = fomatters[column.sType](cellData);
            } // Search in DataTables 1.10 is string based. In 1.11 this
            // should be altered to also allow strict type checking.


            if (cellData === null) {
              cellData = '';
            }

            if (typeof cellData !== 'string' && cellData.toString) {
              cellData = cellData.toString();
            }
          } else {
            cellData = '';
          } // If it looks like there is an HTML entity in the string,
          // attempt to decode it so sorting works as expected. Note that
          // we could use a single line of jQuery to do this, but the DOM
          // method used here is much faster http://jsperf.com/html-decode


          if (cellData.indexOf && cellData.indexOf('&') !== -1) {
            __filter_div.innerHTML = cellData;
            cellData = __filter_div_textContent ? __filter_div.textContent : __filter_div.innerText;
          }

          if (cellData.replace) {
            cellData = cellData.replace(/[\r\n]/g, '');
          }

          filterData.push(cellData);
        }

        row._aFilterData = filterData;
        row._sFilterRow = filterData.join('  ');
        wasInvalidated = true;
      }
    }

    return wasInvalidated;
  }
  /**
   * Convert from the internal Hungarian notation to camelCase for external
   * interaction
   *  @param {object} obj Object to convert
   *  @returns {object} Inverted object
   *  @memberof DataTable#oApi
   */


  function _fnSearchToCamel(obj) {
    return {
      search: obj.sSearch,
      smart: obj.bSmart,
      regex: obj.bRegex,
      caseInsensitive: obj.bCaseInsensitive
    };
  }
  /**
   * Convert from camelCase notation to the internal Hungarian. We could use the
   * Hungarian convert function here, but this is cleaner
   *  @param {object} obj Object to convert
   *  @returns {object} Inverted object
   *  @memberof DataTable#oApi
   */


  function _fnSearchToHung(obj) {
    return {
      sSearch: obj.search,
      bSmart: obj.smart,
      bRegex: obj.regex,
      bCaseInsensitive: obj.caseInsensitive
    };
  }
  /**
   * Generate the node required for the info display
   *  @param {object} oSettings dataTables settings object
   *  @returns {node} Information element
   *  @memberof DataTable#oApi
   */


  function _fnFeatureHtmlInfo(settings) {
    var tid = settings.sTableId,
        nodes = settings.aanFeatures.i,
        n = $('<div/>', {
      'class': settings.oClasses.sInfo,
      'id': !nodes ? tid + '_info' : null
    });

    if (!nodes) {
      // Update display on each draw
      settings.aoDrawCallback.push({
        "fn": _fnUpdateInfo,
        "sName": "information"
      });
      n.attr('role', 'status').attr('aria-live', 'polite'); // Table is described by our info div

      $(settings.nTable).attr('aria-describedby', tid + '_info');
    }

    return n[0];
  }
  /**
   * Update the information elements in the display
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnUpdateInfo(settings) {
    /* Show information about the table */
    var nodes = settings.aanFeatures.i;

    if (nodes.length === 0) {
      return;
    }

    var lang = settings.oLanguage,
        start = settings._iDisplayStart + 1,
        end = settings.fnDisplayEnd(),
        max = settings.fnRecordsTotal(),
        total = settings.fnRecordsDisplay(),
        out = total ? lang.sInfo : lang.sInfoEmpty;

    if (total !== max) {
      /* Record set after filtering */
      out += ' ' + lang.sInfoFiltered;
    } // Convert the macros


    out += lang.sInfoPostFix;
    out = _fnInfoMacros(settings, out);
    var callback = lang.fnInfoCallback;

    if (callback !== null) {
      out = callback.call(settings.oInstance, settings, start, end, max, total, out);
    }

    $(nodes).html(out);
  }

  function _fnInfoMacros(settings, str) {
    // When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
    // internally
    var formatter = settings.fnFormatNumber,
        start = settings._iDisplayStart + 1,
        len = settings._iDisplayLength,
        vis = settings.fnRecordsDisplay(),
        all = len === -1;
    return str.replace(/_START_/g, formatter.call(settings, start)).replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).replace(/_MAX_/g, formatter.call(settings, settings.fnRecordsTotal())).replace(/_TOTAL_/g, formatter.call(settings, vis)).replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len))).replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len)));
  }
  /**
   * Draw the table for the first time, adding all required features
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnInitialise(settings) {
    var i,
        iLen,
        iAjaxStart = settings.iInitDisplayStart;
    var columns = settings.aoColumns,
        column;
    var features = settings.oFeatures;
    var deferLoading = settings.bDeferLoading; // value modified by the draw

    /* Ensure that the table data is fully initialised */

    if (!settings.bInitialised) {
      setTimeout(function () {
        _fnInitialise(settings);
      }, 200);
      return;
    }
    /* Show the display HTML options */


    _fnAddOptionsHtml(settings);
    /* Build and draw the header / footer for the table */


    _fnBuildHead(settings);

    _fnDrawHead(settings, settings.aoHeader);

    _fnDrawHead(settings, settings.aoFooter);
    /* Okay to show that something is going on now */


    _fnProcessingDisplay(settings, true);
    /* Calculate sizes for columns */


    if (features.bAutoWidth) {
      _fnCalculateColumnWidths(settings);
    }

    for (i = 0, iLen = columns.length; i < iLen; i++) {
      column = columns[i];

      if (column.sWidth) {
        column.nTh.style.width = _fnStringToCss(column.sWidth);
      }
    }

    _fnCallbackFire(settings, null, 'preInit', [settings]); // If there is default sorting required - let's do it. The sort function
    // will do the drawing for us. Otherwise we draw the table regardless of the
    // Ajax source - this allows the table to look initialised for Ajax sourcing
    // data (show 'loading' message possibly)


    _fnReDraw(settings); // Server-side processing init complete is done by _fnAjaxUpdateDraw


    var dataSrc = _fnDataSource(settings);

    if (dataSrc != 'ssp' || deferLoading) {
      // if there is an ajax source load the data
      if (dataSrc == 'ajax') {
        _fnBuildAjax(settings, [], function (json) {
          var aData = _fnAjaxDataSrc(settings, json); // Got the data - add it to the table


          for (i = 0; i < aData.length; i++) {
            _fnAddData(settings, aData[i]);
          } // Reset the init display for cookie saving. We've already done
          // a filter, and therefore cleared it before. So we need to make
          // it appear 'fresh'


          settings.iInitDisplayStart = iAjaxStart;

          _fnReDraw(settings);

          _fnProcessingDisplay(settings, false);

          _fnInitComplete(settings, json);
        }, settings);
      } else {
        _fnProcessingDisplay(settings, false);

        _fnInitComplete(settings);
      }
    }
  }
  /**
   * Draw the table for the first time, adding all required features
   *  @param {object} oSettings dataTables settings object
   *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
   *    with client-side processing (optional)
   *  @memberof DataTable#oApi
   */


  function _fnInitComplete(settings, json) {
    settings._bInitComplete = true; // When data was added after the initialisation (data or Ajax) we need to
    // calculate the column sizing

    if (json || settings.oInit.aaData) {
      _fnAdjustColumnSizing(settings);
    }

    _fnCallbackFire(settings, null, 'plugin-init', [settings, json]);

    _fnCallbackFire(settings, 'aoInitComplete', 'init', [settings, json]);
  }

  function _fnLengthChange(settings, val) {
    var len = parseInt(val, 10);
    settings._iDisplayLength = len;

    _fnLengthOverflow(settings); // Fire length change event


    _fnCallbackFire(settings, null, 'length', [settings, len]);
  }
  /**
   * Generate the node required for user display length changing
   *  @param {object} settings dataTables settings object
   *  @returns {node} Display length feature node
   *  @memberof DataTable#oApi
   */


  function _fnFeatureHtmlLength(settings) {
    var classes = settings.oClasses,
        tableId = settings.sTableId,
        menu = settings.aLengthMenu,
        d2 = $.isArray(menu[0]),
        lengths = d2 ? menu[0] : menu,
        language = d2 ? menu[1] : menu;
    var select = $('<select/>', {
      'name': tableId + '_length',
      'aria-controls': tableId,
      'class': classes.sLengthSelect
    });

    for (var i = 0, ien = lengths.length; i < ien; i++) {
      select[0][i] = new Option(typeof language[i] === 'number' ? settings.fnFormatNumber(language[i]) : language[i], lengths[i]);
    }

    var div = $('<div><label/></div>').addClass(classes.sLength);

    if (!settings.aanFeatures.l) {
      div[0].id = tableId + '_length';
    }

    div.children().append(settings.oLanguage.sLengthMenu.replace('_MENU_', select[0].outerHTML)); // Can't use `select` variable as user might provide their own and the
    // reference is broken by the use of outerHTML

    $('select', div).val(settings._iDisplayLength).on('change.DT', function (e) {
      _fnLengthChange(settings, $(this).val());

      _fnDraw(settings);
    }); // Update node value whenever anything changes the table's length

    $(settings.nTable).on('length.dt.DT', function (e, s, len) {
      if (settings === s) {
        $('select', div).val(len);
      }
    });
    return div[0];
  }
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * Note that most of the paging logic is done in
   * DataTable.ext.pager
   */

  /**
   * Generate the node required for default pagination
   *  @param {object} oSettings dataTables settings object
   *  @returns {node} Pagination feature node
   *  @memberof DataTable#oApi
   */


  function _fnFeatureHtmlPaginate(settings) {
    var type = settings.sPaginationType,
        plugin = DataTable.ext.pager[type],
        modern = typeof plugin === 'function',
        redraw = function redraw(settings) {
      _fnDraw(settings);
    },
        node = $('<div/>').addClass(settings.oClasses.sPaging + type)[0],
        features = settings.aanFeatures;

    if (!modern) {
      plugin.fnInit(settings, node, redraw);
    }
    /* Add a draw callback for the pagination on first instance, to update the paging display */


    if (!features.p) {
      node.id = settings.sTableId + '_paginate';
      settings.aoDrawCallback.push({
        "fn": function fn(settings) {
          if (modern) {
            var start = settings._iDisplayStart,
                len = settings._iDisplayLength,
                visRecords = settings.fnRecordsDisplay(),
                all = len === -1,
                page = all ? 0 : Math.ceil(start / len),
                pages = all ? 1 : Math.ceil(visRecords / len),
                buttons = plugin(page, pages),
                i,
                ien;

            for (i = 0, ien = features.p.length; i < ien; i++) {
              _fnRenderer(settings, 'pageButton')(settings, features.p[i], i, buttons, page, pages);
            }
          } else {
            plugin.fnUpdate(settings, redraw);
          }
        },
        "sName": "pagination"
      });
    }

    return node;
  }
  /**
   * Alter the display settings to change the page
   *  @param {object} settings DataTables settings object
   *  @param {string|int} action Paging action to take: "first", "previous",
   *    "next" or "last" or page number to jump to (integer)
   *  @param [bool] redraw Automatically draw the update or not
   *  @returns {bool} true page has changed, false - no change
   *  @memberof DataTable#oApi
   */


  function _fnPageChange(settings, action, redraw) {
    var start = settings._iDisplayStart,
        len = settings._iDisplayLength,
        records = settings.fnRecordsDisplay();

    if (records === 0 || len === -1) {
      start = 0;
    } else if (typeof action === "number") {
      start = action * len;

      if (start > records) {
        start = 0;
      }
    } else if (action == "first") {
      start = 0;
    } else if (action == "previous") {
      start = len >= 0 ? start - len : 0;

      if (start < 0) {
        start = 0;
      }
    } else if (action == "next") {
      if (start + len < records) {
        start += len;
      }
    } else if (action == "last") {
      start = Math.floor((records - 1) / len) * len;
    } else {
      _fnLog(settings, 0, "Unknown paging action: " + action, 5);
    }

    var changed = settings._iDisplayStart !== start;
    settings._iDisplayStart = start;

    if (changed) {
      _fnCallbackFire(settings, null, 'page', [settings]);

      if (redraw) {
        _fnDraw(settings);
      }
    }

    return changed;
  }
  /**
   * Generate the node required for the processing node
   *  @param {object} settings dataTables settings object
   *  @returns {node} Processing element
   *  @memberof DataTable#oApi
   */


  function _fnFeatureHtmlProcessing(settings) {
    return $('<div/>', {
      'id': !settings.aanFeatures.r ? settings.sTableId + '_processing' : null,
      'class': settings.oClasses.sProcessing
    }).html(settings.oLanguage.sProcessing).insertBefore(settings.nTable)[0];
  }
  /**
   * Display or hide the processing indicator
   *  @param {object} settings dataTables settings object
   *  @param {bool} show Show the processing indicator (true) or not (false)
   *  @memberof DataTable#oApi
   */


  function _fnProcessingDisplay(settings, show) {
    if (settings.oFeatures.bProcessing) {
      $(settings.aanFeatures.r).css('display', show ? 'block' : 'none');
    }

    _fnCallbackFire(settings, null, 'processing', [settings, show]);
  }
  /**
   * Add any control elements for the table - specifically scrolling
   *  @param {object} settings dataTables settings object
   *  @returns {node} Node to add to the DOM
   *  @memberof DataTable#oApi
   */


  function _fnFeatureHtmlTable(settings) {
    var table = $(settings.nTable); // Add the ARIA grid role to the table

    table.attr('role', 'grid'); // Scrolling from here on in

    var scroll = settings.oScroll;

    if (scroll.sX === '' && scroll.sY === '') {
      return settings.nTable;
    }

    var scrollX = scroll.sX;
    var scrollY = scroll.sY;
    var classes = settings.oClasses;
    var caption = table.children('caption');
    var captionSide = caption.length ? caption[0]._captionSide : null;
    var headerClone = $(table[0].cloneNode(false));
    var footerClone = $(table[0].cloneNode(false));
    var footer = table.children('tfoot');
    var _div = '<div/>';

    var size = function size(s) {
      return !s ? null : _fnStringToCss(s);
    };

    if (!footer.length) {
      footer = null;
    }
    /*
     * The HTML structure that we want to generate in this function is:
     *  div - scroller
     *    div - scroll head
     *      div - scroll head inner
     *        table - scroll head table
     *          thead - thead
     *    div - scroll body
     *      table - table (master table)
     *        thead - thead clone for sizing
     *        tbody - tbody
     *    div - scroll foot
     *      div - scroll foot inner
     *        table - scroll foot table
     *          tfoot - tfoot
     */


    var scroller = $(_div, {
      'class': classes.sScrollWrapper
    }).append($(_div, {
      'class': classes.sScrollHead
    }).css({
      overflow: 'hidden',
      position: 'relative',
      border: 0,
      width: scrollX ? size(scrollX) : '100%'
    }).append($(_div, {
      'class': classes.sScrollHeadInner
    }).css({
      'box-sizing': 'content-box',
      width: scroll.sXInner || '100%'
    }).append(headerClone.removeAttr('id').css('margin-left', 0).append(captionSide === 'top' ? caption : null).append(table.children('thead'))))).append($(_div, {
      'class': classes.sScrollBody
    }).css({
      position: 'relative',
      overflow: 'auto',
      width: size(scrollX)
    }).append(table));

    if (footer) {
      scroller.append($(_div, {
        'class': classes.sScrollFoot
      }).css({
        overflow: 'hidden',
        border: 0,
        width: scrollX ? size(scrollX) : '100%'
      }).append($(_div, {
        'class': classes.sScrollFootInner
      }).append(footerClone.removeAttr('id').css('margin-left', 0).append(captionSide === 'bottom' ? caption : null).append(table.children('tfoot')))));
    }

    var children = scroller.children();
    var scrollHead = children[0];
    var scrollBody = children[1];
    var scrollFoot = footer ? children[2] : null; // When the body is scrolled, then we also want to scroll the headers

    if (scrollX) {
      $(scrollBody).on('scroll.DT', function (e) {
        var scrollLeft = this.scrollLeft;
        scrollHead.scrollLeft = scrollLeft;

        if (footer) {
          scrollFoot.scrollLeft = scrollLeft;
        }
      });
    }

    $(scrollBody).css(scrollY && scroll.bCollapse ? 'max-height' : 'height', scrollY);
    settings.nScrollHead = scrollHead;
    settings.nScrollBody = scrollBody;
    settings.nScrollFoot = scrollFoot; // On redraw - align columns

    settings.aoDrawCallback.push({
      "fn": _fnScrollDraw,
      "sName": "scrolling"
    });
    return scroller[0];
  }
  /**
   * Update the header, footer and body tables for resizing - i.e. column
   * alignment.
   *
   * Welcome to the most horrible function DataTables. The process that this
   * function follows is basically:
   *   1. Re-create the table inside the scrolling div
   *   2. Take live measurements from the DOM
   *   3. Apply the measurements to align the columns
   *   4. Clean up
   *
   *  @param {object} settings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnScrollDraw(settings) {
    // Given that this is such a monster function, a lot of variables are use
    // to try and keep the minimised size as small as possible
    var scroll = settings.oScroll,
        scrollX = scroll.sX,
        scrollXInner = scroll.sXInner,
        scrollY = scroll.sY,
        barWidth = scroll.iBarWidth,
        divHeader = $(settings.nScrollHead),
        divHeaderStyle = divHeader[0].style,
        divHeaderInner = divHeader.children('div'),
        divHeaderInnerStyle = divHeaderInner[0].style,
        divHeaderTable = divHeaderInner.children('table'),
        divBodyEl = settings.nScrollBody,
        divBody = $(divBodyEl),
        divBodyStyle = divBodyEl.style,
        divFooter = $(settings.nScrollFoot),
        divFooterInner = divFooter.children('div'),
        divFooterTable = divFooterInner.children('table'),
        header = $(settings.nTHead),
        table = $(settings.nTable),
        tableEl = table[0],
        tableStyle = tableEl.style,
        footer = settings.nTFoot ? $(settings.nTFoot) : null,
        browser = settings.oBrowser,
        ie67 = browser.bScrollOversize,
        dtHeaderCells = _pluck(settings.aoColumns, 'nTh'),
        headerTrgEls,
        footerTrgEls,
        headerSrcEls,
        footerSrcEls,
        headerCopy,
        footerCopy,
        headerWidths = [],
        footerWidths = [],
        headerContent = [],
        footerContent = [],
        idx,
        correction,
        sanityWidth,
        zeroOut = function zeroOut(nSizer) {
      var style = nSizer.style;
      style.paddingTop = "0";
      style.paddingBottom = "0";
      style.borderTopWidth = "0";
      style.borderBottomWidth = "0";
      style.height = 0;
    }; // If the scrollbar visibility has changed from the last draw, we need to
    // adjust the column sizes as the table width will have changed to account
    // for the scrollbar


    var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;

    if (settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== undefined) {
      settings.scrollBarVis = scrollBarVis;

      _fnAdjustColumnSizing(settings);

      return; // adjust column sizing will call this function again
    } else {
      settings.scrollBarVis = scrollBarVis;
    }
    /*
     * 1. Re-create the table inside the scrolling div
     */
    // Remove the old minimised thead and tfoot elements in the inner table


    table.children('thead, tfoot').remove();

    if (footer) {
      footerCopy = footer.clone().prependTo(table);
      footerTrgEls = footer.find('tr'); // the original tfoot is in its own table and must be sized

      footerSrcEls = footerCopy.find('tr');
    } // Clone the current header and footer elements and then place it into the inner table


    headerCopy = header.clone().prependTo(table);
    headerTrgEls = header.find('tr'); // original header is in its own table

    headerSrcEls = headerCopy.find('tr');
    headerCopy.find('th, td').removeAttr('tabindex');
    /*
     * 2. Take live measurements from the DOM - do not alter the DOM itself!
     */
    // Remove old sizing and apply the calculated column widths
    // Get the unique column headers in the newly created (cloned) header. We want to apply the
    // calculated sizes to this header

    if (!scrollX) {
      divBodyStyle.width = '100%';
      divHeader[0].style.width = '100%';
    }

    $.each(_fnGetUniqueThs(settings, headerCopy), function (i, el) {
      idx = _fnVisibleToColumnIndex(settings, i);
      el.style.width = settings.aoColumns[idx].sWidth;
    });

    if (footer) {
      _fnApplyToChildren(function (n) {
        n.style.width = "";
      }, footerSrcEls);
    } // Size the table as a whole


    sanityWidth = table.outerWidth();

    if (scrollX === "") {
      // No x scrolling
      tableStyle.width = "100%"; // IE7 will make the width of the table when 100% include the scrollbar
      // - which is shouldn't. When there is a scrollbar we need to take this
      // into account.

      if (ie67 && (table.find('tbody').height() > divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")) {
        tableStyle.width = _fnStringToCss(table.outerWidth() - barWidth);
      } // Recalculate the sanity width


      sanityWidth = table.outerWidth();
    } else if (scrollXInner !== "") {
      // legacy x scroll inner has been given - use it
      tableStyle.width = _fnStringToCss(scrollXInner); // Recalculate the sanity width

      sanityWidth = table.outerWidth();
    } // Hidden header should have zero height, so remove padding and borders. Then
    // set the width based on the real headers
    // Apply all styles in one pass


    _fnApplyToChildren(zeroOut, headerSrcEls); // Read all widths in next pass


    _fnApplyToChildren(function (nSizer) {
      headerContent.push(nSizer.innerHTML);
      headerWidths.push(_fnStringToCss($(nSizer).css('width')));
    }, headerSrcEls); // Apply all widths in final pass


    _fnApplyToChildren(function (nToSize, i) {
      // Only apply widths to the DataTables detected header cells - this
      // prevents complex headers from having contradictory sizes applied
      if ($.inArray(nToSize, dtHeaderCells) !== -1) {
        nToSize.style.width = headerWidths[i];
      }
    }, headerTrgEls);

    $(headerSrcEls).height(0);
    /* Same again with the footer if we have one */

    if (footer) {
      _fnApplyToChildren(zeroOut, footerSrcEls);

      _fnApplyToChildren(function (nSizer) {
        footerContent.push(nSizer.innerHTML);
        footerWidths.push(_fnStringToCss($(nSizer).css('width')));
      }, footerSrcEls);

      _fnApplyToChildren(function (nToSize, i) {
        nToSize.style.width = footerWidths[i];
      }, footerTrgEls);

      $(footerSrcEls).height(0);
    }
    /*
     * 3. Apply the measurements
     */
    // "Hide" the header and footer that we used for the sizing. We need to keep
    // the content of the cell so that the width applied to the header and body
    // both match, but we want to hide it completely. We want to also fix their
    // width to what they currently are


    _fnApplyToChildren(function (nSizer, i) {
      nSizer.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">' + headerContent[i] + '</div>';
      nSizer.style.width = headerWidths[i];
    }, headerSrcEls);

    if (footer) {
      _fnApplyToChildren(function (nSizer, i) {
        nSizer.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">' + footerContent[i] + '</div>';
        nSizer.style.width = footerWidths[i];
      }, footerSrcEls);
    } // Sanity check that the table is of a sensible width. If not then we are going to get
    // misalignment - try to prevent this by not allowing the table to shrink below its min width


    if (table.outerWidth() < sanityWidth) {
      // The min width depends upon if we have a vertical scrollbar visible or not */
      correction = divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll" ? sanityWidth + barWidth : sanityWidth; // IE6/7 are a law unto themselves...

      if (ie67 && (divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")) {
        tableStyle.width = _fnStringToCss(correction - barWidth);
      } // And give the user a warning that we've stopped the table getting too small


      if (scrollX === "" || scrollXInner !== "") {
        _fnLog(settings, 1, 'Possible column misalignment', 6);
      }
    } else {
      correction = '100%';
    } // Apply to the container elements


    divBodyStyle.width = _fnStringToCss(correction);
    divHeaderStyle.width = _fnStringToCss(correction);

    if (footer) {
      settings.nScrollFoot.style.width = _fnStringToCss(correction);
    }
    /*
     * 4. Clean up
     */


    if (!scrollY) {
      /* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
       * the scrollbar height from the visible display, rather than adding it on. We need to
       * set the height in order to sort this. Don't want to do it in any other browsers.
       */
      if (ie67) {
        divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + barWidth);
      }
    }
    /* Finally set the width's of the header and footer tables */


    var iOuterWidth = table.outerWidth();
    divHeaderTable[0].style.width = _fnStringToCss(iOuterWidth);
    divHeaderInnerStyle.width = _fnStringToCss(iOuterWidth); // Figure out if there are scrollbar present - if so then we need a the header and footer to
    // provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)

    var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == "scroll";
    var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right');
    divHeaderInnerStyle[padding] = bScrolling ? barWidth + "px" : "0px";

    if (footer) {
      divFooterTable[0].style.width = _fnStringToCss(iOuterWidth);
      divFooterInner[0].style.width = _fnStringToCss(iOuterWidth);
      divFooterInner[0].style[padding] = bScrolling ? barWidth + "px" : "0px";
    } // Correct DOM ordering for colgroup - comes before the thead


    table.children('colgroup').insertBefore(table.children('thead'));
    /* Adjust the position of the header in case we loose the y-scrollbar */

    divBody.scroll(); // If sorting or filtering has occurred, jump the scrolling back to the top
    // only if we aren't holding the position

    if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {
      divBodyEl.scrollTop = 0;
    }
  }
  /**
   * Apply a given function to the display child nodes of an element array (typically
   * TD children of TR rows
   *  @param {function} fn Method to apply to the objects
   *  @param array {nodes} an1 List of elements to look through for display children
   *  @param array {nodes} an2 Another list (identical structure to the first) - optional
   *  @memberof DataTable#oApi
   */


  function _fnApplyToChildren(fn, an1, an2) {
    var index = 0,
        i = 0,
        iLen = an1.length;
    var nNode1, nNode2;

    while (i < iLen) {
      nNode1 = an1[i].firstChild;
      nNode2 = an2 ? an2[i].firstChild : null;

      while (nNode1) {
        if (nNode1.nodeType === 1) {
          if (an2) {
            fn(nNode1, nNode2, index);
          } else {
            fn(nNode1, index);
          }

          index++;
        }

        nNode1 = nNode1.nextSibling;
        nNode2 = an2 ? nNode2.nextSibling : null;
      }

      i++;
    }
  }

  var __re_html_remove = /<.*?>/g;
  /**
   * Calculate the width of columns for the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */

  function _fnCalculateColumnWidths(oSettings) {
    var table = oSettings.nTable,
        columns = oSettings.aoColumns,
        scroll = oSettings.oScroll,
        scrollY = scroll.sY,
        scrollX = scroll.sX,
        scrollXInner = scroll.sXInner,
        columnCount = columns.length,
        visibleColumns = _fnGetColumns(oSettings, 'bVisible'),
        headerCells = $('th', oSettings.nTHead),
        tableWidthAttr = table.getAttribute('width'),
        // from DOM element
    tableContainer = table.parentNode,
        userInputs = false,
        i,
        column,
        columnIdx,
        width,
        outerWidth,
        browser = oSettings.oBrowser,
        ie67 = browser.bScrollOversize;

    var styleWidth = table.style.width;

    if (styleWidth && styleWidth.indexOf('%') !== -1) {
      tableWidthAttr = styleWidth;
    }
    /* Convert any user input sizes into pixel sizes */


    for (i = 0; i < visibleColumns.length; i++) {
      column = columns[visibleColumns[i]];

      if (column.sWidth !== null) {
        column.sWidth = _fnConvertToWidth(column.sWidthOrig, tableContainer);
        userInputs = true;
      }
    }
    /* If the number of columns in the DOM equals the number that we have to
     * process in DataTables, then we can use the offsets that are created by
     * the web- browser. No custom sizes can be set in order for this to happen,
     * nor scrolling used
     */


    if (ie67 || !userInputs && !scrollX && !scrollY && columnCount == _fnVisbleColumns(oSettings) && columnCount == headerCells.length) {
      for (i = 0; i < columnCount; i++) {
        var colIdx = _fnVisibleToColumnIndex(oSettings, i);

        if (colIdx !== null) {
          columns[colIdx].sWidth = _fnStringToCss(headerCells.eq(i).width());
        }
      }
    } else {
      // Otherwise construct a single row, worst case, table with the widest
      // node in the data, assign any user defined widths, then insert it into
      // the DOM and allow the browser to do all the hard work of calculating
      // table widths
      var tmpTable = $(table).clone() // don't use cloneNode - IE8 will remove events on the main table
      .css('visibility', 'hidden').removeAttr('id'); // Clean up the table body

      tmpTable.find('tbody tr').remove();
      var tr = $('<tr/>').appendTo(tmpTable.find('tbody')); // Clone the table header and footer - we can't use the header / footer
      // from the cloned table, since if scrolling is active, the table's
      // real header and footer are contained in different table tags

      tmpTable.find('thead, tfoot').remove();
      tmpTable.append($(oSettings.nTHead).clone()).append($(oSettings.nTFoot).clone()); // Remove any assigned widths from the footer (from scrolling)

      tmpTable.find('tfoot th, tfoot td').css('width', ''); // Apply custom sizing to the cloned header

      headerCells = _fnGetUniqueThs(oSettings, tmpTable.find('thead')[0]);

      for (i = 0; i < visibleColumns.length; i++) {
        column = columns[visibleColumns[i]];
        headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== '' ? _fnStringToCss(column.sWidthOrig) : ''; // For scrollX we need to force the column width otherwise the
        // browser will collapse it. If this width is smaller than the
        // width the column requires, then it will have no effect

        if (column.sWidthOrig && scrollX) {
          $(headerCells[i]).append($('<div/>').css({
            width: column.sWidthOrig,
            margin: 0,
            padding: 0,
            border: 0,
            height: 1
          }));
        }
      } // Find the widest cell for each column and put it into the table


      if (oSettings.aoData.length) {
        for (i = 0; i < visibleColumns.length; i++) {
          columnIdx = visibleColumns[i];
          column = columns[columnIdx];
          $(_fnGetWidestNode(oSettings, columnIdx)).clone(false).append(column.sContentPadding).appendTo(tr);
        }
      } // Tidy the temporary table - remove name attributes so there aren't
      // duplicated in the dom (radio elements for example)


      $('[name]', tmpTable).removeAttr('name'); // Table has been built, attach to the document so we can work with it.
      // A holding element is used, positioned at the top of the container
      // with minimal height, so it has no effect on if the container scrolls
      // or not. Otherwise it might trigger scrolling when it actually isn't
      // needed

      var holder = $('<div/>').css(scrollX || scrollY ? {
        position: 'absolute',
        top: 0,
        left: 0,
        height: 1,
        right: 0,
        overflow: 'hidden'
      } : {}).append(tmpTable).appendTo(tableContainer); // When scrolling (X or Y) we want to set the width of the table as 
      // appropriate. However, when not scrolling leave the table width as it
      // is. This results in slightly different, but I think correct behaviour

      if (scrollX && scrollXInner) {
        tmpTable.width(scrollXInner);
      } else if (scrollX) {
        tmpTable.css('width', 'auto');
        tmpTable.removeAttr('width'); // If there is no width attribute or style, then allow the table to
        // collapse

        if (tmpTable.width() < tableContainer.clientWidth && tableWidthAttr) {
          tmpTable.width(tableContainer.clientWidth);
        }
      } else if (scrollY) {
        tmpTable.width(tableContainer.clientWidth);
      } else if (tableWidthAttr) {
        tmpTable.width(tableWidthAttr);
      } // Get the width of each column in the constructed table - we need to
      // know the inner width (so it can be assigned to the other table's
      // cells) and the outer width so we can calculate the full width of the
      // table. This is safe since DataTables requires a unique cell for each
      // column, but if ever a header can span multiple columns, this will
      // need to be modified.


      var total = 0;

      for (i = 0; i < visibleColumns.length; i++) {
        var cell = $(headerCells[i]);
        var border = cell.outerWidth() - cell.width(); // Use getBounding... where possible (not IE8-) because it can give
        // sub-pixel accuracy, which we then want to round up!

        var bounding = browser.bBounding ? Math.ceil(headerCells[i].getBoundingClientRect().width) : cell.outerWidth(); // Total is tracked to remove any sub-pixel errors as the outerWidth
        // of the table might not equal the total given here (IE!).

        total += bounding; // Width for each column to use

        columns[visibleColumns[i]].sWidth = _fnStringToCss(bounding - border);
      }

      table.style.width = _fnStringToCss(total); // Finished with the table - ditch it

      holder.remove();
    } // If there is a width attr, we want to attach an event listener which
    // allows the table sizing to automatically adjust when the window is
    // resized. Use the width attr rather than CSS, since we can't know if the
    // CSS is a relative value or absolute - DOM read is always px.


    if (tableWidthAttr) {
      table.style.width = _fnStringToCss(tableWidthAttr);
    }

    if ((tableWidthAttr || scrollX) && !oSettings._reszEvt) {
      var bindResize = function bindResize() {
        $(window).on('resize.DT-' + oSettings.sInstance, _fnThrottle(function () {
          _fnAdjustColumnSizing(oSettings);
        }));
      }; // IE6/7 will crash if we bind a resize event handler on page load.
      // To be removed in 1.11 which drops IE6/7 support


      if (ie67) {
        setTimeout(bindResize, 1000);
      } else {
        bindResize();
      }

      oSettings._reszEvt = true;
    }
  }
  /**
   * Throttle the calls to a function. Arguments and context are maintained for
   * the throttled function
   *  @param {function} fn Function to be called
   *  @param {int} [freq=200] call frequency in mS
   *  @returns {function} wrapped function
   *  @memberof DataTable#oApi
   */


  var _fnThrottle = DataTable.util.throttle;
  /**
   * Convert a CSS unit width to pixels (e.g. 2em)
   *  @param {string} width width to be converted
   *  @param {node} parent parent to get the with for (required for relative widths) - optional
   *  @returns {int} width in pixels
   *  @memberof DataTable#oApi
   */

  function _fnConvertToWidth(width, parent) {
    if (!width) {
      return 0;
    }

    var n = $('<div/>').css('width', _fnStringToCss(width)).appendTo(parent || document.body);
    var val = n[0].offsetWidth;
    n.remove();
    return val;
  }
  /**
   * Get the widest node
   *  @param {object} settings dataTables settings object
   *  @param {int} colIdx column of interest
   *  @returns {node} widest table node
   *  @memberof DataTable#oApi
   */


  function _fnGetWidestNode(settings, colIdx) {
    var idx = _fnGetMaxLenString(settings, colIdx);

    if (idx < 0) {
      return null;
    }

    var data = settings.aoData[idx];
    return !data.nTr ? // Might not have been created when deferred rendering
    $('<td/>').html(_fnGetCellData(settings, idx, colIdx, 'display'))[0] : data.anCells[colIdx];
  }
  /**
   * Get the maximum strlen for each data column
   *  @param {object} settings dataTables settings object
   *  @param {int} colIdx column of interest
   *  @returns {string} max string length for each column
   *  @memberof DataTable#oApi
   */


  function _fnGetMaxLenString(settings, colIdx) {
    var s,
        max = -1,
        maxIdx = -1;

    for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
      s = _fnGetCellData(settings, i, colIdx, 'display') + '';
      s = s.replace(__re_html_remove, '');
      s = s.replace(/&nbsp;/g, ' ');

      if (s.length > max) {
        max = s.length;
        maxIdx = i;
      }
    }

    return maxIdx;
  }
  /**
   * Append a CSS unit (only if required) to a string
   *  @param {string} value to css-ify
   *  @returns {string} value with css unit
   *  @memberof DataTable#oApi
   */


  function _fnStringToCss(s) {
    if (s === null) {
      return '0px';
    }

    if (typeof s == 'number') {
      return s < 0 ? '0px' : s + 'px';
    } // Check it has a unit character already


    return s.match(/\d$/) ? s + 'px' : s;
  }

  function _fnSortFlatten(settings) {
    var i,
        iLen,
        k,
        kLen,
        aSort = [],
        aiOrig = [],
        aoColumns = settings.aoColumns,
        aDataSort,
        iCol,
        sType,
        srcCol,
        fixed = settings.aaSortingFixed,
        fixedObj = $.isPlainObject(fixed),
        nestedSort = [],
        add = function add(a) {
      if (a.length && !$.isArray(a[0])) {
        // 1D array
        nestedSort.push(a);
      } else {
        // 2D array
        $.merge(nestedSort, a);
      }
    }; // Build the sort array, with pre-fix and post-fix options if they have been
    // specified


    if ($.isArray(fixed)) {
      add(fixed);
    }

    if (fixedObj && fixed.pre) {
      add(fixed.pre);
    }

    add(settings.aaSorting);

    if (fixedObj && fixed.post) {
      add(fixed.post);
    }

    for (i = 0; i < nestedSort.length; i++) {
      srcCol = nestedSort[i][0];
      aDataSort = aoColumns[srcCol].aDataSort;

      for (k = 0, kLen = aDataSort.length; k < kLen; k++) {
        iCol = aDataSort[k];
        sType = aoColumns[iCol].sType || 'string';

        if (nestedSort[i]._idx === undefined) {
          nestedSort[i]._idx = $.inArray(nestedSort[i][1], aoColumns[iCol].asSorting);
        }

        aSort.push({
          src: srcCol,
          col: iCol,
          dir: nestedSort[i][1],
          index: nestedSort[i]._idx,
          type: sType,
          formatter: DataTable.ext.type.order[sType + "-pre"]
        });
      }
    }

    return aSort;
  }
  /**
   * Change the order of the table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   *  @todo This really needs split up!
   */


  function _fnSort(oSettings) {
    var i,
        ien,
        iLen,
        j,
        jLen,
        k,
        kLen,
        sDataType,
        nTh,
        aiOrig = [],
        oExtSort = DataTable.ext.type.order,
        aoData = oSettings.aoData,
        aoColumns = oSettings.aoColumns,
        aDataSort,
        data,
        iCol,
        sType,
        oSort,
        formatters = 0,
        sortCol,
        displayMaster = oSettings.aiDisplayMaster,
        aSort; // Resolve any column types that are unknown due to addition or invalidation
    // @todo Can this be moved into a 'data-ready' handler which is called when
    //   data is going to be used in the table?

    _fnColumnTypes(oSettings);

    aSort = _fnSortFlatten(oSettings);

    for (i = 0, ien = aSort.length; i < ien; i++) {
      sortCol = aSort[i]; // Track if we can use the fast sort algorithm

      if (sortCol.formatter) {
        formatters++;
      } // Load the data needed for the sort, for each cell


      _fnSortData(oSettings, sortCol.col);
    }
    /* No sorting required if server-side or no sorting array */


    if (_fnDataSource(oSettings) != 'ssp' && aSort.length !== 0) {
      // Create a value - key array of the current row positions such that we can use their
      // current position during the sort, if values match, in order to perform stable sorting
      for (i = 0, iLen = displayMaster.length; i < iLen; i++) {
        aiOrig[displayMaster[i]] = i;
      }
      /* Do the sort - here we want multi-column sorting based on a given data source (column)
       * and sorting function (from oSort) in a certain direction. It's reasonably complex to
       * follow on it's own, but this is what we want (example two column sorting):
       *  fnLocalSorting = function(a,b){
       *    var iTest;
       *    iTest = oSort['string-asc']('data11', 'data12');
       *      if (iTest !== 0)
       *        return iTest;
       *    iTest = oSort['numeric-desc']('data21', 'data22');
       *    if (iTest !== 0)
       *      return iTest;
       *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
       *  }
       * Basically we have a test for each sorting column, if the data in that column is equal,
       * test the next column. If all columns match, then we use a numeric sort on the row
       * positions in the original data array to provide a stable sort.
       *
       * Note - I know it seems excessive to have two sorting methods, but the first is around
       * 15% faster, so the second is only maintained for backwards compatibility with sorting
       * methods which do not have a pre-sort formatting function.
       */


      if (formatters === aSort.length) {
        // All sort types have formatting functions
        displayMaster.sort(function (a, b) {
          var x,
              y,
              k,
              test,
              sort,
              len = aSort.length,
              dataA = aoData[a]._aSortData,
              dataB = aoData[b]._aSortData;

          for (k = 0; k < len; k++) {
            sort = aSort[k];
            x = dataA[sort.col];
            y = dataB[sort.col];
            test = x < y ? -1 : x > y ? 1 : 0;

            if (test !== 0) {
              return sort.dir === 'asc' ? test : -test;
            }
          }

          x = aiOrig[a];
          y = aiOrig[b];
          return x < y ? -1 : x > y ? 1 : 0;
        });
      } else {
        // Depreciated - remove in 1.11 (providing a plug-in option)
        // Not all sort types have formatting methods, so we have to call their sorting
        // methods.
        displayMaster.sort(function (a, b) {
          var x,
              y,
              k,
              l,
              test,
              sort,
              fn,
              len = aSort.length,
              dataA = aoData[a]._aSortData,
              dataB = aoData[b]._aSortData;

          for (k = 0; k < len; k++) {
            sort = aSort[k];
            x = dataA[sort.col];
            y = dataB[sort.col];
            fn = oExtSort[sort.type + "-" + sort.dir] || oExtSort["string-" + sort.dir];
            test = fn(x, y);

            if (test !== 0) {
              return test;
            }
          }

          x = aiOrig[a];
          y = aiOrig[b];
          return x < y ? -1 : x > y ? 1 : 0;
        });
      }
    }
    /* Tell the draw function that we have sorted the data */


    oSettings.bSorted = true;
  }

  function _fnSortAria(settings) {
    var label;
    var nextSort;
    var columns = settings.aoColumns;

    var aSort = _fnSortFlatten(settings);

    var oAria = settings.oLanguage.oAria; // ARIA attributes - need to loop all columns, to update all (removing old
    // attributes as needed)

    for (var i = 0, iLen = columns.length; i < iLen; i++) {
      var col = columns[i];
      var asSorting = col.asSorting;
      var sTitle = col.sTitle.replace(/<.*?>/g, "");
      var th = col.nTh; // IE7 is throwing an error when setting these properties with jQuery's
      // attr() and removeAttr() methods...

      th.removeAttribute('aria-sort');
      /* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */

      if (col.bSortable) {
        if (aSort.length > 0 && aSort[0].col == i) {
          th.setAttribute('aria-sort', aSort[0].dir == "asc" ? "ascending" : "descending");
          nextSort = asSorting[aSort[0].index + 1] || asSorting[0];
        } else {
          nextSort = asSorting[0];
        }

        label = sTitle + (nextSort === "asc" ? oAria.sSortAscending : oAria.sSortDescending);
      } else {
        label = sTitle;
      }

      th.setAttribute('aria-label', label);
    }
  }
  /**
   * Function to run on user sort request
   *  @param {object} settings dataTables settings object
   *  @param {node} attachTo node to attach the handler to
   *  @param {int} colIdx column sorting index
   *  @param {boolean} [append=false] Append the requested sort to the existing
   *    sort if true (i.e. multi-column sort)
   *  @param {function} [callback] callback function
   *  @memberof DataTable#oApi
   */


  function _fnSortListener(settings, colIdx, append, callback) {
    var col = settings.aoColumns[colIdx];
    var sorting = settings.aaSorting;
    var asSorting = col.asSorting;
    var nextSortIdx;

    var next = function next(a, overflow) {
      var idx = a._idx;

      if (idx === undefined) {
        idx = $.inArray(a[1], asSorting);
      }

      return idx + 1 < asSorting.length ? idx + 1 : overflow ? null : 0;
    }; // Convert to 2D array if needed


    if (typeof sorting[0] === 'number') {
      sorting = settings.aaSorting = [sorting];
    } // If appending the sort then we are multi-column sorting


    if (append && settings.oFeatures.bSortMulti) {
      // Are we already doing some kind of sort on this column?
      var sortIdx = $.inArray(colIdx, _pluck(sorting, '0'));

      if (sortIdx !== -1) {
        // Yes, modify the sort
        nextSortIdx = next(sorting[sortIdx], true);

        if (nextSortIdx === null && sorting.length === 1) {
          nextSortIdx = 0; // can't remove sorting completely
        }

        if (nextSortIdx === null) {
          sorting.splice(sortIdx, 1);
        } else {
          sorting[sortIdx][1] = asSorting[nextSortIdx];
          sorting[sortIdx]._idx = nextSortIdx;
        }
      } else {
        // No sort on this column yet
        sorting.push([colIdx, asSorting[0], 0]);
        sorting[sorting.length - 1]._idx = 0;
      }
    } else if (sorting.length && sorting[0][0] == colIdx) {
      // Single column - already sorting on this column, modify the sort
      nextSortIdx = next(sorting[0]);
      sorting.length = 1;
      sorting[0][1] = asSorting[nextSortIdx];
      sorting[0]._idx = nextSortIdx;
    } else {
      // Single column - sort only on this column
      sorting.length = 0;
      sorting.push([colIdx, asSorting[0]]);
      sorting[0]._idx = 0;
    } // Run the sort by calling a full redraw


    _fnReDraw(settings); // callback used for async user interaction


    if (typeof callback == 'function') {
      callback(settings);
    }
  }
  /**
   * Attach a sort handler (click) to a node
   *  @param {object} settings dataTables settings object
   *  @param {node} attachTo node to attach the handler to
   *  @param {int} colIdx column sorting index
   *  @param {function} [callback] callback function
   *  @memberof DataTable#oApi
   */


  function _fnSortAttachListener(settings, attachTo, colIdx, callback) {
    var col = settings.aoColumns[colIdx];

    _fnBindAction(attachTo, {}, function (e) {
      /* If the column is not sortable - don't to anything */
      if (col.bSortable === false) {
        return;
      } // If processing is enabled use a timeout to allow the processing
      // display to be shown - otherwise to it synchronously


      if (settings.oFeatures.bProcessing) {
        _fnProcessingDisplay(settings, true);

        setTimeout(function () {
          _fnSortListener(settings, colIdx, e.shiftKey, callback); // In server-side processing, the draw callback will remove the
          // processing display


          if (_fnDataSource(settings) !== 'ssp') {
            _fnProcessingDisplay(settings, false);
          }
        }, 0);
      } else {
        _fnSortListener(settings, colIdx, e.shiftKey, callback);
      }
    });
  }
  /**
   * Set the sorting classes on table's body, Note: it is safe to call this function
   * when bSort and bSortClasses are false
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnSortingClasses(settings) {
    var oldSort = settings.aLastSort;
    var sortClass = settings.oClasses.sSortColumn;

    var sort = _fnSortFlatten(settings);

    var features = settings.oFeatures;
    var i, ien, colIdx;

    if (features.bSort && features.bSortClasses) {
      // Remove old sorting classes
      for (i = 0, ien = oldSort.length; i < ien; i++) {
        colIdx = oldSort[i].src; // Remove column sorting

        $(_pluck(settings.aoData, 'anCells', colIdx)).removeClass(sortClass + (i < 2 ? i + 1 : 3));
      } // Add new column sorting


      for (i = 0, ien = sort.length; i < ien; i++) {
        colIdx = sort[i].src;
        $(_pluck(settings.aoData, 'anCells', colIdx)).addClass(sortClass + (i < 2 ? i + 1 : 3));
      }
    }

    settings.aLastSort = sort;
  } // Get the data to sort a column, be it from cache, fresh (populating the
  // cache), or from a sort formatter


  function _fnSortData(settings, idx) {
    // Custom sorting function - provided by the sort data type
    var column = settings.aoColumns[idx];
    var customSort = DataTable.ext.order[column.sSortDataType];
    var customData;

    if (customSort) {
      customData = customSort.call(settings.oInstance, settings, idx, _fnColumnIndexToVisible(settings, idx));
    } // Use / populate cache


    var row, cellData;
    var formatter = DataTable.ext.type.order[column.sType + "-pre"];

    for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
      row = settings.aoData[i];

      if (!row._aSortData) {
        row._aSortData = [];
      }

      if (!row._aSortData[idx] || customSort) {
        cellData = customSort ? customData[i] : // If there was a custom sort function, use data from there
        _fnGetCellData(settings, i, idx, 'sort');
        row._aSortData[idx] = formatter ? formatter(cellData) : cellData;
      }
    }
  }
  /**
   * Save the state of a table
   *  @param {object} oSettings dataTables settings object
   *  @memberof DataTable#oApi
   */


  function _fnSaveState(settings) {
    if (!settings.oFeatures.bStateSave || settings.bDestroying) {
      return;
    }
    /* Store the interesting variables */


    var state = {
      time: +new Date(),
      start: settings._iDisplayStart,
      length: settings._iDisplayLength,
      order: $.extend(true, [], settings.aaSorting),
      search: _fnSearchToCamel(settings.oPreviousSearch),
      columns: $.map(settings.aoColumns, function (col, i) {
        return {
          visible: col.bVisible,
          search: _fnSearchToCamel(settings.aoPreSearchCols[i])
        };
      })
    };

    _fnCallbackFire(settings, "aoStateSaveParams", 'stateSaveParams', [settings, state]);

    settings.oSavedState = state;
    settings.fnStateSaveCallback.call(settings.oInstance, settings, state);
  }
  /**
   * Attempt to load a saved table state
   *  @param {object} oSettings dataTables settings object
   *  @param {object} oInit DataTables init object so we can override settings
   *  @param {function} callback Callback to execute when the state has been loaded
   *  @memberof DataTable#oApi
   */


  function _fnLoadState(settings, oInit, callback) {
    var i, ien;
    var columns = settings.aoColumns;

    var loaded = function loaded(s) {
      if (!s || !s.time) {
        callback();
        return;
      } // Allow custom and plug-in manipulation functions to alter the saved data set and
      // cancelling of loading by returning false


      var abStateLoad = _fnCallbackFire(settings, 'aoStateLoadParams', 'stateLoadParams', [settings, s]);

      if ($.inArray(false, abStateLoad) !== -1) {
        callback();
        return;
      } // Reject old data


      var duration = settings.iStateDuration;

      if (duration > 0 && s.time < +new Date() - duration * 1000) {
        callback();
        return;
      } // Number of columns have changed - all bets are off, no restore of settings


      if (s.columns && columns.length !== s.columns.length) {
        callback();
        return;
      } // Store the saved state so it might be accessed at any time


      settings.oLoadedState = $.extend(true, {}, s); // Restore key features - todo - for 1.11 this needs to be done by
      // subscribed events

      if (s.start !== undefined) {
        settings._iDisplayStart = s.start;
        settings.iInitDisplayStart = s.start;
      }

      if (s.length !== undefined) {
        settings._iDisplayLength = s.length;
      } // Order


      if (s.order !== undefined) {
        settings.aaSorting = [];
        $.each(s.order, function (i, col) {
          settings.aaSorting.push(col[0] >= columns.length ? [0, col[1]] : col);
        });
      } // Search


      if (s.search !== undefined) {
        $.extend(settings.oPreviousSearch, _fnSearchToHung(s.search));
      } // Columns
      //


      if (s.columns) {
        for (i = 0, ien = s.columns.length; i < ien; i++) {
          var col = s.columns[i]; // Visibility

          if (col.visible !== undefined) {
            columns[i].bVisible = col.visible;
          } // Search


          if (col.search !== undefined) {
            $.extend(settings.aoPreSearchCols[i], _fnSearchToHung(col.search));
          }
        }
      }

      _fnCallbackFire(settings, 'aoStateLoaded', 'stateLoaded', [settings, s]);

      callback();
    };

    if (!settings.oFeatures.bStateSave) {
      callback();
      return;
    }

    var state = settings.fnStateLoadCallback.call(settings.oInstance, settings, loaded);

    if (state !== undefined) {
      loaded(state);
    } // otherwise, wait for the loaded callback to be executed

  }
  /**
   * Return the settings object for a particular table
   *  @param {node} table table we are using as a dataTable
   *  @returns {object} Settings object - or null if not found
   *  @memberof DataTable#oApi
   */


  function _fnSettingsFromNode(table) {
    var settings = DataTable.settings;
    var idx = $.inArray(table, _pluck(settings, 'nTable'));
    return idx !== -1 ? settings[idx] : null;
  }
  /**
   * Log an error message
   *  @param {object} settings dataTables settings object
   *  @param {int} level log error messages, or display them to the user
   *  @param {string} msg error message
   *  @param {int} tn Technical note id to get more information about the error.
   *  @memberof DataTable#oApi
   */


  function _fnLog(settings, level, msg, tn) {
    msg = 'DataTables warning: ' + (settings ? 'table id=' + settings.sTableId + ' - ' : '') + msg;

    if (tn) {
      msg += '. For more information about this error, please see ' + 'http://datatables.net/tn/' + tn;
    }

    if (!level) {
      // Backwards compatibility pre 1.10
      var ext = DataTable.ext;
      var type = ext.sErrMode || ext.errMode;

      if (settings) {
        _fnCallbackFire(settings, null, 'error', [settings, tn, msg]);
      }

      if (type == 'alert') {
        alert(msg);
      } else if (type == 'throw') {
        throw new Error(msg);
      } else if (typeof type == 'function') {
        type(settings, tn, msg);
      }
    } else if (window.console && console.log) {
      console.log(msg);
    }
  }
  /**
   * See if a property is defined on one object, if so assign it to the other object
   *  @param {object} ret target object
   *  @param {object} src source object
   *  @param {string} name property
   *  @param {string} [mappedName] name to map too - optional, name used if not given
   *  @memberof DataTable#oApi
   */


  function _fnMap(ret, src, name, mappedName) {
    if ($.isArray(name)) {
      $.each(name, function (i, val) {
        if ($.isArray(val)) {
          _fnMap(ret, src, val[0], val[1]);
        } else {
          _fnMap(ret, src, val);
        }
      });
      return;
    }

    if (mappedName === undefined) {
      mappedName = name;
    }

    if (src[name] !== undefined) {
      ret[mappedName] = src[name];
    }
  }
  /**
   * Extend objects - very similar to jQuery.extend, but deep copy objects, and
   * shallow copy arrays. The reason we need to do this, is that we don't want to
   * deep copy array init values (such as aaSorting) since the dev wouldn't be
   * able to override them, but we do want to deep copy arrays.
   *  @param {object} out Object to extend
   *  @param {object} extender Object from which the properties will be applied to
   *      out
   *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
   *      independent copy with the exception of the `data` or `aaData` parameters
   *      if they are present. This is so you can pass in a collection to
   *      DataTables and have that used as your data source without breaking the
   *      references
   *  @returns {object} out Reference, just for convenience - out === the return.
   *  @memberof DataTable#oApi
   *  @todo This doesn't take account of arrays inside the deep copied objects.
   */


  function _fnExtend(out, extender, breakRefs) {
    var val;

    for (var prop in extender) {
      if (extender.hasOwnProperty(prop)) {
        val = extender[prop];

        if ($.isPlainObject(val)) {
          if (!$.isPlainObject(out[prop])) {
            out[prop] = {};
          }

          $.extend(true, out[prop], val);
        } else if (breakRefs && prop !== 'data' && prop !== 'aaData' && $.isArray(val)) {
          out[prop] = val.slice();
        } else {
          out[prop] = val;
        }
      }
    }

    return out;
  }
  /**
   * Bind an event handers to allow a click or return key to activate the callback.
   * This is good for accessibility since a return on the keyboard will have the
   * same effect as a click, if the element has focus.
   *  @param {element} n Element to bind the action to
   *  @param {object} oData Data object to pass to the triggered function
   *  @param {function} fn Callback function for when the event is triggered
   *  @memberof DataTable#oApi
   */


  function _fnBindAction(n, oData, fn) {
    $(n).on('click.DT', oData, function (e) {
      n.blur(); // Remove focus outline for mouse users

      fn(e);
    }).on('keypress.DT', oData, function (e) {
      if (e.which === 13) {
        e.preventDefault();
        fn(e);
      }
    }).on('selectstart.DT', function () {
      /* Take the brutal approach to cancelling text selection */
      return false;
    });
  }
  /**
   * Register a callback function. Easily allows a callback function to be added to
   * an array store of callback functions that can then all be called together.
   *  @param {object} oSettings dataTables settings object
   *  @param {string} sStore Name of the array storage for the callbacks in oSettings
   *  @param {function} fn Function to be called back
   *  @param {string} sName Identifying name for the callback (i.e. a label)
   *  @memberof DataTable#oApi
   */


  function _fnCallbackReg(oSettings, sStore, fn, sName) {
    if (fn) {
      oSettings[sStore].push({
        "fn": fn,
        "sName": sName
      });
    }
  }
  /**
   * Fire callback functions and trigger events. Note that the loop over the
   * callback array store is done backwards! Further note that you do not want to
   * fire off triggers in time sensitive applications (for example cell creation)
   * as its slow.
   *  @param {object} settings dataTables settings object
   *  @param {string} callbackArr Name of the array storage for the callbacks in
   *      oSettings
   *  @param {string} eventName Name of the jQuery custom event to trigger. If
   *      null no trigger is fired
   *  @param {array} args Array of arguments to pass to the callback function /
   *      trigger
   *  @memberof DataTable#oApi
   */


  function _fnCallbackFire(settings, callbackArr, eventName, args) {
    var ret = [];

    if (callbackArr) {
      ret = $.map(settings[callbackArr].slice().reverse(), function (val, i) {
        return val.fn.apply(settings.oInstance, args);
      });
    }

    if (eventName !== null) {
      var e = $.Event(eventName + '.dt');
      $(settings.nTable).trigger(e, args);
      ret.push(e.result);
    }

    return ret;
  }

  function _fnLengthOverflow(settings) {
    var start = settings._iDisplayStart,
        end = settings.fnDisplayEnd(),
        len = settings._iDisplayLength;
    /* If we have space to show extra rows (backing up from the end point - then do so */

    if (start >= end) {
      start = end - len;
    } // Keep the start record on the current page


    start -= start % len;

    if (len === -1 || start < 0) {
      start = 0;
    }

    settings._iDisplayStart = start;
  }

  function _fnRenderer(settings, type) {
    var renderer = settings.renderer;
    var host = DataTable.ext.renderer[type];

    if ($.isPlainObject(renderer) && renderer[type]) {
      // Specific renderer for this type. If available use it, otherwise use
      // the default.
      return host[renderer[type]] || host._;
    } else if (typeof renderer === 'string') {
      // Common renderer - if there is one available for this type use it,
      // otherwise use the default
      return host[renderer] || host._;
    } // Use the default


    return host._;
  }
  /**
   * Detect the data source being used for the table. Used to simplify the code
   * a little (ajax) and to make it compress a little smaller.
   *
   *  @param {object} settings dataTables settings object
   *  @returns {string} Data source
   *  @memberof DataTable#oApi
   */


  function _fnDataSource(settings) {
    if (settings.oFeatures.bServerSide) {
      return 'ssp';
    } else if (settings.ajax || settings.sAjaxSource) {
      return 'ajax';
    }

    return 'dom';
  }
  /**
   * Computed structure of the DataTables API, defined by the options passed to
   * `DataTable.Api.register()` when building the API.
   *
   * The structure is built in order to speed creation and extension of the Api
   * objects since the extensions are effectively pre-parsed.
   *
   * The array is an array of objects with the following structure, where this
   * base array represents the Api prototype base:
   *
   *     [
   *       {
   *         name:      'data'                -- string   - Property name
   *         val:       function () {},       -- function - Api method (or undefined if just an object
   *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
   *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
   *       },
   *       {
   *         name:     'row'
   *         val:       {},
   *         methodExt: [ ... ],
   *         propExt:   [
   *           {
   *             name:      'data'
   *             val:       function () {},
   *             methodExt: [ ... ],
   *             propExt:   [ ... ]
   *           },
   *           ...
   *         ]
   *       }
   *     ]
   *
   * @type {Array}
   * @ignore
   */


  var __apiStruct = [];
  /**
   * `Array.prototype` reference.
   *
   * @type object
   * @ignore
   */

  var __arrayProto = Array.prototype;
  /**
   * Abstraction for `context` parameter of the `Api` constructor to allow it to
   * take several different forms for ease of use.
   *
   * Each of the input parameter types will be converted to a DataTables settings
   * object where possible.
   *
   * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
   *   of:
   *
   *   * `string` - jQuery selector. Any DataTables' matching the given selector
   *     with be found and used.
   *   * `node` - `TABLE` node which has already been formed into a DataTable.
   *   * `jQuery` - A jQuery object of `TABLE` nodes.
   *   * `object` - DataTables settings object
   *   * `DataTables.Api` - API instance
   * @return {array|null} Matching DataTables settings objects. `null` or
   *   `undefined` is returned if no matching DataTable is found.
   * @ignore
   */

  var _toSettings = function _toSettings(mixed) {
    var idx, jq;
    var settings = DataTable.settings;
    var tables = $.map(settings, function (el, i) {
      return el.nTable;
    });

    if (!mixed) {
      return [];
    } else if (mixed.nTable && mixed.oApi) {
      // DataTables settings object
      return [mixed];
    } else if (mixed.nodeName && mixed.nodeName.toLowerCase() === 'table') {
      // Table node
      idx = $.inArray(mixed, tables);
      return idx !== -1 ? [settings[idx]] : null;
    } else if (mixed && typeof mixed.settings === 'function') {
      return mixed.settings().toArray();
    } else if (typeof mixed === 'string') {
      // jQuery selector
      jq = $(mixed);
    } else if (mixed instanceof $) {
      // jQuery object (also DataTables instance)
      jq = mixed;
    }

    if (jq) {
      return jq.map(function (i) {
        idx = $.inArray(this, tables);
        return idx !== -1 ? settings[idx] : null;
      }).toArray();
    }
  };
  /**
   * DataTables API class - used to control and interface with  one or more
   * DataTables enhanced tables.
   *
   * The API class is heavily based on jQuery, presenting a chainable interface
   * that you can use to interact with tables. Each instance of the API class has
   * a "context" - i.e. the tables that it will operate on. This could be a single
   * table, all tables on a page or a sub-set thereof.
   *
   * Additionally the API is designed to allow you to easily work with the data in
   * the tables, retrieving and manipulating it as required. This is done by
   * presenting the API class as an array like interface. The contents of the
   * array depend upon the actions requested by each method (for example
   * `rows().nodes()` will return an array of nodes, while `rows().data()` will
   * return an array of objects or arrays depending upon your table's
   * configuration). The API object has a number of array like methods (`push`,
   * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
   * `unique` etc) to assist your working with the data held in a table.
   *
   * Most methods (those which return an Api instance) are chainable, which means
   * the return from a method call also has all of the methods available that the
   * top level object had. For example, these two calls are equivalent:
   *
   *     // Not chained
   *     api.row.add( {...} );
   *     api.draw();
   *
   *     // Chained
   *     api.row.add( {...} ).draw();
   *
   * @class DataTable.Api
   * @param {array|object|string|jQuery} context DataTable identifier. This is
   *   used to define which DataTables enhanced tables this API will operate on.
   *   Can be one of:
   *
   *   * `string` - jQuery selector. Any DataTables' matching the given selector
   *     with be found and used.
   *   * `node` - `TABLE` node which has already been formed into a DataTable.
   *   * `jQuery` - A jQuery object of `TABLE` nodes.
   *   * `object` - DataTables settings object
   * @param {array} [data] Data to initialise the Api instance with.
   *
   * @example
   *   // Direct initialisation during DataTables construction
   *   var api = $('#example').DataTable();
   *
   * @example
   *   // Initialisation using a DataTables jQuery object
   *   var api = $('#example').dataTable().api();
   *
   * @example
   *   // Initialisation as a constructor
   *   var api = new $.fn.DataTable.Api( 'table.dataTable' );
   */


  _Api2 = function _Api(context, data) {
    if (!(this instanceof _Api2)) {
      return new _Api2(context, data);
    }

    var settings = [];

    var ctxSettings = function ctxSettings(o) {
      var a = _toSettings(o);

      if (a) {
        settings = settings.concat(a);
      }
    };

    if ($.isArray(context)) {
      for (var i = 0, ien = context.length; i < ien; i++) {
        ctxSettings(context[i]);
      }
    } else {
      ctxSettings(context);
    } // Remove duplicates


    this.context = _unique(settings); // Initial data

    if (data) {
      $.merge(this, data);
    } // selector


    this.selector = {
      rows: null,
      cols: null,
      opts: null
    };

    _Api2.extend(this, this, __apiStruct);
  };

  DataTable.Api = _Api2; // Don't destroy the existing prototype, just extend it. Required for jQuery 2's
  // isPlainObject.

  $.extend(_Api2.prototype, {
    any: function any() {
      return this.count() !== 0;
    },
    concat: __arrayProto.concat,
    context: [],
    // array of table settings objects
    count: function count() {
      return this.flatten().length;
    },
    each: function each(fn) {
      for (var i = 0, ien = this.length; i < ien; i++) {
        fn.call(this, this[i], i, this);
      }

      return this;
    },
    eq: function eq(idx) {
      var ctx = this.context;
      return ctx.length > idx ? new _Api2(ctx[idx], this[idx]) : null;
    },
    filter: function filter(fn) {
      var a = [];

      if (__arrayProto.filter) {
        a = __arrayProto.filter.call(this, fn, this);
      } else {
        // Compatibility for browsers without EMCA-252-5 (JS 1.6)
        for (var i = 0, ien = this.length; i < ien; i++) {
          if (fn.call(this, this[i], i, this)) {
            a.push(this[i]);
          }
        }
      }

      return new _Api2(this.context, a);
    },
    flatten: function flatten() {
      var a = [];
      return new _Api2(this.context, a.concat.apply(a, this.toArray()));
    },
    join: __arrayProto.join,
    indexOf: __arrayProto.indexOf || function (obj, start) {
      for (var i = start || 0, ien = this.length; i < ien; i++) {
        if (this[i] === obj) {
          return i;
        }
      }

      return -1;
    },
    iterator: function iterator(flatten, type, fn, alwaysNew) {
      var a = [],
          ret,
          i,
          ien,
          j,
          jen,
          context = this.context,
          rows,
          items,
          item,
          selector = this.selector; // Argument shifting

      if (typeof flatten === 'string') {
        alwaysNew = fn;
        fn = type;
        type = flatten;
        flatten = false;
      }

      for (i = 0, ien = context.length; i < ien; i++) {
        var apiInst = new _Api2(context[i]);

        if (type === 'table') {
          ret = fn.call(apiInst, context[i], i);

          if (ret !== undefined) {
            a.push(ret);
          }
        } else if (type === 'columns' || type === 'rows') {
          // this has same length as context - one entry for each table
          ret = fn.call(apiInst, context[i], this[i], i);

          if (ret !== undefined) {
            a.push(ret);
          }
        } else if (type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell') {
          // columns and rows share the same structure.
          // 'this' is an array of column indexes for each context
          items = this[i];

          if (type === 'column-rows') {
            rows = _selector_row_indexes(context[i], selector.opts);
          }

          for (j = 0, jen = items.length; j < jen; j++) {
            item = items[j];

            if (type === 'cell') {
              ret = fn.call(apiInst, context[i], item.row, item.column, i, j);
            } else {
              ret = fn.call(apiInst, context[i], item, i, j, rows);
            }

            if (ret !== undefined) {
              a.push(ret);
            }
          }
        }
      }

      if (a.length || alwaysNew) {
        var api = new _Api2(context, flatten ? a.concat.apply([], a) : a);
        var apiSelector = api.selector;
        apiSelector.rows = selector.rows;
        apiSelector.cols = selector.cols;
        apiSelector.opts = selector.opts;
        return api;
      }

      return this;
    },
    lastIndexOf: __arrayProto.lastIndexOf || function (obj, start) {
      // Bit cheeky...
      return this.indexOf.apply(this.toArray.reverse(), arguments);
    },
    length: 0,
    map: function map(fn) {
      var a = [];

      if (__arrayProto.map) {
        a = __arrayProto.map.call(this, fn, this);
      } else {
        // Compatibility for browsers without EMCA-252-5 (JS 1.6)
        for (var i = 0, ien = this.length; i < ien; i++) {
          a.push(fn.call(this, this[i], i));
        }
      }

      return new _Api2(this.context, a);
    },
    pluck: function pluck(prop) {
      return this.map(function (el) {
        return el[prop];
      });
    },
    pop: __arrayProto.pop,
    push: __arrayProto.push,
    // Does not return an API instance
    reduce: __arrayProto.reduce || function (fn, init) {
      return _fnReduce(this, fn, init, 0, this.length, 1);
    },
    reduceRight: __arrayProto.reduceRight || function (fn, init) {
      return _fnReduce(this, fn, init, this.length - 1, -1, -1);
    },
    reverse: __arrayProto.reverse,
    // Object with rows, columns and opts
    selector: null,
    shift: __arrayProto.shift,
    slice: function slice() {
      return new _Api2(this.context, this);
    },
    sort: __arrayProto.sort,
    // ? name - order?
    splice: __arrayProto.splice,
    toArray: function toArray() {
      return __arrayProto.slice.call(this);
    },
    to$: function to$() {
      return $(this);
    },
    toJQuery: function toJQuery() {
      return $(this);
    },
    unique: function unique() {
      return new _Api2(this.context, _unique(this));
    },
    unshift: __arrayProto.unshift
  });

  _Api2.extend = function (scope, obj, ext) {
    // Only extend API instances and static properties of the API
    if (!ext.length || !obj || !(obj instanceof _Api2) && !obj.__dt_wrapper) {
      return;
    }

    var i,
        ien,
        j,
        jen,
        struct,
        inner,
        methodScoping = function methodScoping(scope, fn, struc) {
      return function () {
        var ret = fn.apply(scope, arguments); // Method extension

        _Api2.extend(ret, ret, struc.methodExt);

        return ret;
      };
    };

    for (i = 0, ien = ext.length; i < ien; i++) {
      struct = ext[i]; // Value

      obj[struct.name] = typeof struct.val === 'function' ? methodScoping(scope, struct.val, struct) : $.isPlainObject(struct.val) ? {} : struct.val;
      obj[struct.name].__dt_wrapper = true; // Property extension

      _Api2.extend(scope, obj[struct.name], struct.propExt);
    }
  }; // @todo - Is there need for an augment function?
  // _Api.augment = function ( inst, name )
  // {
  // 	// Find src object in the structure from the name
  // 	var parts = name.split('.');
  // 	_Api.extend( inst, obj );
  // };
  //     [
  //       {
  //         name:      'data'                -- string   - Property name
  //         val:       function () {},       -- function - Api method (or undefined if just an object
  //         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
  //         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
  //       },
  //       {
  //         name:     'row'
  //         val:       {},
  //         methodExt: [ ... ],
  //         propExt:   [
  //           {
  //             name:      'data'
  //             val:       function () {},
  //             methodExt: [ ... ],
  //             propExt:   [ ... ]
  //           },
  //           ...
  //         ]
  //       }
  //     ]


  _Api2.register = _api_register = function _api_register(name, val) {
    if ($.isArray(name)) {
      for (var j = 0, jen = name.length; j < jen; j++) {
        _Api2.register(name[j], val);
      }

      return;
    }

    var i,
        ien,
        heir = name.split('.'),
        struct = __apiStruct,
        key,
        method;

    var find = function find(src, name) {
      for (var i = 0, ien = src.length; i < ien; i++) {
        if (src[i].name === name) {
          return src[i];
        }
      }

      return null;
    };

    for (i = 0, ien = heir.length; i < ien; i++) {
      method = heir[i].indexOf('()') !== -1;
      key = method ? heir[i].replace('()', '') : heir[i];
      var src = find(struct, key);

      if (!src) {
        src = {
          name: key,
          val: {},
          methodExt: [],
          propExt: []
        };
        struct.push(src);
      }

      if (i === ien - 1) {
        src.val = val;
      } else {
        struct = method ? src.methodExt : src.propExt;
      }
    }
  };

  _Api2.registerPlural = _api_registerPlural = function _api_registerPlural(pluralName, singularName, val) {
    _Api2.register(pluralName, val);

    _Api2.register(singularName, function () {
      var ret = val.apply(this, arguments);

      if (ret === this) {
        // Returned item is the API instance that was passed in, return it
        return this;
      } else if (ret instanceof _Api2) {
        // New API instance returned, want the value from the first item
        // in the returned array for the singular result.
        return ret.length ? $.isArray(ret[0]) ? new _Api2(ret.context, ret[0]) : // Array results are 'enhanced'
        ret[0] : undefined;
      } // Non-API return - just fire it back


      return ret;
    });
  };
  /**
   * Selector for HTML tables. Apply the given selector to the give array of
   * DataTables settings objects.
   *
   * @param {string|integer} [selector] jQuery selector string or integer
   * @param  {array} Array of DataTables settings objects to be filtered
   * @return {array}
   * @ignore
   */


  var __table_selector = function __table_selector(selector, a) {
    // Integer is used to pick out a table by index
    if (typeof selector === 'number') {
      return [a[selector]];
    } // Perform a jQuery selector on the table nodes


    var nodes = $.map(a, function (el, i) {
      return el.nTable;
    });
    return $(nodes).filter(selector).map(function (i) {
      // Need to translate back from the table node to the settings
      var idx = $.inArray(this, nodes);
      return a[idx];
    }).toArray();
  };
  /**
   * Context selector for the API's context (i.e. the tables the API instance
   * refers to.
   *
   * @name    DataTable.Api#tables
   * @param {string|integer} [selector] Selector to pick which tables the iterator
   *   should operate on. If not given, all tables in the current context are
   *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to
   *   select multiple tables or as an integer to select a single table.
   * @returns {DataTable.Api} Returns a new API instance if a selector is given.
   */


  _api_register('tables()', function (selector) {
    // A new instance is created if there was a selector specified
    return selector ? new _Api2(__table_selector(selector, this.context)) : this;
  });

  _api_register('table()', function (selector) {
    var tables = this.tables(selector);
    var ctx = tables.context; // Truncate to the first matched table

    return ctx.length ? new _Api2(ctx[0]) : tables;
  });

  _api_registerPlural('tables().nodes()', 'table().node()', function () {
    return this.iterator('table', function (ctx) {
      return ctx.nTable;
    }, 1);
  });

  _api_registerPlural('tables().body()', 'table().body()', function () {
    return this.iterator('table', function (ctx) {
      return ctx.nTBody;
    }, 1);
  });

  _api_registerPlural('tables().header()', 'table().header()', function () {
    return this.iterator('table', function (ctx) {
      return ctx.nTHead;
    }, 1);
  });

  _api_registerPlural('tables().footer()', 'table().footer()', function () {
    return this.iterator('table', function (ctx) {
      return ctx.nTFoot;
    }, 1);
  });

  _api_registerPlural('tables().containers()', 'table().container()', function () {
    return this.iterator('table', function (ctx) {
      return ctx.nTableWrapper;
    }, 1);
  });
  /**
   * Redraw the tables in the current context.
   */


  _api_register('draw()', function (paging) {
    return this.iterator('table', function (settings) {
      if (paging === 'page') {
        _fnDraw(settings);
      } else {
        if (typeof paging === 'string') {
          paging = paging === 'full-hold' ? false : true;
        }

        _fnReDraw(settings, paging === false);
      }
    });
  });
  /**
   * Get the current page index.
   *
   * @return {integer} Current page index (zero based)
   */

  /**
  * Set the current page.
  *
  * Note that if you attempt to show a page which does not exist, DataTables will
  * not throw an error, but rather reset the paging.
  *
  * @param {integer|string} action The paging action to take. This can be one of:
  *  * `integer` - The page index to jump to
  *  * `string` - An action to take:
  *    * `first` - Jump to first page.
  *    * `next` - Jump to the next page
  *    * `previous` - Jump to previous page
  *    * `last` - Jump to the last page.
  * @returns {DataTables.Api} this
  */


  _api_register('page()', function (action) {
    if (action === undefined) {
      return this.page.info().page; // not an expensive call
    } // else, have an action to take on all tables


    return this.iterator('table', function (settings) {
      _fnPageChange(settings, action);
    });
  });
  /**
   * Paging information for the first table in the current context.
   *
   * If you require paging information for another table, use the `table()` method
   * with a suitable selector.
   *
   * @return {object} Object with the following properties set:
   *  * `page` - Current page index (zero based - i.e. the first page is `0`)
   *  * `pages` - Total number of pages
   *  * `start` - Display index for the first record shown on the current page
   *  * `end` - Display index for the last record shown on the current page
   *  * `length` - Display length (number of records). Note that generally `start
   *    + length = end`, but this is not always true, for example if there are
   *    only 2 records to show on the final page, with a length of 10.
   *  * `recordsTotal` - Full data set length
   *  * `recordsDisplay` - Data set length once the current filtering criterion
   *    are applied.
   */


  _api_register('page.info()', function (action) {
    if (this.context.length === 0) {
      return undefined;
    }

    var settings = this.context[0],
        start = settings._iDisplayStart,
        len = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1,
        visRecords = settings.fnRecordsDisplay(),
        all = len === -1;
    return {
      "page": all ? 0 : Math.floor(start / len),
      "pages": all ? 1 : Math.ceil(visRecords / len),
      "start": start,
      "end": settings.fnDisplayEnd(),
      "length": len,
      "recordsTotal": settings.fnRecordsTotal(),
      "recordsDisplay": visRecords,
      "serverSide": _fnDataSource(settings) === 'ssp'
    };
  });
  /**
   * Get the current page length.
   *
   * @return {integer} Current page length. Note `-1` indicates that all records
   *   are to be shown.
   */

  /**
  * Set the current page length.
  *
  * @param {integer} Page length to set. Use `-1` to show all records.
  * @returns {DataTables.Api} this
  */


  _api_register('page.len()', function (len) {
    // Note that we can't call this function 'length()' because `length`
    // is a Javascript property of functions which defines how many arguments
    // the function expects.
    if (len === undefined) {
      return this.context.length !== 0 ? this.context[0]._iDisplayLength : undefined;
    } // else, set the page length


    return this.iterator('table', function (settings) {
      _fnLengthChange(settings, len);
    });
  });

  var __reload = function __reload(settings, holdPosition, callback) {
    // Use the draw event to trigger a callback
    if (callback) {
      var api = new _Api2(settings);
      api.one('draw', function () {
        callback(api.ajax.json());
      });
    }

    if (_fnDataSource(settings) == 'ssp') {
      _fnReDraw(settings, holdPosition);
    } else {
      _fnProcessingDisplay(settings, true); // Cancel an existing request


      var xhr = settings.jqXHR;

      if (xhr && xhr.readyState !== 4) {
        xhr.abort();
      } // Trigger xhr


      _fnBuildAjax(settings, [], function (json) {
        _fnClearTable(settings);

        var data = _fnAjaxDataSrc(settings, json);

        for (var i = 0, ien = data.length; i < ien; i++) {
          _fnAddData(settings, data[i]);
        }

        _fnReDraw(settings, holdPosition);

        _fnProcessingDisplay(settings, false);
      });
    }
  };
  /**
   * Get the JSON response from the last Ajax request that DataTables made to the
   * server. Note that this returns the JSON from the first table in the current
   * context.
   *
   * @return {object} JSON received from the server.
   */


  _api_register('ajax.json()', function () {
    var ctx = this.context;

    if (ctx.length > 0) {
      return ctx[0].json;
    } // else return undefined;

  });
  /**
   * Get the data submitted in the last Ajax request
   */


  _api_register('ajax.params()', function () {
    var ctx = this.context;

    if (ctx.length > 0) {
      return ctx[0].oAjaxData;
    } // else return undefined;

  });
  /**
   * Reload tables from the Ajax data source. Note that this function will
   * automatically re-draw the table when the remote data has been loaded.
   *
   * @param {boolean} [reset=true] Reset (default) or hold the current paging
   *   position. A full re-sort and re-filter is performed when this method is
   *   called, which is why the pagination reset is the default action.
   * @returns {DataTables.Api} this
   */


  _api_register('ajax.reload()', function (callback, resetPaging) {
    return this.iterator('table', function (settings) {
      __reload(settings, resetPaging === false, callback);
    });
  });
  /**
   * Get the current Ajax URL. Note that this returns the URL from the first
   * table in the current context.
   *
   * @return {string} Current Ajax source URL
   */

  /**
  * Set the Ajax URL. Note that this will set the URL for all tables in the
  * current context.
  *
  * @param {string} url URL to set.
  * @returns {DataTables.Api} this
  */


  _api_register('ajax.url()', function (url) {
    var ctx = this.context;

    if (url === undefined) {
      // get
      if (ctx.length === 0) {
        return undefined;
      }

      ctx = ctx[0];
      return ctx.ajax ? $.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax : ctx.sAjaxSource;
    } // set


    return this.iterator('table', function (settings) {
      if ($.isPlainObject(settings.ajax)) {
        settings.ajax.url = url;
      } else {
        settings.ajax = url;
      } // No need to consider sAjaxSource here since DataTables gives priority
      // to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any
      // value of `sAjaxSource` redundant.

    });
  });
  /**
   * Load data from the newly set Ajax URL. Note that this method is only
   * available when `ajax.url()` is used to set a URL. Additionally, this method
   * has the same effect as calling `ajax.reload()` but is provided for
   * convenience when setting a new URL. Like `ajax.reload()` it will
   * automatically redraw the table once the remote data has been loaded.
   *
   * @returns {DataTables.Api} this
   */


  _api_register('ajax.url().load()', function (callback, resetPaging) {
    // Same as a reload, but makes sense to present it for easy access after a
    // url change
    return this.iterator('table', function (ctx) {
      __reload(ctx, resetPaging === false, callback);
    });
  });

  var _selector_run = function _selector_run(type, selector, selectFn, settings, opts) {
    var out = [],
        res,
        a,
        i,
        ien,
        j,
        jen,
        selectorType = _typeof(selector); // Can't just check for isArray here, as an API or jQuery instance might be
    // given with their array like look


    if (!selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined) {
      selector = [selector];
    }

    for (i = 0, ien = selector.length; i < ien; i++) {
      // Only split on simple strings - complex expressions will be jQuery selectors
      a = selector[i] && selector[i].split && !selector[i].match(/[\[\(:]/) ? selector[i].split(',') : [selector[i]];

      for (j = 0, jen = a.length; j < jen; j++) {
        res = selectFn(typeof a[j] === 'string' ? $.trim(a[j]) : a[j]);

        if (res && res.length) {
          out = out.concat(res);
        }
      }
    } // selector extensions


    var ext = _ext.selector[type];

    if (ext.length) {
      for (i = 0, ien = ext.length; i < ien; i++) {
        out = ext[i](settings, opts, out);
      }
    }

    return _unique(out);
  };

  var _selector_opts = function _selector_opts(opts) {
    if (!opts) {
      opts = {};
    } // Backwards compatibility for 1.9- which used the terminology filter rather
    // than search


    if (opts.filter && opts.search === undefined) {
      opts.search = opts.filter;
    }

    return $.extend({
      search: 'none',
      order: 'current',
      page: 'all'
    }, opts);
  };

  var _selector_first = function _selector_first(inst) {
    // Reduce the API instance to the first item found
    for (var i = 0, ien = inst.length; i < ien; i++) {
      if (inst[i].length > 0) {
        // Assign the first element to the first item in the instance
        // and truncate the instance and context
        inst[0] = inst[i];
        inst[0].length = 1;
        inst.length = 1;
        inst.context = [inst.context[i]];
        return inst;
      }
    } // Not found - return an empty instance


    inst.length = 0;
    return inst;
  };

  var _selector_row_indexes = function _selector_row_indexes(settings, opts) {
    var i,
        ien,
        tmp,
        a = [],
        displayFiltered = settings.aiDisplay,
        displayMaster = settings.aiDisplayMaster;
    var search = opts.search,
        // none, applied, removed
    order = opts.order,
        // applied, current, index (original - compatibility with 1.9)
    page = opts.page; // all, current

    if (_fnDataSource(settings) == 'ssp') {
      // In server-side processing mode, most options are irrelevant since
      // rows not shown don't exist and the index order is the applied order
      // Removed is a special case - for consistency just return an empty
      // array
      return search === 'removed' ? [] : _range(0, displayMaster.length);
    } else if (page == 'current') {
      // Current page implies that order=current and fitler=applied, since it is
      // fairly senseless otherwise, regardless of what order and search actually
      // are
      for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {
        a.push(displayFiltered[i]);
      }
    } else if (order == 'current' || order == 'applied') {
      a = search == 'none' ? displayMaster.slice() : // no search
      search == 'applied' ? displayFiltered.slice() : // applied search
      $.map(displayMaster, function (el, i) {
        // removed search
        return $.inArray(el, displayFiltered) === -1 ? el : null;
      });
    } else if (order == 'index' || order == 'original') {
      for (i = 0, ien = settings.aoData.length; i < ien; i++) {
        if (search == 'none') {
          a.push(i);
        } else {
          // applied | removed
          tmp = $.inArray(i, displayFiltered);

          if (tmp === -1 && search == 'removed' || tmp >= 0 && search == 'applied') {
            a.push(i);
          }
        }
      }
    }

    return a;
  };
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * Rows
   *
   * {}          - no selector - use all available rows
   * {integer}   - row aoData index
   * {node}      - TR node
   * {string}    - jQuery selector to apply to the TR elements
   * {array}     - jQuery array of nodes, or simply an array of TR nodes
   *
   */


  var __row_selector = function __row_selector(settings, selector, opts) {
    var rows;

    var run = function run(sel) {
      var selInt = _intVal(sel);

      var i, ien; // Short cut - selector is a number and no options provided (default is
      // all records, so no need to check if the index is in there, since it
      // must be - dev error if the index doesn't exist).

      if (selInt !== null && !opts) {
        return [selInt];
      }

      if (!rows) {
        rows = _selector_row_indexes(settings, opts);
      }

      if (selInt !== null && $.inArray(selInt, rows) !== -1) {
        // Selector - integer
        return [selInt];
      } else if (sel === null || sel === undefined || sel === '') {
        // Selector - none
        return rows;
      } // Selector - function


      if (typeof sel === 'function') {
        return $.map(rows, function (idx) {
          var row = settings.aoData[idx];
          return sel(idx, row._aData, row.nTr) ? idx : null;
        });
      } // Get nodes in the order from the `rows` array with null values removed


      var nodes = _removeEmpty(_pluck_order(settings.aoData, rows, 'nTr')); // Selector - node


      if (sel.nodeName) {
        if (sel._DT_RowIndex !== undefined) {
          return [sel._DT_RowIndex]; // Property added by DT for fast lookup
        } else if (sel._DT_CellIndex) {
          return [sel._DT_CellIndex.row];
        } else {
          var host = $(sel).closest('*[data-dt-row]');
          return host.length ? [host.data('dt-row')] : [];
        }
      } // ID selector. Want to always be able to select rows by id, regardless
      // of if the tr element has been created or not, so can't rely upon
      // jQuery here - hence a custom implementation. This does not match
      // Sizzle's fast selector or HTML4 - in HTML5 the ID can be anything,
      // but to select it using a CSS selector engine (like Sizzle or
      // querySelect) it would need to need to be escaped for some characters.
      // DataTables simplifies this for row selectors since you can select
      // only a row. A # indicates an id any anything that follows is the id -
      // unescaped.


      if (typeof sel === 'string' && sel.charAt(0) === '#') {
        // get row index from id
        var rowObj = settings.aIds[sel.replace(/^#/, '')];

        if (rowObj !== undefined) {
          return [rowObj.idx];
        } // need to fall through to jQuery in case there is DOM id that
        // matches

      } // Selector - jQuery selector string, array of nodes or jQuery object/
      // As jQuery's .filter() allows jQuery objects to be passed in filter,
      // it also allows arrays, so this will cope with all three options


      return $(nodes).filter(sel).map(function () {
        return this._DT_RowIndex;
      }).toArray();
    };

    return _selector_run('row', selector, run, settings, opts);
  };

  _api_register('rows()', function (selector, opts) {
    // argument shifting
    if (selector === undefined) {
      selector = '';
    } else if ($.isPlainObject(selector)) {
      opts = selector;
      selector = '';
    }

    opts = _selector_opts(opts);
    var inst = this.iterator('table', function (settings) {
      return __row_selector(settings, selector, opts);
    }, 1); // Want argument shifting here and in __row_selector?

    inst.selector.rows = selector;
    inst.selector.opts = opts;
    return inst;
  });

  _api_register('rows().nodes()', function () {
    return this.iterator('row', function (settings, row) {
      return settings.aoData[row].nTr || undefined;
    }, 1);
  });

  _api_register('rows().data()', function () {
    return this.iterator(true, 'rows', function (settings, rows) {
      return _pluck_order(settings.aoData, rows, '_aData');
    }, 1);
  });

  _api_registerPlural('rows().cache()', 'row().cache()', function (type) {
    return this.iterator('row', function (settings, row) {
      var r = settings.aoData[row];
      return type === 'search' ? r._aFilterData : r._aSortData;
    }, 1);
  });

  _api_registerPlural('rows().invalidate()', 'row().invalidate()', function (src) {
    return this.iterator('row', function (settings, row) {
      _fnInvalidate(settings, row, src);
    });
  });

  _api_registerPlural('rows().indexes()', 'row().index()', function () {
    return this.iterator('row', function (settings, row) {
      return row;
    }, 1);
  });

  _api_registerPlural('rows().ids()', 'row().id()', function (hash) {
    var a = [];
    var context = this.context; // `iterator` will drop undefined values, but in this case we want them

    for (var i = 0, ien = context.length; i < ien; i++) {
      for (var j = 0, jen = this[i].length; j < jen; j++) {
        var id = context[i].rowIdFn(context[i].aoData[this[i][j]]._aData);
        a.push((hash === true ? '#' : '') + id);
      }
    }

    return new _Api2(context, a);
  });

  _api_registerPlural('rows().remove()', 'row().remove()', function () {
    var that = this;
    this.iterator('row', function (settings, row, thatIdx) {
      var data = settings.aoData;
      var rowData = data[row];
      var i, ien, j, jen;
      var loopRow, loopCells;
      data.splice(row, 1); // Update the cached indexes

      for (i = 0, ien = data.length; i < ien; i++) {
        loopRow = data[i];
        loopCells = loopRow.anCells; // Rows

        if (loopRow.nTr !== null) {
          loopRow.nTr._DT_RowIndex = i;
        } // Cells


        if (loopCells !== null) {
          for (j = 0, jen = loopCells.length; j < jen; j++) {
            loopCells[j]._DT_CellIndex.row = i;
          }
        }
      } // Delete from the display arrays


      _fnDeleteIndex(settings.aiDisplayMaster, row);

      _fnDeleteIndex(settings.aiDisplay, row);

      _fnDeleteIndex(that[thatIdx], row, false); // maintain local indexes
      // For server-side processing tables - subtract the deleted row from the count


      if (settings._iRecordsDisplay > 0) {
        settings._iRecordsDisplay--;
      } // Check for an 'overflow' they case for displaying the table


      _fnLengthOverflow(settings); // Remove the row's ID reference if there is one


      var id = settings.rowIdFn(rowData._aData);

      if (id !== undefined) {
        delete settings.aIds[id];
      }
    });
    this.iterator('table', function (settings) {
      for (var i = 0, ien = settings.aoData.length; i < ien; i++) {
        settings.aoData[i].idx = i;
      }
    });
    return this;
  });

  _api_register('rows.add()', function (rows) {
    var newRows = this.iterator('table', function (settings) {
      var row, i, ien;
      var out = [];

      for (i = 0, ien = rows.length; i < ien; i++) {
        row = rows[i];

        if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {
          out.push(_fnAddTr(settings, row)[0]);
        } else {
          out.push(_fnAddData(settings, row));
        }
      }

      return out;
    }, 1); // Return an Api.rows() extended instance, so rows().nodes() etc can be used

    var modRows = this.rows(-1);
    modRows.pop();
    $.merge(modRows, newRows);
    return modRows;
  });
  /**
   *
   */


  _api_register('row()', function (selector, opts) {
    return _selector_first(this.rows(selector, opts));
  });

  _api_register('row().data()', function (data) {
    var ctx = this.context;

    if (data === undefined) {
      // Get
      return ctx.length && this.length ? ctx[0].aoData[this[0]]._aData : undefined;
    } // Set


    ctx[0].aoData[this[0]]._aData = data; // Automatically invalidate

    _fnInvalidate(ctx[0], this[0], 'data');

    return this;
  });

  _api_register('row().node()', function () {
    var ctx = this.context;
    return ctx.length && this.length ? ctx[0].aoData[this[0]].nTr || null : null;
  });

  _api_register('row.add()', function (row) {
    // Allow a jQuery object to be passed in - only a single row is added from
    // it though - the first element in the set
    if (row instanceof $ && row.length) {
      row = row[0];
    }

    var rows = this.iterator('table', function (settings) {
      if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {
        return _fnAddTr(settings, row)[0];
      }

      return _fnAddData(settings, row);
    }); // Return an Api.rows() extended instance, with the newly added row selected

    return this.row(rows[0]);
  });

  var __details_add = function __details_add(ctx, row, data, klass) {
    // Convert to array of TR elements
    var rows = [];

    var addRow = function addRow(r, k) {
      // Recursion to allow for arrays of jQuery objects
      if ($.isArray(r) || r instanceof $) {
        for (var i = 0, ien = r.length; i < ien; i++) {
          addRow(r[i], k);
        }

        return;
      } // If we get a TR element, then just add it directly - up to the dev
      // to add the correct number of columns etc


      if (r.nodeName && r.nodeName.toLowerCase() === 'tr') {
        rows.push(r);
      } else {
        // Otherwise create a row with a wrapper
        var created = $('<tr><td/></tr>').addClass(k);
        $('td', created).addClass(k).html(r)[0].colSpan = _fnVisbleColumns(ctx);
        rows.push(created[0]);
      }
    };

    addRow(data, klass);

    if (row._details) {
      row._details.detach();
    }

    row._details = $(rows); // If the children were already shown, that state should be retained

    if (row._detailsShow) {
      row._details.insertAfter(row.nTr);
    }
  };

  var __details_remove = function __details_remove(api, idx) {
    var ctx = api.context;

    if (ctx.length) {
      var row = ctx[0].aoData[idx !== undefined ? idx : api[0]];

      if (row && row._details) {
        row._details.remove();

        row._detailsShow = undefined;
        row._details = undefined;
      }
    }
  };

  var __details_display = function __details_display(api, show) {
    var ctx = api.context;

    if (ctx.length && api.length) {
      var row = ctx[0].aoData[api[0]];

      if (row._details) {
        row._detailsShow = show;

        if (show) {
          row._details.insertAfter(row.nTr);
        } else {
          row._details.detach();
        }

        __details_events(ctx[0]);
      }
    }
  };

  var __details_events = function __details_events(settings) {
    var api = new _Api2(settings);
    var namespace = '.dt.DT_details';
    var drawEvent = 'draw' + namespace;
    var colvisEvent = 'column-visibility' + namespace;
    var destroyEvent = 'destroy' + namespace;
    var data = settings.aoData;
    api.off(drawEvent + ' ' + colvisEvent + ' ' + destroyEvent);

    if (_pluck(data, '_details').length > 0) {
      // On each draw, insert the required elements into the document
      api.on(drawEvent, function (e, ctx) {
        if (settings !== ctx) {
          return;
        }

        api.rows({
          page: 'current'
        }).eq(0).each(function (idx) {
          // Internal data grab
          var row = data[idx];

          if (row._detailsShow) {
            row._details.insertAfter(row.nTr);
          }
        });
      }); // Column visibility change - update the colspan

      api.on(colvisEvent, function (e, ctx, idx, vis) {
        if (settings !== ctx) {
          return;
        } // Update the colspan for the details rows (note, only if it already has
        // a colspan)


        var row,
            visible = _fnVisbleColumns(ctx);

        for (var i = 0, ien = data.length; i < ien; i++) {
          row = data[i];

          if (row._details) {
            row._details.children('td[colspan]').attr('colspan', visible);
          }
        }
      }); // Table destroyed - nuke any child rows

      api.on(destroyEvent, function (e, ctx) {
        if (settings !== ctx) {
          return;
        }

        for (var i = 0, ien = data.length; i < ien; i++) {
          if (data[i]._details) {
            __details_remove(api, i);
          }
        }
      });
    }
  }; // Strings for the method names to help minification


  var _emp = '';

  var _child_obj = _emp + 'row().child';

  var _child_mth = _child_obj + '()'; // data can be:
  //  tr
  //  string
  //  jQuery or array of any of the above


  _api_register(_child_mth, function (data, klass) {
    var ctx = this.context;

    if (data === undefined) {
      // get
      return ctx.length && this.length ? ctx[0].aoData[this[0]]._details : undefined;
    } else if (data === true) {
      // show
      this.child.show();
    } else if (data === false) {
      // remove
      __details_remove(this);
    } else if (ctx.length && this.length) {
      // set
      __details_add(ctx[0], ctx[0].aoData[this[0]], data, klass);
    }

    return this;
  });

  _api_register([_child_obj + '.show()', _child_mth + '.show()' // only when `child()` was called with parameters (without
  ], function (show) {
    // it returns an object and this method is not executed)
    __details_display(this, true);

    return this;
  });

  _api_register([_child_obj + '.hide()', _child_mth + '.hide()' // only when `child()` was called with parameters (without
  ], function () {
    // it returns an object and this method is not executed)
    __details_display(this, false);

    return this;
  });

  _api_register([_child_obj + '.remove()', _child_mth + '.remove()' // only when `child()` was called with parameters (without
  ], function () {
    // it returns an object and this method is not executed)
    __details_remove(this);

    return this;
  });

  _api_register(_child_obj + '.isShown()', function () {
    var ctx = this.context;

    if (ctx.length && this.length) {
      // _detailsShown as false or undefined will fall through to return false
      return ctx[0].aoData[this[0]]._detailsShow || false;
    }

    return false;
  });
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * Columns
   *
   * {integer}           - column index (>=0 count from left, <0 count from right)
   * "{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
   * "{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)
   * "{string}:name"     - column name
   * "{string}"          - jQuery selector on column header nodes
   *
   */
  // can be an array of these items, comma separated list, or an array of comma
  // separated lists


  var __re_column_selector = /^([^:]+):(name|visIdx|visible)$/; // r1 and r2 are redundant - but it means that the parameters match for the
  // iterator callback in columns().data()

  var __columnData = function __columnData(settings, column, r1, r2, rows) {
    var a = [];

    for (var row = 0, ien = rows.length; row < ien; row++) {
      a.push(_fnGetCellData(settings, rows[row], column));
    }

    return a;
  };

  var __column_selector = function __column_selector(settings, selector, opts) {
    var columns = settings.aoColumns,
        names = _pluck(columns, 'sName'),
        nodes = _pluck(columns, 'nTh');

    var run = function run(s) {
      var selInt = _intVal(s); // Selector - all


      if (s === '') {
        return _range(columns.length);
      } // Selector - index


      if (selInt !== null) {
        return [selInt >= 0 ? selInt : // Count from left
        columns.length + selInt // Count from right (+ because its a negative value)
        ];
      } // Selector = function


      if (typeof s === 'function') {
        var rows = _selector_row_indexes(settings, opts);

        return $.map(columns, function (col, idx) {
          return s(idx, __columnData(settings, idx, 0, 0, rows), nodes[idx]) ? idx : null;
        });
      } // jQuery or string selector


      var match = typeof s === 'string' ? s.match(__re_column_selector) : '';

      if (match) {
        switch (match[2]) {
          case 'visIdx':
          case 'visible':
            var idx = parseInt(match[1], 10); // Visible index given, convert to column index

            if (idx < 0) {
              // Counting from the right
              var visColumns = $.map(columns, function (col, i) {
                return col.bVisible ? i : null;
              });
              return [visColumns[visColumns.length + idx]];
            } // Counting from the left


            return [_fnVisibleToColumnIndex(settings, idx)];

          case 'name':
            // match by name. `names` is column index complete and in order
            return $.map(names, function (name, i) {
              return name === match[1] ? i : null;
            });

          default:
            return [];
        }
      } // Cell in the table body


      if (s.nodeName && s._DT_CellIndex) {
        return [s._DT_CellIndex.column];
      } // jQuery selector on the TH elements for the columns


      var jqResult = $(nodes).filter(s).map(function () {
        return $.inArray(this, nodes); // `nodes` is column index complete and in order
      }).toArray();

      if (jqResult.length || !s.nodeName) {
        return jqResult;
      } // Otherwise a node which might have a `dt-column` data attribute, or be
      // a child or such an element


      var host = $(s).closest('*[data-dt-column]');
      return host.length ? [host.data('dt-column')] : [];
    };

    return _selector_run('column', selector, run, settings, opts);
  };

  var __setColumnVis = function __setColumnVis(settings, column, vis) {
    var cols = settings.aoColumns,
        col = cols[column],
        data = settings.aoData,
        row,
        cells,
        i,
        ien,
        tr; // Get

    if (vis === undefined) {
      return col.bVisible;
    } // Set
    // No change


    if (col.bVisible === vis) {
      return;
    }

    if (vis) {
      // Insert column
      // Need to decide if we should use appendChild or insertBefore
      var insertBefore = $.inArray(true, _pluck(cols, 'bVisible'), column + 1);

      for (i = 0, ien = data.length; i < ien; i++) {
        tr = data[i].nTr;
        cells = data[i].anCells;

        if (tr) {
          // insertBefore can act like appendChild if 2nd arg is null
          tr.insertBefore(cells[column], cells[insertBefore] || null);
        }
      }
    } else {
      // Remove column
      $(_pluck(settings.aoData, 'anCells', column)).detach();
    } // Common actions


    col.bVisible = vis;

    _fnDrawHead(settings, settings.aoHeader);

    _fnDrawHead(settings, settings.aoFooter);

    _fnSaveState(settings);
  };

  _api_register('columns()', function (selector, opts) {
    // argument shifting
    if (selector === undefined) {
      selector = '';
    } else if ($.isPlainObject(selector)) {
      opts = selector;
      selector = '';
    }

    opts = _selector_opts(opts);
    var inst = this.iterator('table', function (settings) {
      return __column_selector(settings, selector, opts);
    }, 1); // Want argument shifting here and in _row_selector?

    inst.selector.cols = selector;
    inst.selector.opts = opts;
    return inst;
  });

  _api_registerPlural('columns().header()', 'column().header()', function (selector, opts) {
    return this.iterator('column', function (settings, column) {
      return settings.aoColumns[column].nTh;
    }, 1);
  });

  _api_registerPlural('columns().footer()', 'column().footer()', function (selector, opts) {
    return this.iterator('column', function (settings, column) {
      return settings.aoColumns[column].nTf;
    }, 1);
  });

  _api_registerPlural('columns().data()', 'column().data()', function () {
    return this.iterator('column-rows', __columnData, 1);
  });

  _api_registerPlural('columns().dataSrc()', 'column().dataSrc()', function () {
    return this.iterator('column', function (settings, column) {
      return settings.aoColumns[column].mData;
    }, 1);
  });

  _api_registerPlural('columns().cache()', 'column().cache()', function (type) {
    return this.iterator('column-rows', function (settings, column, i, j, rows) {
      return _pluck_order(settings.aoData, rows, type === 'search' ? '_aFilterData' : '_aSortData', column);
    }, 1);
  });

  _api_registerPlural('columns().nodes()', 'column().nodes()', function () {
    return this.iterator('column-rows', function (settings, column, i, j, rows) {
      return _pluck_order(settings.aoData, rows, 'anCells', column);
    }, 1);
  });

  _api_registerPlural('columns().visible()', 'column().visible()', function (vis, calc) {
    var ret = this.iterator('column', function (settings, column) {
      if (vis === undefined) {
        return settings.aoColumns[column].bVisible;
      } // else


      __setColumnVis(settings, column, vis);
    }); // Group the column visibility changes

    if (vis !== undefined) {
      // Second loop once the first is done for events
      this.iterator('column', function (settings, column) {
        _fnCallbackFire(settings, null, 'column-visibility', [settings, column, vis, calc]);
      });

      if (calc === undefined || calc) {
        this.columns.adjust();
      }
    }

    return ret;
  });

  _api_registerPlural('columns().indexes()', 'column().index()', function (type) {
    return this.iterator('column', function (settings, column) {
      return type === 'visible' ? _fnColumnIndexToVisible(settings, column) : column;
    }, 1);
  });

  _api_register('columns.adjust()', function () {
    return this.iterator('table', function (settings) {
      _fnAdjustColumnSizing(settings);
    }, 1);
  });

  _api_register('column.index()', function (type, idx) {
    if (this.context.length !== 0) {
      var ctx = this.context[0];

      if (type === 'fromVisible' || type === 'toData') {
        return _fnVisibleToColumnIndex(ctx, idx);
      } else if (type === 'fromData' || type === 'toVisible') {
        return _fnColumnIndexToVisible(ctx, idx);
      }
    }
  });

  _api_register('column()', function (selector, opts) {
    return _selector_first(this.columns(selector, opts));
  });

  var __cell_selector = function __cell_selector(settings, selector, opts) {
    var data = settings.aoData;

    var rows = _selector_row_indexes(settings, opts);

    var cells = _removeEmpty(_pluck_order(data, rows, 'anCells'));

    var allCells = $([].concat.apply([], cells));
    var row;
    var columns = settings.aoColumns.length;
    var a, i, ien, j, o, host;

    var run = function run(s) {
      var fnSelector = typeof s === 'function';

      if (s === null || s === undefined || fnSelector) {
        // All cells and function selectors
        a = [];

        for (i = 0, ien = rows.length; i < ien; i++) {
          row = rows[i];

          for (j = 0; j < columns; j++) {
            o = {
              row: row,
              column: j
            };

            if (fnSelector) {
              // Selector - function
              host = data[row];

              if (s(o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null)) {
                a.push(o);
              }
            } else {
              // Selector - all
              a.push(o);
            }
          }
        }

        return a;
      } // Selector - index


      if ($.isPlainObject(s)) {
        return [s];
      } // Selector - jQuery filtered cells


      var jqResult = allCells.filter(s).map(function (i, el) {
        return {
          // use a new object, in case someone changes the values
          row: el._DT_CellIndex.row,
          column: el._DT_CellIndex.column
        };
      }).toArray();

      if (jqResult.length || !s.nodeName) {
        return jqResult;
      } // Otherwise the selector is a node, and there is one last option - the
      // element might be a child of an element which has dt-row and dt-column
      // data attributes


      host = $(s).closest('*[data-dt-row]');
      return host.length ? [{
        row: host.data('dt-row'),
        column: host.data('dt-column')
      }] : [];
    };

    return _selector_run('cell', selector, run, settings, opts);
  };

  _api_register('cells()', function (rowSelector, columnSelector, opts) {
    // Argument shifting
    if ($.isPlainObject(rowSelector)) {
      // Indexes
      if (rowSelector.row === undefined) {
        // Selector options in first parameter
        opts = rowSelector;
        rowSelector = null;
      } else {
        // Cell index objects in first parameter
        opts = columnSelector;
        columnSelector = null;
      }
    }

    if ($.isPlainObject(columnSelector)) {
      opts = columnSelector;
      columnSelector = null;
    } // Cell selector


    if (columnSelector === null || columnSelector === undefined) {
      return this.iterator('table', function (settings) {
        return __cell_selector(settings, rowSelector, _selector_opts(opts));
      });
    } // Row + column selector


    var columns = this.columns(columnSelector, opts);
    var rows = this.rows(rowSelector, opts);
    var a, i, ien, j, jen;
    var cells = this.iterator('table', function (settings, idx) {
      a = [];

      for (i = 0, ien = rows[idx].length; i < ien; i++) {
        for (j = 0, jen = columns[idx].length; j < jen; j++) {
          a.push({
            row: rows[idx][i],
            column: columns[idx][j]
          });
        }
      }

      return a;
    }, 1);
    $.extend(cells.selector, {
      cols: columnSelector,
      rows: rowSelector,
      opts: opts
    });
    return cells;
  });

  _api_registerPlural('cells().nodes()', 'cell().node()', function () {
    return this.iterator('cell', function (settings, row, column) {
      var data = settings.aoData[row];
      return data && data.anCells ? data.anCells[column] : undefined;
    }, 1);
  });

  _api_register('cells().data()', function () {
    return this.iterator('cell', function (settings, row, column) {
      return _fnGetCellData(settings, row, column);
    }, 1);
  });

  _api_registerPlural('cells().cache()', 'cell().cache()', function (type) {
    type = type === 'search' ? '_aFilterData' : '_aSortData';
    return this.iterator('cell', function (settings, row, column) {
      return settings.aoData[row][type][column];
    }, 1);
  });

  _api_registerPlural('cells().render()', 'cell().render()', function (type) {
    return this.iterator('cell', function (settings, row, column) {
      return _fnGetCellData(settings, row, column, type);
    }, 1);
  });

  _api_registerPlural('cells().indexes()', 'cell().index()', function () {
    return this.iterator('cell', function (settings, row, column) {
      return {
        row: row,
        column: column,
        columnVisible: _fnColumnIndexToVisible(settings, column)
      };
    }, 1);
  });

  _api_registerPlural('cells().invalidate()', 'cell().invalidate()', function (src) {
    return this.iterator('cell', function (settings, row, column) {
      _fnInvalidate(settings, row, src, column);
    });
  });

  _api_register('cell()', function (rowSelector, columnSelector, opts) {
    return _selector_first(this.cells(rowSelector, columnSelector, opts));
  });

  _api_register('cell().data()', function (data) {
    var ctx = this.context;
    var cell = this[0];

    if (data === undefined) {
      // Get
      return ctx.length && cell.length ? _fnGetCellData(ctx[0], cell[0].row, cell[0].column) : undefined;
    } // Set


    _fnSetCellData(ctx[0], cell[0].row, cell[0].column, data);

    _fnInvalidate(ctx[0], cell[0].row, 'data', cell[0].column);

    return this;
  });
  /**
   * Get current ordering (sorting) that has been applied to the table.
   *
   * @returns {array} 2D array containing the sorting information for the first
   *   table in the current context. Each element in the parent array represents
   *   a column being sorted upon (i.e. multi-sorting with two columns would have
   *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
   *   the column index that the sorting condition applies to, the second is the
   *   direction of the sort (`desc` or `asc`) and, optionally, the third is the
   *   index of the sorting order from the `column.sorting` initialisation array.
   */

  /**
  * Set the ordering for the table.
  *
  * @param {integer} order Column index to sort upon.
  * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
  * @returns {DataTables.Api} this
  */

  /**
  * Set the ordering for the table.
  *
  * @param {array} order 1D array of sorting information to be applied.
  * @param {array} [...] Optional additional sorting conditions
  * @returns {DataTables.Api} this
  */

  /**
  * Set the ordering for the table.
  *
  * @param {array} order 2D array of sorting information to be applied.
  * @returns {DataTables.Api} this
  */


  _api_register('order()', function (order, dir) {
    var ctx = this.context;

    if (order === undefined) {
      // get
      return ctx.length !== 0 ? ctx[0].aaSorting : undefined;
    } // set


    if (typeof order === 'number') {
      // Simple column / direction passed in
      order = [[order, dir]];
    } else if (order.length && !$.isArray(order[0])) {
      // Arguments passed in (list of 1D arrays)
      order = Array.prototype.slice.call(arguments);
    } // otherwise a 2D array was passed in


    return this.iterator('table', function (settings) {
      settings.aaSorting = order.slice();
    });
  });
  /**
   * Attach a sort listener to an element for a given column
   *
   * @param {node|jQuery|string} node Identifier for the element(s) to attach the
   *   listener to. This can take the form of a single DOM node, a jQuery
   *   collection of nodes or a jQuery selector which will identify the node(s).
   * @param {integer} column the column that a click on this node will sort on
   * @param {function} [callback] callback function when sort is run
   * @returns {DataTables.Api} this
   */


  _api_register('order.listener()', function (node, column, callback) {
    return this.iterator('table', function (settings) {
      _fnSortAttachListener(settings, node, column, callback);
    });
  });

  _api_register('order.fixed()', function (set) {
    if (!set) {
      var ctx = this.context;
      var fixed = ctx.length ? ctx[0].aaSortingFixed : undefined;
      return $.isArray(fixed) ? {
        pre: fixed
      } : fixed;
    }

    return this.iterator('table', function (settings) {
      settings.aaSortingFixed = $.extend(true, {}, set);
    });
  }); // Order by the selected column(s)


  _api_register(['columns().order()', 'column().order()'], function (dir) {
    var that = this;
    return this.iterator('table', function (settings, i) {
      var sort = [];
      $.each(that[i], function (j, col) {
        sort.push([col, dir]);
      });
      settings.aaSorting = sort;
    });
  });

  _api_register('search()', function (input, regex, smart, caseInsen) {
    var ctx = this.context;

    if (input === undefined) {
      // get
      return ctx.length !== 0 ? ctx[0].oPreviousSearch.sSearch : undefined;
    } // set


    return this.iterator('table', function (settings) {
      if (!settings.oFeatures.bFilter) {
        return;
      }

      _fnFilterComplete(settings, $.extend({}, settings.oPreviousSearch, {
        "sSearch": input + "",
        "bRegex": regex === null ? false : regex,
        "bSmart": smart === null ? true : smart,
        "bCaseInsensitive": caseInsen === null ? true : caseInsen
      }), 1);
    });
  });

  _api_registerPlural('columns().search()', 'column().search()', function (input, regex, smart, caseInsen) {
    return this.iterator('column', function (settings, column) {
      var preSearch = settings.aoPreSearchCols;

      if (input === undefined) {
        // get
        return preSearch[column].sSearch;
      } // set


      if (!settings.oFeatures.bFilter) {
        return;
      }

      $.extend(preSearch[column], {
        "sSearch": input + "",
        "bRegex": regex === null ? false : regex,
        "bSmart": smart === null ? true : smart,
        "bCaseInsensitive": caseInsen === null ? true : caseInsen
      });

      _fnFilterComplete(settings, settings.oPreviousSearch, 1);
    });
  });
  /*
   * State API methods
   */


  _api_register('state()', function () {
    return this.context.length ? this.context[0].oSavedState : null;
  });

  _api_register('state.clear()', function () {
    return this.iterator('table', function (settings) {
      // Save an empty object
      settings.fnStateSaveCallback.call(settings.oInstance, settings, {});
    });
  });

  _api_register('state.loaded()', function () {
    return this.context.length ? this.context[0].oLoadedState : null;
  });

  _api_register('state.save()', function () {
    return this.iterator('table', function (settings) {
      _fnSaveState(settings);
    });
  });
  /**
   * Provide a common method for plug-ins to check the version of DataTables being
   * used, in order to ensure compatibility.
   *
   *  @param {string} version Version string to check for, in the format "X.Y.Z".
   *    Note that the formats "X" and "X.Y" are also acceptable.
   *  @returns {boolean} true if this version of DataTables is greater or equal to
   *    the required version, or false if this version of DataTales is not
   *    suitable
   *  @static
   *  @dtopt API-Static
   *
   *  @example
   *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );
   */


  DataTable.versionCheck = DataTable.fnVersionCheck = function (version) {
    var aThis = DataTable.version.split('.');
    var aThat = version.split('.');
    var iThis, iThat;

    for (var i = 0, iLen = aThat.length; i < iLen; i++) {
      iThis = parseInt(aThis[i], 10) || 0;
      iThat = parseInt(aThat[i], 10) || 0; // Parts are the same, keep comparing

      if (iThis === iThat) {
        continue;
      } // Parts are different, return immediately


      return iThis > iThat;
    }

    return true;
  };
  /**
   * Check if a `<table>` node is a DataTable table already or not.
   *
   *  @param {node|jquery|string} table Table node, jQuery object or jQuery
   *      selector for the table to test. Note that if more than more than one
   *      table is passed on, only the first will be checked
   *  @returns {boolean} true the table given is a DataTable, or false otherwise
   *  @static
   *  @dtopt API-Static
   *
   *  @example
   *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {
   *      $('#example').dataTable();
   *    }
   */


  DataTable.isDataTable = DataTable.fnIsDataTable = function (table) {
    var t = $(table).get(0);
    var is = false;

    if (table instanceof DataTable.Api) {
      return true;
    }

    $.each(DataTable.settings, function (i, o) {
      var head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;
      var foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;

      if (o.nTable === t || head === t || foot === t) {
        is = true;
      }
    });
    return is;
  };
  /**
   * Get all DataTable tables that have been initialised - optionally you can
   * select to get only currently visible tables.
   *
   *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
   *    or visible tables only.
   *  @returns {array} Array of `table` nodes (not DataTable instances) which are
   *    DataTables
   *  @static
   *  @dtopt API-Static
   *
   *  @example
   *    $.each( $.fn.dataTable.tables(true), function () {
   *      $(table).DataTable().columns.adjust();
   *    } );
   */


  DataTable.tables = DataTable.fnTables = function (visible) {
    var api = false;

    if ($.isPlainObject(visible)) {
      api = visible.api;
      visible = visible.visible;
    }

    var a = $.map(DataTable.settings, function (o) {
      if (!visible || visible && $(o.nTable).is(':visible')) {
        return o.nTable;
      }
    });
    return api ? new _Api2(a) : a;
  };
  /**
   * Convert from camel case parameters to Hungarian notation. This is made public
   * for the extensions to provide the same ability as DataTables core to accept
   * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
   * parameters.
   *
   *  @param {object} src The model object which holds all parameters that can be
   *    mapped.
   *  @param {object} user The object to convert from camel case to Hungarian.
   *  @param {boolean} force When set to `true`, properties which already have a
   *    Hungarian value in the `user` object will be overwritten. Otherwise they
   *    won't be.
   */


  DataTable.camelToHungarian = _fnCamelToHungarian;
  /**
   *
   */

  _api_register('$()', function (selector, opts) {
    var rows = this.rows(opts).nodes(),
        // Get all rows
    jqRows = $(rows);
    return $([].concat(jqRows.filter(selector).toArray(), jqRows.find(selector).toArray()));
  }); // jQuery functions to operate on the tables


  $.each(['on', 'one', 'off'], function (i, key) {
    _api_register(key + '()', function ()
    /* event, handler */
    {
      var args = Array.prototype.slice.call(arguments); // Add the `dt` namespace automatically if it isn't already present

      args[0] = $.map(args[0].split(/\s/), function (e) {
        return !e.match(/\.dt\b/) ? e + '.dt' : e;
      }).join(' ');
      var inst = $(this.tables().nodes());
      inst[key].apply(inst, args);
      return this;
    });
  });

  _api_register('clear()', function () {
    return this.iterator('table', function (settings) {
      _fnClearTable(settings);
    });
  });

  _api_register('settings()', function () {
    return new _Api2(this.context, this.context);
  });

  _api_register('init()', function () {
    var ctx = this.context;
    return ctx.length ? ctx[0].oInit : null;
  });

  _api_register('data()', function () {
    return this.iterator('table', function (settings) {
      return _pluck(settings.aoData, '_aData');
    }).flatten();
  });

  _api_register('destroy()', function (remove) {
    remove = remove || false;
    return this.iterator('table', function (settings) {
      var orig = settings.nTableWrapper.parentNode;
      var classes = settings.oClasses;
      var table = settings.nTable;
      var tbody = settings.nTBody;
      var thead = settings.nTHead;
      var tfoot = settings.nTFoot;
      var jqTable = $(table);
      var jqTbody = $(tbody);
      var jqWrapper = $(settings.nTableWrapper);
      var rows = $.map(settings.aoData, function (r) {
        return r.nTr;
      });
      var i, ien; // Flag to note that the table is currently being destroyed - no action
      // should be taken

      settings.bDestroying = true; // Fire off the destroy callbacks for plug-ins etc

      _fnCallbackFire(settings, "aoDestroyCallback", "destroy", [settings]); // If not being removed from the document, make all columns visible


      if (!remove) {
        new _Api2(settings).columns().visible(true);
      } // Blitz all `DT` namespaced events (these are internal events, the
      // lowercase, `dt` events are user subscribed and they are responsible
      // for removing them


      jqWrapper.off('.DT').find(':not(tbody *)').off('.DT');
      $(window).off('.DT-' + settings.sInstance); // When scrolling we had to break the table up - restore it

      if (table != thead.parentNode) {
        jqTable.children('thead').detach();
        jqTable.append(thead);
      }

      if (tfoot && table != tfoot.parentNode) {
        jqTable.children('tfoot').detach();
        jqTable.append(tfoot);
      }

      settings.aaSorting = [];
      settings.aaSortingFixed = [];

      _fnSortingClasses(settings);

      $(rows).removeClass(settings.asStripeClasses.join(' '));
      $('th, td', thead).removeClass(classes.sSortable + ' ' + classes.sSortableAsc + ' ' + classes.sSortableDesc + ' ' + classes.sSortableNone); // Add the TR elements back into the table in their original order

      jqTbody.children().detach();
      jqTbody.append(rows); // Remove the DataTables generated nodes, events and classes

      var removedMethod = remove ? 'remove' : 'detach';
      jqTable[removedMethod]();
      jqWrapper[removedMethod](); // If we need to reattach the table to the document

      if (!remove && orig) {
        // insertBefore acts like appendChild if !arg[1]
        orig.insertBefore(table, settings.nTableReinsertBefore); // Restore the width of the original table - was read from the style property,
        // so we can restore directly to that

        jqTable.css('width', settings.sDestroyWidth).removeClass(classes.sTable); // If the were originally stripe classes - then we add them back here.
        // Note this is not fool proof (for example if not all rows had stripe
        // classes - but it's a good effort without getting carried away

        ien = settings.asDestroyStripes.length;

        if (ien) {
          jqTbody.children().each(function (i) {
            $(this).addClass(settings.asDestroyStripes[i % ien]);
          });
        }
      }
      /* Remove the settings object from the settings array */


      var idx = $.inArray(settings, DataTable.settings);

      if (idx !== -1) {
        DataTable.settings.splice(idx, 1);
      }
    });
  }); // Add the `every()` method for rows, columns and cells in a compact form


  $.each(['column', 'row', 'cell'], function (i, type) {
    _api_register(type + 's().every()', function (fn) {
      var opts = this.selector.opts;
      var api = this;
      return this.iterator(type, function (settings, arg1, arg2, arg3, arg4) {
        // Rows and columns:
        //  arg1 - index
        //  arg2 - table counter
        //  arg3 - loop counter
        //  arg4 - undefined
        // Cells:
        //  arg1 - row index
        //  arg2 - column index
        //  arg3 - table counter
        //  arg4 - loop counter
        fn.call(api[type](arg1, type === 'cell' ? arg2 : opts, type === 'cell' ? opts : undefined), arg1, arg2, arg3, arg4);
      });
    });
  }); // i18n method for extensions to be able to use the language object from the
  // DataTable

  _api_register('i18n()', function (token, def, plural) {
    var ctx = this.context[0];

    var resolved = _fnGetObjectDataFn(token)(ctx.oLanguage);

    if (resolved === undefined) {
      resolved = def;
    }

    if (plural !== undefined && $.isPlainObject(resolved)) {
      resolved = resolved[plural] !== undefined ? resolved[plural] : resolved._;
    }

    return resolved.replace('%d', plural); // nb: plural might be undefined,
  });
  /**
   * Version string for plug-ins to check compatibility. Allowed format is
   * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
   * only for non-release builds. See http://semver.org/ for more information.
   *  @member
   *  @type string
   *  @default Version number
   */


  DataTable.version = "1.10.16";
  /**
   * Private data store, containing all of the settings objects that are
   * created for the tables on a given page.
   *
   * Note that the `DataTable.settings` object is aliased to
   * `jQuery.fn.dataTableExt` through which it may be accessed and
   * manipulated, or `jQuery.fn.dataTable.settings`.
   *  @member
   *  @type array
   *  @default []
   *  @private
   */

  DataTable.settings = [];
  /**
   * Object models container, for the various models that DataTables has
   * available to it. These models define the objects that are used to hold
   * the active state and configuration of the table.
   *  @namespace
   */

  DataTable.models = {};
  /**
   * Template object for the way in which DataTables holds information about
   * search information for the global filter and individual column filters.
   *  @namespace
   */

  DataTable.models.oSearch = {
    /**
     * Flag to indicate if the filtering should be case insensitive or not
     *  @type boolean
     *  @default true
     */
    "bCaseInsensitive": true,

    /**
     * Applied search term
     *  @type string
     *  @default <i>Empty string</i>
     */
    "sSearch": "",

    /**
     * Flag to indicate if the search term should be interpreted as a
     * regular expression (true) or not (false) and therefore and special
     * regex characters escaped.
     *  @type boolean
     *  @default false
     */
    "bRegex": false,

    /**
     * Flag to indicate if DataTables is to use its smart filtering or not.
     *  @type boolean
     *  @default true
     */
    "bSmart": true
  };
  /**
   * Template object for the way in which DataTables holds information about
   * each individual row. This is the object format used for the settings
   * aoData array.
   *  @namespace
   */

  DataTable.models.oRow = {
    /**
     * TR element for the row
     *  @type node
     *  @default null
     */
    "nTr": null,

    /**
     * Array of TD elements for each row. This is null until the row has been
     * created.
     *  @type array nodes
     *  @default []
     */
    "anCells": null,

    /**
     * Data object from the original data source for the row. This is either
     * an array if using the traditional form of DataTables, or an object if
     * using mData options. The exact type will depend on the passed in
     * data from the data source, or will be an array if using DOM a data
     * source.
     *  @type array|object
     *  @default []
     */
    "_aData": [],

    /**
     * Sorting data cache - this array is ostensibly the same length as the
     * number of columns (although each index is generated only as it is
     * needed), and holds the data that is used for sorting each column in the
     * row. We do this cache generation at the start of the sort in order that
     * the formatting of the sort data need be done only once for each cell
     * per sort. This array should not be read from or written to by anything
     * other than the master sorting methods.
     *  @type array
     *  @default null
     *  @private
     */
    "_aSortData": null,

    /**
     * Per cell filtering data cache. As per the sort data cache, used to
     * increase the performance of the filtering in DataTables
     *  @type array
     *  @default null
     *  @private
     */
    "_aFilterData": null,

    /**
     * Filtering data cache. This is the same as the cell filtering cache, but
     * in this case a string rather than an array. This is easily computed with
     * a join on `_aFilterData`, but is provided as a cache so the join isn't
     * needed on every search (memory traded for performance)
     *  @type array
     *  @default null
     *  @private
     */
    "_sFilterRow": null,

    /**
     * Cache of the class name that DataTables has applied to the row, so we
     * can quickly look at this variable rather than needing to do a DOM check
     * on className for the nTr property.
     *  @type string
     *  @default <i>Empty string</i>
     *  @private
     */
    "_sRowStripe": "",

    /**
     * Denote if the original data source was from the DOM, or the data source
     * object. This is used for invalidating data, so DataTables can
     * automatically read data from the original source, unless uninstructed
     * otherwise.
     *  @type string
     *  @default null
     *  @private
     */
    "src": null,

    /**
     * Index in the aoData array. This saves an indexOf lookup when we have the
     * object, but want to know the index
     *  @type integer
     *  @default -1
     *  @private
     */
    "idx": -1
  };
  /**
   * Template object for the column information object in DataTables. This object
   * is held in the settings aoColumns array and contains all the information that
   * DataTables needs about each individual column.
   *
   * Note that this object is related to {@link DataTable.defaults.column}
   * but this one is the internal data store for DataTables's cache of columns.
   * It should NOT be manipulated outside of DataTables. Any configuration should
   * be done through the initialisation options.
   *  @namespace
   */

  DataTable.models.oColumn = {
    /**
     * Column index. This could be worked out on-the-fly with $.inArray, but it
     * is faster to just hold it as a variable
     *  @type integer
     *  @default null
     */
    "idx": null,

    /**
     * A list of the columns that sorting should occur on when this column
     * is sorted. That this property is an array allows multi-column sorting
     * to be defined for a column (for example first name / last name columns
     * would benefit from this). The values are integers pointing to the
     * columns to be sorted on (typically it will be a single integer pointing
     * at itself, but that doesn't need to be the case).
     *  @type array
     */
    "aDataSort": null,

    /**
     * Define the sorting directions that are applied to the column, in sequence
     * as the column is repeatedly sorted upon - i.e. the first value is used
     * as the sorting direction when the column if first sorted (clicked on).
     * Sort it again (click again) and it will move on to the next index.
     * Repeat until loop.
     *  @type array
     */
    "asSorting": null,

    /**
     * Flag to indicate if the column is searchable, and thus should be included
     * in the filtering or not.
     *  @type boolean
     */
    "bSearchable": null,

    /**
     * Flag to indicate if the column is sortable or not.
     *  @type boolean
     */
    "bSortable": null,

    /**
     * Flag to indicate if the column is currently visible in the table or not
     *  @type boolean
     */
    "bVisible": null,

    /**
     * Store for manual type assignment using the `column.type` option. This
     * is held in store so we can manipulate the column's `sType` property.
     *  @type string
     *  @default null
     *  @private
     */
    "_sManualType": null,

    /**
     * Flag to indicate if HTML5 data attributes should be used as the data
     * source for filtering or sorting. True is either are.
     *  @type boolean
     *  @default false
     *  @private
     */
    "_bAttrSrc": false,

    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     *  @type function
     *  @param {element} nTd The TD node that has been created
     *  @param {*} sData The Data for the cell
     *  @param {array|object} oData The data for the whole row
     *  @param {int} iRow The row index for the aoData data store
     *  @default null
     */
    "fnCreatedCell": null,

    /**
     * Function to get data from a cell in a column. You should <b>never</b>
     * access data directly through _aData internally in DataTables - always use
     * the method attached to this property. It allows mData to function as
     * required. This function is automatically assigned by the column
     * initialisation method
     *  @type function
     *  @param {array|object} oData The data array/object for the array
     *    (i.e. aoData[]._aData)
     *  @param {string} sSpecific The specific data type you want to get -
     *    'display', 'type' 'filter' 'sort'
     *  @returns {*} The data for the cell from the given row's data
     *  @default null
     */
    "fnGetData": null,

    /**
     * Function to set data for a cell in the column. You should <b>never</b>
     * set the data directly to _aData internally in DataTables - always use
     * this method. It allows mData to function as required. This function
     * is automatically assigned by the column initialisation method
     *  @type function
     *  @param {array|object} oData The data array/object for the array
     *    (i.e. aoData[]._aData)
     *  @param {*} sValue Value to set
     *  @default null
     */
    "fnSetData": null,

    /**
     * Property to read the value for the cells in the column from the data
     * source array / object. If null, then the default content is used, if a
     * function is given then the return from the function is used.
     *  @type function|int|string|null
     *  @default null
     */
    "mData": null,

    /**
     * Partner property to mData which is used (only when defined) to get
     * the data - i.e. it is basically the same as mData, but without the
     * 'set' option, and also the data fed to it is the result from mData.
     * This is the rendering method to match the data method of mData.
     *  @type function|int|string|null
     *  @default null
     */
    "mRender": null,

    /**
     * Unique header TH/TD element for this column - this is what the sorting
     * listener is attached to (if sorting is enabled.)
     *  @type node
     *  @default null
     */
    "nTh": null,

    /**
     * Unique footer TH/TD element for this column (if there is one). Not used
     * in DataTables as such, but can be used for plug-ins to reference the
     * footer for each column.
     *  @type node
     *  @default null
     */
    "nTf": null,

    /**
     * The class to apply to all TD elements in the table's TBODY for the column
     *  @type string
     *  @default null
     */
    "sClass": null,

    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     *  @type string
     */
    "sContentPadding": null,

    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because mData
     * is set to null, or because the data source itself is null).
     *  @type string
     *  @default null
     */
    "sDefaultContent": null,

    /**
     * Name for the column, allowing reference to the column by name as well as
     * by index (needs a lookup to work by name).
     *  @type string
     */
    "sName": null,

    /**
     * Custom sorting data type - defines which of the available plug-ins in
     * afnSortData the custom sorting will use - if any is defined.
     *  @type string
     *  @default std
     */
    "sSortDataType": 'std',

    /**
     * Class to be applied to the header element when sorting on this column
     *  @type string
     *  @default null
     */
    "sSortingClass": null,

    /**
     * Class to be applied to the header element when sorting on this column -
     * when jQuery UI theming is used.
     *  @type string
     *  @default null
     */
    "sSortingClassJUI": null,

    /**
     * Title of the column - what is seen in the TH element (nTh).
     *  @type string
     */
    "sTitle": null,

    /**
     * Column sorting and filtering type
     *  @type string
     *  @default null
     */
    "sType": null,

    /**
     * Width of the column
     *  @type string
     *  @default null
     */
    "sWidth": null,

    /**
     * Width of the column when it was first "encountered"
     *  @type string
     *  @default null
     */
    "sWidthOrig": null
  };
  /*
   * Developer note: The properties of the object below are given in Hungarian
   * notation, that was used as the interface for DataTables prior to v1.10, however
   * from v1.10 onwards the primary interface is camel case. In order to avoid
   * breaking backwards compatibility utterly with this change, the Hungarian
   * version is still, internally the primary interface, but is is not documented
   * - hence the @name tags in each doc comment. This allows a Javascript function
   * to create a map from Hungarian notation to camel case (going the other direction
   * would require each property to be listed, which would at around 3K to the size
   * of DataTables, while this method is about a 0.5K hit.
   *
   * Ultimately this does pave the way for Hungarian notation to be dropped
   * completely, but that is a massive amount of work and will break current
   * installs (therefore is on-hold until v2).
   */

  /**
   * Initialisation options that can be given to DataTables at initialisation
   * time.
   *  @namespace
   */

  DataTable.defaults = {
    /**
     * An array of data to use for the table, passed in at initialisation which
     * will be used in preference to any data which is already in the DOM. This is
     * particularly useful for constructing tables purely in Javascript, for
     * example with a custom Ajax call.
     *  @type array
     *  @default null
     *
     *  @dtopt Option
     *  @name DataTable.defaults.data
     *
     *  @example
     *    // Using a 2D array data source
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "data": [
     *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
     *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
     *        ],
     *        "columns": [
     *          { "title": "Engine" },
     *          { "title": "Browser" },
     *          { "title": "Platform" },
     *          { "title": "Version" },
     *          { "title": "Grade" }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using an array of objects as a data source (`data`)
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "data": [
     *          {
     *            "engine":   "Trident",
     *            "browser":  "Internet Explorer 4.0",
     *            "platform": "Win 95+",
     *            "version":  4,
     *            "grade":    "X"
     *          },
     *          {
     *            "engine":   "Trident",
     *            "browser":  "Internet Explorer 5.0",
     *            "platform": "Win 95+",
     *            "version":  5,
     *            "grade":    "C"
     *          }
     *        ],
     *        "columns": [
     *          { "title": "Engine",   "data": "engine" },
     *          { "title": "Browser",  "data": "browser" },
     *          { "title": "Platform", "data": "platform" },
     *          { "title": "Version",  "data": "version" },
     *          { "title": "Grade",    "data": "grade" }
     *        ]
     *      } );
     *    } );
     */
    "aaData": null,

    /**
     * If ordering is enabled, then DataTables will perform a first pass sort on
     * initialisation. You can define which column(s) the sort is performed
     * upon, and the sorting direction, with this variable. The `sorting` array
     * should contain an array for each column to be sorted initially containing
     * the column's index and a direction string ('asc' or 'desc').
     *  @type array
     *  @default [[0,'asc']]
     *
     *  @dtopt Option
     *  @name DataTable.defaults.order
     *
     *  @example
     *    // Sort by 3rd column first, and then 4th column
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "order": [[2,'asc'], [3,'desc']]
     *      } );
     *    } );
     *
     *    // No initial sorting
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "order": []
     *      } );
     *    } );
     */
    "aaSorting": [[0, 'asc']],

    /**
     * This parameter is basically identical to the `sorting` parameter, but
     * cannot be overridden by user interaction with the table. What this means
     * is that you could have a column (visible or hidden) which the sorting
     * will always be forced on first - any sorting after that (from the user)
     * will then be performed as required. This can be useful for grouping rows
     * together.
     *  @type array
     *  @default null
     *
     *  @dtopt Option
     *  @name DataTable.defaults.orderFixed
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "orderFixed": [[0,'asc']]
     *      } );
     *    } )
     */
    "aaSortingFixed": [],

    /**
     * DataTables can be instructed to load data to display in the table from a
     * Ajax source. This option defines how that Ajax call is made and where to.
     *
     * The `ajax` property has three different modes of operation, depending on
     * how it is defined. These are:
     *
     * * `string` - Set the URL from where the data should be loaded from.
     * * `object` - Define properties for `jQuery.ajax`.
     * * `function` - Custom data get function
     *
     * `string`
     * --------
     *
     * As a string, the `ajax` property simply defines the URL from which
     * DataTables will load data.
     *
     * `object`
     * --------
     *
     * As an object, the parameters in the object are passed to
     * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control
     * of the Ajax request. DataTables has a number of default parameters which
     * you can override using this option. Please refer to the jQuery
     * documentation for a full description of the options available, although
     * the following parameters provide additional options in DataTables or
     * require special consideration:
     *
     * * `data` - As with jQuery, `data` can be provided as an object, but it
     *   can also be used as a function to manipulate the data DataTables sends
     *   to the server. The function takes a single parameter, an object of
     *   parameters with the values that DataTables has readied for sending. An
     *   object may be returned which will be merged into the DataTables
     *   defaults, or you can add the items to the object that was passed in and
     *   not return anything from the function. This supersedes `fnServerParams`
     *   from DataTables 1.9-.
     *
     * * `dataSrc` - By default DataTables will look for the property `data` (or
     *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
     *   from an Ajax source or for server-side processing - this parameter
     *   allows that property to be changed. You can use Javascript dotted
     *   object notation to get a data source for multiple levels of nesting, or
     *   it my be used as a function. As a function it takes a single parameter,
     *   the JSON returned from the server, which can be manipulated as
     *   required, with the returned value being that used by DataTables as the
     *   data source for the table. This supersedes `sAjaxDataProp` from
     *   DataTables 1.9-.
     *
     * * `success` - Should not be overridden it is used internally in
     *   DataTables. To manipulate / transform the data returned by the server
     *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
     *
     * `function`
     * ----------
     *
     * As a function, making the Ajax call is left up to yourself allowing
     * complete control of the Ajax request. Indeed, if desired, a method other
     * than Ajax could be used to obtain the required data, such as Web storage
     * or an AIR database.
     *
     * The function is given four parameters and no return is required. The
     * parameters are:
     *
     * 1. _object_ - Data to send to the server
     * 2. _function_ - Callback function that must be executed when the required
     *    data has been obtained. That data should be passed into the callback
     *    as the only parameter
     * 3. _object_ - DataTables settings object for the table
     *
     * Note that this supersedes `fnServerData` from DataTables 1.9-.
     *
     *  @type string|object|function
     *  @default null
     *
     *  @dtopt Option
     *  @name DataTable.defaults.ajax
     *  @since 1.10.0
     *
     * @example
     *   // Get JSON data from a file via Ajax.
     *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).
     *   $('#example').dataTable( {
     *     "ajax": "data.json"
     *   } );
     *
     * @example
     *   // Get JSON data from a file via Ajax, using `dataSrc` to change
     *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "dataSrc": "tableData"
     *     }
     *   } );
     *
     * @example
     *   // Get JSON data from a file via Ajax, using `dataSrc` to read data
     *   // from a plain array rather than an array in an object
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "dataSrc": ""
     *     }
     *   } );
     *
     * @example
     *   // Manipulate the data returned from the server - add a link to data
     *   // (note this can, should, be done using `render` for the column - this
     *   // is just a simple example of how the data can be manipulated).
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "dataSrc": function ( json ) {
     *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {
     *           json[i][0] = '<a href="/message/'+json[i][0]+'>View message</a>';
     *         }
     *         return json;
     *       }
     *     }
     *   } );
     *
     * @example
     *   // Add data to the request
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "data": function ( d ) {
     *         return {
     *           "extra_search": $('#extra').val()
     *         };
     *       }
     *     }
     *   } );
     *
     * @example
     *   // Send request as POST
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "type": "POST"
     *     }
     *   } );
     *
     * @example
     *   // Get the data from localStorage (could interface with a form for
     *   // adding, editing and removing rows).
     *   $('#example').dataTable( {
     *     "ajax": function (data, callback, settings) {
     *       callback(
     *         JSON.parse( localStorage.getItem('dataTablesData') )
     *       );
     *     }
     *   } );
     */
    "ajax": null,

    /**
     * This parameter allows you to readily specify the entries in the length drop
     * down menu that DataTables shows when pagination is enabled. It can be
     * either a 1D array of options which will be used for both the displayed
     * option and the value, or a 2D array which will use the array in the first
     * position as the value, and the array in the second position as the
     * displayed options (useful for language strings such as 'All').
     *
     * Note that the `pageLength` property will be automatically set to the
     * first value given in this array, unless `pageLength` is also provided.
     *  @type array
     *  @default [ 10, 25, 50, 100 ]
     *
     *  @dtopt Option
     *  @name DataTable.defaults.lengthMenu
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
     *      } );
     *    } );
     */
    "aLengthMenu": [10, 25, 50, 100],

    /**
     * The `columns` option in the initialisation parameter allows you to define
     * details about the way individual columns behave. For a full list of
     * column options that can be set, please see
     * {@link DataTable.defaults.column}. Note that if you use `columns` to
     * define your columns, you must have an entry in the array for every single
     * column that you have in your table (these can be null if you don't which
     * to specify any options).
     *  @member
     *
     *  @name DataTable.defaults.column
     */
    "aoColumns": null,

    /**
     * Very similar to `columns`, `columnDefs` allows you to target a specific
     * column, multiple columns, or all columns, using the `targets` property of
     * each object in the array. This allows great flexibility when creating
     * tables, as the `columnDefs` arrays can be of any length, targeting the
     * columns you specifically want. `columnDefs` may use any of the column
     * options available: {@link DataTable.defaults.column}, but it _must_
     * have `targets` defined in each object in the array. Values in the `targets`
     * array may be:
     *   <ul>
     *     <li>a string - class name will be matched on the TH for the column</li>
     *     <li>0 or a positive integer - column index counting from the left</li>
     *     <li>a negative integer - column index counting from the right</li>
     *     <li>the string "_all" - all columns (i.e. assign a default)</li>
     *   </ul>
     *  @member
     *
     *  @name DataTable.defaults.columnDefs
     */
    "aoColumnDefs": null,

    /**
     * Basically the same as `search`, this parameter defines the individual column
     * filtering state at initialisation time. The array must be of the same size
     * as the number of columns, and each element be an object with the parameters
     * `search` and `escapeRegex` (the latter is optional). 'null' is also
     * accepted and the default will be used.
     *  @type array
     *  @default []
     *
     *  @dtopt Option
     *  @name DataTable.defaults.searchCols
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "searchCols": [
     *          null,
     *          { "search": "My filter" },
     *          null,
     *          { "search": "^[0-9]", "escapeRegex": false }
     *        ]
     *      } );
     *    } )
     */
    "aoSearchCols": [],

    /**
     * An array of CSS classes that should be applied to displayed rows. This
     * array may be of any length, and DataTables will apply each class
     * sequentially, looping when required.
     *  @type array
     *  @default null <i>Will take the values determined by the `oClasses.stripe*`
     *    options</i>
     *
     *  @dtopt Option
     *  @name DataTable.defaults.stripeClasses
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stripeClasses": [ 'strip1', 'strip2', 'strip3' ]
     *      } );
     *    } )
     */
    "asStripeClasses": null,

    /**
     * Enable or disable automatic column width calculation. This can be disabled
     * as an optimisation (it takes some time to calculate the widths) if the
     * tables widths are passed in using `columns`.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.autoWidth
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "autoWidth": false
     *      } );
     *    } );
     */
    "bAutoWidth": true,

    /**
     * Deferred rendering can provide DataTables with a huge speed boost when you
     * are using an Ajax or JS data source for the table. This option, when set to
     * true, will cause DataTables to defer the creation of the table elements for
     * each row until they are needed for a draw - saving a significant amount of
     * time.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @name DataTable.defaults.deferRender
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajax": "sources/arrays.txt",
     *        "deferRender": true
     *      } );
     *    } );
     */
    "bDeferRender": false,

    /**
     * Replace a DataTable which matches the given selector and replace it with
     * one which has the properties of the new initialisation object passed. If no
     * table matches the selector, then the new DataTable will be constructed as
     * per normal.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.destroy
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "srollY": "200px",
     *        "paginate": false
     *      } );
     *
     *      // Some time later....
     *      $('#example').dataTable( {
     *        "filter": false,
     *        "destroy": true
     *      } );
     *    } );
     */
    "bDestroy": false,

    /**
     * Enable or disable filtering of data. Filtering in DataTables is "smart" in
     * that it allows the end user to input multiple words (space separated) and
     * will match a row containing those words, even if not in the order that was
     * specified (this allow matching across multiple columns). Note that if you
     * wish to use filtering in DataTables this must remain 'true' - to remove the
     * default filtering input box and retain filtering abilities, please use
     * {@link DataTable.defaults.dom}.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.searching
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "searching": false
     *      } );
     *    } );
     */
    "bFilter": true,

    /**
     * Enable or disable the table information display. This shows information
     * about the data that is currently visible on the page, including information
     * about filtered data if that action is being performed.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.info
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "info": false
     *      } );
     *    } );
     */
    "bInfo": true,

    /**
     * Allows the end user to select the size of a formatted page from a select
     * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.lengthChange
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "lengthChange": false
     *      } );
     *    } );
     */
    "bLengthChange": true,

    /**
     * Enable or disable pagination.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.paging
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "paging": false
     *      } );
     *    } );
     */
    "bPaginate": true,

    /**
     * Enable or disable the display of a 'processing' indicator when the table is
     * being processed (e.g. a sort). This is particularly useful for tables with
     * large amounts of data where it can take a noticeable amount of time to sort
     * the entries.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @name DataTable.defaults.processing
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "processing": true
     *      } );
     *    } );
     */
    "bProcessing": false,

    /**
     * Retrieve the DataTables object for the given selector. Note that if the
     * table has already been initialised, this parameter will cause DataTables
     * to simply return the object that has already been set up - it will not take
     * account of any changes you might have made to the initialisation object
     * passed to DataTables (setting this parameter to true is an acknowledgement
     * that you understand this). `destroy` can be used to reinitialise a table if
     * you need.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.retrieve
     *
     *  @example
     *    $(document).ready( function() {
     *      initTable();
     *      tableActions();
     *    } );
     *
     *    function initTable ()
     *    {
     *      return $('#example').dataTable( {
     *        "scrollY": "200px",
     *        "paginate": false,
     *        "retrieve": true
     *      } );
     *    }
     *
     *    function tableActions ()
     *    {
     *      var table = initTable();
     *      // perform API operations with oTable
     *    }
     */
    "bRetrieve": false,

    /**
     * When vertical (y) scrolling is enabled, DataTables will force the height of
     * the table's viewport to the given height at all times (useful for layout).
     * However, this can look odd when filtering data down to a small data set,
     * and the footer is left "floating" further down. This parameter (when
     * enabled) will cause DataTables to collapse the table's viewport down when
     * the result set will fit within the given Y height.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.scrollCollapse
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollY": "200",
     *        "scrollCollapse": true
     *      } );
     *    } );
     */
    "bScrollCollapse": false,

    /**
     * Configure DataTables to use server-side processing. Note that the
     * `ajax` parameter must also be given in order to give DataTables a
     * source to obtain the required data for each draw.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverSide
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "serverSide": true,
     *        "ajax": "xhr.php"
     *      } );
     *    } );
     */
    "bServerSide": false,

    /**
     * Enable or disable sorting of columns. Sorting of individual columns can be
     * disabled by the `sortable` option for each column.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.ordering
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "ordering": false
     *      } );
     *    } );
     */
    "bSort": true,

    /**
     * Enable or display DataTables' ability to sort multiple columns at the
     * same time (activated by shift-click by the user).
     *  @type boolean
     *  @default true
     *
     *  @dtopt Options
     *  @name DataTable.defaults.orderMulti
     *
     *  @example
     *    // Disable multiple column sorting ability
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "orderMulti": false
     *      } );
     *    } );
     */
    "bSortMulti": true,

    /**
     * Allows control over whether DataTables should use the top (true) unique
     * cell that is found for a single column, or the bottom (false - default).
     * This is useful when using complex headers.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.orderCellsTop
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "orderCellsTop": true
     *      } );
     *    } );
     */
    "bSortCellsTop": false,

    /**
     * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
     * `sorting\_3` to the columns which are currently being sorted on. This is
     * presented as a feature switch as it can increase processing time (while
     * classes are removed and added) so for large data sets you might want to
     * turn this off.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.orderClasses
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "orderClasses": false
     *      } );
     *    } );
     */
    "bSortClasses": true,

    /**
     * Enable or disable state saving. When enabled HTML5 `localStorage` will be
     * used to save table display information such as pagination information,
     * display length, filtering and sorting. As such when the end user reloads
     * the page the display display will match what thy had previously set up.
     *
     * Due to the use of `localStorage` the default state saving is not supported
     * in IE6 or 7. If state saving is required in those browsers, use
     * `stateSaveCallback` to provide a storage solution such as cookies.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @name DataTable.defaults.stateSave
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "stateSave": true
     *      } );
     *    } );
     */
    "bStateSave": false,

    /**
     * This function is called when a TR element is created (and all TD child
     * elements have been inserted), or registered if using a DOM source, allowing
     * manipulation of the TR element (adding classes etc).
     *  @type function
     *  @param {node} row "TR" element for the current row
     *  @param {array} data Raw data array for this row
     *  @param {int} dataIndex The index of this row in the internal aoData array
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.createdRow
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "createdRow": function( row, data, dataIndex ) {
     *          // Bold the grade for all 'A' grade browsers
     *          if ( data[4] == "A" )
     *          {
     *            $('td:eq(4)', row).html( '<b>A</b>' );
     *          }
     *        }
     *      } );
     *    } );
     */
    "fnCreatedRow": null,

    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify any aspect you want about the created DOM.
     *  @type function
     *  @param {object} settings DataTables settings object
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.drawCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "drawCallback": function( settings ) {
     *          alert( 'DataTables has redrawn the table' );
     *        }
     *      } );
     *    } );
     */
    "fnDrawCallback": null,

    /**
     * Identical to fnHeaderCallback() but for the table footer this function
     * allows you to modify the table footer on every 'draw' event.
     *  @type function
     *  @param {node} foot "TR" element for the footer
     *  @param {array} data Full table data (as derived from the original HTML)
     *  @param {int} start Index for the current display starting point in the
     *    display array
     *  @param {int} end Index for the current display ending point in the
     *    display array
     *  @param {array int} display Index array to translate the visual position
     *    to the full data array
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.footerCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "footerCallback": function( tfoot, data, start, end, display ) {
     *          tfoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+start;
     *        }
     *      } );
     *    } )
     */
    "fnFooterCallback": null,

    /**
     * When rendering large numbers in the information element for the table
     * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
     * to have a comma separator for the 'thousands' units (e.g. 1 million is
     * rendered as "1,000,000") to help readability for the end user. This
     * function will override the default method DataTables uses.
     *  @type function
     *  @member
     *  @param {int} toFormat number to be formatted
     *  @returns {string} formatted string for DataTables to show the number
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.formatNumber
     *
     *  @example
     *    // Format a number using a single quote for the separator (note that
     *    // this can also be done with the language.thousands option)
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "formatNumber": function ( toFormat ) {
     *          return toFormat.toString().replace(
     *            /\B(?=(\d{3})+(?!\d))/g, "'"
     *          );
     *        };
     *      } );
     *    } );
     */
    "fnFormatNumber": function fnFormatNumber(toFormat) {
      return toFormat.toString().replace(/\B(?=(\d{3})+(?!\d))/g, this.oLanguage.sThousands);
    },

    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify the header row. This can be used to calculate and
     * display useful information about the table.
     *  @type function
     *  @param {node} head "TR" element for the header
     *  @param {array} data Full table data (as derived from the original HTML)
     *  @param {int} start Index for the current display starting point in the
     *    display array
     *  @param {int} end Index for the current display ending point in the
     *    display array
     *  @param {array int} display Index array to translate the visual position
     *    to the full data array
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.headerCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "fheaderCallback": function( head, data, start, end, display ) {
     *          head.getElementsByTagName('th')[0].innerHTML = "Displaying "+(end-start)+" records";
     *        }
     *      } );
     *    } )
     */
    "fnHeaderCallback": null,

    /**
     * The information element can be used to convey information about the current
     * state of the table. Although the internationalisation options presented by
     * DataTables are quite capable of dealing with most customisations, there may
     * be times where you wish to customise the string further. This callback
     * allows you to do exactly that.
     *  @type function
     *  @param {object} oSettings DataTables settings object
     *  @param {int} start Starting position in data for the draw
     *  @param {int} end End position in data for the draw
     *  @param {int} max Total number of rows in the table (regardless of
     *    filtering)
     *  @param {int} total Total number of rows in the data set, after filtering
     *  @param {string} pre The string that DataTables has formatted using it's
     *    own rules
     *  @returns {string} The string to be displayed in the information element.
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.infoCallback
     *
     *  @example
     *    $('#example').dataTable( {
     *      "infoCallback": function( settings, start, end, max, total, pre ) {
     *        return start +" to "+ end;
     *      }
     *    } );
     */
    "fnInfoCallback": null,

    /**
     * Called when the table has been initialised. Normally DataTables will
     * initialise sequentially and there will be no need for this function,
     * however, this does not hold true when using external language information
     * since that is obtained using an async XHR call.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} json The JSON object request from the server - only
     *    present if client-side Ajax sourced data is used
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.initComplete
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "initComplete": function(settings, json) {
     *          alert( 'DataTables has finished its initialisation.' );
     *        }
     *      } );
     *    } )
     */
    "fnInitComplete": null,

    /**
     * Called at the very start of each table draw and can be used to cancel the
     * draw by returning false, any other return (including undefined) results in
     * the full draw occurring).
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @returns {boolean} False will cancel the draw, anything else (including no
     *    return) will allow it to complete.
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.preDrawCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "preDrawCallback": function( settings ) {
     *          if ( $('#test').val() == 1 ) {
     *            return false;
     *          }
     *        }
     *      } );
     *    } );
     */
    "fnPreDrawCallback": null,

    /**
     * This function allows you to 'post process' each row after it have been
     * generated for each table draw, but before it is rendered on screen. This
     * function might be used for setting the row class name etc.
     *  @type function
     *  @param {node} row "TR" element for the current row
     *  @param {array} data Raw data array for this row
     *  @param {int} displayIndex The display index for the current table draw
     *  @param {int} displayIndexFull The index of the data in the full list of
     *    rows (after filtering)
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.rowCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "rowCallback": function( row, data, displayIndex, displayIndexFull ) {
     *          // Bold the grade for all 'A' grade browsers
     *          if ( data[4] == "A" ) {
     *            $('td:eq(4)', row).html( '<b>A</b>' );
     *          }
     *        }
     *      } );
     *    } );
     */
    "fnRowCallback": null,

    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * This parameter allows you to override the default function which obtains
     * the data from the server so something more suitable for your application.
     * For example you could use POST data, or pull information from a Gears or
     * AIR database.
     *  @type function
     *  @member
     *  @param {string} source HTTP source to obtain the data from (`ajax`)
     *  @param {array} data A key/value pair object containing the data to send
     *    to the server
     *  @param {function} callback to be called on completion of the data get
     *    process that will draw the data on the page.
     *  @param {object} settings DataTables settings object
     *
     *  @dtopt Callbacks
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverData
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "fnServerData": null,

    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     *  It is often useful to send extra data to the server when making an Ajax
     * request - for example custom filtering information, and this callback
     * function makes it trivial to send extra information to the server. The
     * passed in parameter is the data set that has been constructed by
     * DataTables, and you can add to this or modify it as you require.
     *  @type function
     *  @param {array} data Data array (array of objects which are name/value
     *    pairs) that has been constructed by DataTables and will be sent to the
     *    server. In the case of Ajax sourced data with server-side processing
     *    this will be an empty array, for server-side processing there will be a
     *    significant number of parameters!
     *  @returns {undefined} Ensure that you modify the data array passed in,
     *    as this is passed by reference.
     *
     *  @dtopt Callbacks
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverParams
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "fnServerParams": null,

    /**
     * Load the table state. With this function you can define from where, and how, the
     * state of a table is loaded. By default DataTables will load from `localStorage`
     * but you might wish to use a server-side database or cookies.
     *  @type function
     *  @member
     *  @param {object} settings DataTables settings object
     *  @param {object} callback Callback that can be executed when done. It
     *    should be passed the loaded state object.
     *  @return {object} The DataTables state object to be loaded
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateLoadCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoadCallback": function (settings, callback) {
     *          $.ajax( {
     *            "url": "/state_load",
     *            "dataType": "json",
     *            "success": function (json) {
     *              callback( json );
     *            }
     *          } );
     *        }
     *      } );
     *    } );
     */
    "fnStateLoadCallback": function fnStateLoadCallback(settings) {
      try {
        return JSON.parse((settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem('DataTables_' + settings.sInstance + '_' + location.pathname));
      } catch (e) {}
    },

    /**
     * Callback which allows modification of the saved state prior to loading that state.
     * This callback is called when the table is loading state from the stored data, but
     * prior to the settings object being modified by the saved state. Note that for
     * plug-in authors, you should use the `stateLoadParams` event to load parameters for
     * a plug-in.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object that is to be loaded
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateLoadParams
     *
     *  @example
     *    // Remove a saved filter, so filtering is never loaded
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoadParams": function (settings, data) {
     *          data.oSearch.sSearch = "";
     *        }
     *      } );
     *    } );
     *
     *  @example
     *    // Disallow state loading by returning false
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoadParams": function (settings, data) {
     *          return false;
     *        }
     *      } );
     *    } );
     */
    "fnStateLoadParams": null,

    /**
     * Callback that is called when the state has been loaded from the state saving method
     * and the DataTables settings object has been modified as a result of the loaded state.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object that was loaded
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateLoaded
     *
     *  @example
     *    // Show an alert with the filtering value that was saved
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoaded": function (settings, data) {
     *          alert( 'Saved filter was: '+data.oSearch.sSearch );
     *        }
     *      } );
     *    } );
     */
    "fnStateLoaded": null,

    /**
     * Save the table state. This function allows you to define where and how the state
     * information for the table is stored By default DataTables will use `localStorage`
     * but you might wish to use a server-side database or cookies.
     *  @type function
     *  @member
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object to be saved
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateSaveCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateSaveCallback": function (settings, data) {
     *          // Send an Ajax request to the server with the state object
     *          $.ajax( {
     *            "url": "/state_save",
     *            "data": data,
     *            "dataType": "json",
     *            "method": "POST"
     *            "success": function () {}
     *          } );
     *        }
     *      } );
     *    } );
     */
    "fnStateSaveCallback": function fnStateSaveCallback(settings, data) {
      try {
        (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem('DataTables_' + settings.sInstance + '_' + location.pathname, JSON.stringify(data));
      } catch (e) {}
    },

    /**
     * Callback which allows modification of the state to be saved. Called when the table
     * has changed state a new state save is required. This method allows modification of
     * the state saving object prior to actually doing the save, including addition or
     * other state properties or modification. Note that for plug-in authors, you should
     * use the `stateSaveParams` event to save parameters for a plug-in.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object to be saved
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateSaveParams
     *
     *  @example
     *    // Remove a saved filter, so filtering is never saved
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateSaveParams": function (settings, data) {
     *          data.oSearch.sSearch = "";
     *        }
     *      } );
     *    } );
     */
    "fnStateSaveParams": null,

    /**
     * Duration for which the saved state information is considered valid. After this period
     * has elapsed the state will be returned to the default.
     * Value is given in seconds.
     *  @type int
     *  @default 7200 <i>(2 hours)</i>
     *
     *  @dtopt Options
     *  @name DataTable.defaults.stateDuration
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateDuration": 60*60*24; // 1 day
     *      } );
     *    } )
     */
    "iStateDuration": 7200,

    /**
     * When enabled DataTables will not make a request to the server for the first
     * page draw - rather it will use the data already on the page (no sorting etc
     * will be applied to it), thus saving on an XHR at load time. `deferLoading`
     * is used to indicate that deferred loading is required, but it is also used
     * to tell DataTables how many records there are in the full table (allowing
     * the information element and pagination to be displayed correctly). In the case
     * where a filtering is applied to the table on initial load, this can be
     * indicated by giving the parameter as an array, where the first element is
     * the number of records available after filtering and the second element is the
     * number of records without filtering (allowing the table information element
     * to be shown correctly).
     *  @type int | array
     *  @default null
     *
     *  @dtopt Options
     *  @name DataTable.defaults.deferLoading
     *
     *  @example
     *    // 57 records available in the table, no filtering applied
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "serverSide": true,
     *        "ajax": "scripts/server_processing.php",
     *        "deferLoading": 57
     *      } );
     *    } );
     *
     *  @example
     *    // 57 records after filtering, 100 without filtering (an initial filter applied)
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "serverSide": true,
     *        "ajax": "scripts/server_processing.php",
     *        "deferLoading": [ 57, 100 ],
     *        "search": {
     *          "search": "my_filter"
     *        }
     *      } );
     *    } );
     */
    "iDeferLoading": null,

    /**
     * Number of rows to display on a single page when using pagination. If
     * feature enabled (`lengthChange`) then the end user will be able to override
     * this to a custom setting using a pop-up menu.
     *  @type int
     *  @default 10
     *
     *  @dtopt Options
     *  @name DataTable.defaults.pageLength
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "pageLength": 50
     *      } );
     *    } )
     */
    "iDisplayLength": 10,

    /**
     * Define the starting point for data display when using DataTables with
     * pagination. Note that this parameter is the number of records, rather than
     * the page number, so if you have 10 records per page and want to start on
     * the third page, it should be "20".
     *  @type int
     *  @default 0
     *
     *  @dtopt Options
     *  @name DataTable.defaults.displayStart
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "displayStart": 20
     *      } );
     *    } )
     */
    "iDisplayStart": 0,

    /**
     * By default DataTables allows keyboard navigation of the table (sorting, paging,
     * and filtering) by adding a `tabindex` attribute to the required elements. This
     * allows you to tab through the controls and press the enter key to activate them.
     * The tabindex is default 0, meaning that the tab follows the flow of the document.
     * You can overrule this using this parameter if you wish. Use a value of -1 to
     * disable built-in keyboard navigation.
     *  @type int
     *  @default 0
     *
     *  @dtopt Options
     *  @name DataTable.defaults.tabIndex
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "tabIndex": 1
     *      } );
     *    } );
     */
    "iTabIndex": 0,

    /**
     * Classes that DataTables assigns to the various components and features
     * that it adds to the HTML table. This allows classes to be configured
     * during initialisation in addition to through the static
     * {@link DataTable.ext.oStdClasses} object).
     *  @namespace
     *  @name DataTable.defaults.classes
     */
    "oClasses": {},

    /**
     * All strings that DataTables uses in the user interface that it creates
     * are defined in this object, allowing you to modified them individually or
     * completely replace them all as required.
     *  @namespace
     *  @name DataTable.defaults.language
     */
    "oLanguage": {
      /**
       * Strings that are used for WAI-ARIA labels and controls only (these are not
       * actually visible on the page, but will be read by screenreaders, and thus
       * must be internationalised as well).
       *  @namespace
       *  @name DataTable.defaults.language.aria
       */
      "oAria": {
        /**
         * ARIA label that is added to the table headers when the column may be
         * sorted ascending by activing the column (click or return when focused).
         * Note that the column header is prefixed to this string.
         *  @type string
         *  @default : activate to sort column ascending
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.aria.sortAscending
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "aria": {
         *            "sortAscending": " - click/return to sort ascending"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sSortAscending": ": activate to sort column ascending",

        /**
         * ARIA label that is added to the table headers when the column may be
         * sorted descending by activing the column (click or return when focused).
         * Note that the column header is prefixed to this string.
         *  @type string
         *  @default : activate to sort column ascending
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.aria.sortDescending
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "aria": {
         *            "sortDescending": " - click/return to sort descending"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sSortDescending": ": activate to sort column descending"
      },

      /**
       * Pagination string used by DataTables for the built-in pagination
       * control types.
       *  @namespace
       *  @name DataTable.defaults.language.paginate
       */
      "oPaginate": {
        /**
         * Text to use when using the 'full_numbers' type of pagination for the
         * button to take the user to the first page.
         *  @type string
         *  @default First
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.first
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "first": "First page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sFirst": "First",

        /**
         * Text to use when using the 'full_numbers' type of pagination for the
         * button to take the user to the last page.
         *  @type string
         *  @default Last
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.last
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "last": "Last page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sLast": "Last",

        /**
         * Text to use for the 'next' pagination button (to take the user to the
         * next page).
         *  @type string
         *  @default Next
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.next
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "next": "Next page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sNext": "Next",

        /**
         * Text to use for the 'previous' pagination button (to take the user to
         * the previous page).
         *  @type string
         *  @default Previous
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.previous
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "previous": "Previous page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sPrevious": "Previous"
      },

      /**
       * This string is shown in preference to `zeroRecords` when the table is
       * empty of data (regardless of filtering). Note that this is an optional
       * parameter - if it is not given, the value of `zeroRecords` will be used
       * instead (either the default or given value).
       *  @type string
       *  @default No data available in table
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.emptyTable
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "emptyTable": "No data available in table"
       *        }
       *      } );
       *    } );
       */
      "sEmptyTable": "No data available in table",

      /**
       * This string gives information to the end user about the information
       * that is current on display on the page. The following tokens can be
       * used in the string and will be dynamically replaced as the table
       * display updates. This tokens can be placed anywhere in the string, or
       * removed as needed by the language requires:
       *
       * * `\_START\_` - Display index of the first record on the current page
       * * `\_END\_` - Display index of the last record on the current page
       * * `\_TOTAL\_` - Number of records in the table after filtering
       * * `\_MAX\_` - Number of records in the table without filtering
       * * `\_PAGE\_` - Current page number
       * * `\_PAGES\_` - Total number of pages of data in the table
       *
       *  @type string
       *  @default Showing _START_ to _END_ of _TOTAL_ entries
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.info
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "info": "Showing page _PAGE_ of _PAGES_"
       *        }
       *      } );
       *    } );
       */
      "sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",

      /**
       * Display information string for when the table is empty. Typically the
       * format of this string should match `info`.
       *  @type string
       *  @default Showing 0 to 0 of 0 entries
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.infoEmpty
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "infoEmpty": "No entries to show"
       *        }
       *      } );
       *    } );
       */
      "sInfoEmpty": "Showing 0 to 0 of 0 entries",

      /**
       * When a user filters the information in a table, this string is appended
       * to the information (`info`) to give an idea of how strong the filtering
       * is. The variable _MAX_ is dynamically updated.
       *  @type string
       *  @default (filtered from _MAX_ total entries)
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.infoFiltered
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "infoFiltered": " - filtering from _MAX_ records"
       *        }
       *      } );
       *    } );
       */
      "sInfoFiltered": "(filtered from _MAX_ total entries)",

      /**
       * If can be useful to append extra information to the info string at times,
       * and this variable does exactly that. This information will be appended to
       * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
       * being used) at all times.
       *  @type string
       *  @default <i>Empty string</i>
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.infoPostFix
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "infoPostFix": "All records shown are derived from real information."
       *        }
       *      } );
       *    } );
       */
      "sInfoPostFix": "",

      /**
       * This decimal place operator is a little different from the other
       * language options since DataTables doesn't output floating point
       * numbers, so it won't ever use this for display of a number. Rather,
       * what this parameter does is modify the sort methods of the table so
       * that numbers which are in a format which has a character other than
       * a period (`.`) as a decimal place will be sorted numerically.
       *
       * Note that numbers with different decimal places cannot be shown in
       * the same table and still be sortable, the table must be consistent.
       * However, multiple different tables on the page can use different
       * decimal place characters.
       *  @type string
       *  @default 
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.decimal
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "decimal": ","
       *          "thousands": "."
       *        }
       *      } );
       *    } );
       */
      "sDecimal": "",

      /**
       * DataTables has a build in number formatter (`formatNumber`) which is
       * used to format large numbers that are used in the table information.
       * By default a comma is used, but this can be trivially changed to any
       * character you wish with this parameter.
       *  @type string
       *  @default ,
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.thousands
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "thousands": "'"
       *        }
       *      } );
       *    } );
       */
      "sThousands": ",",

      /**
       * Detail the action that will be taken when the drop down menu for the
       * pagination length option is changed. The '_MENU_' variable is replaced
       * with a default select list of 10, 25, 50 and 100, and can be replaced
       * with a custom select box if required.
       *  @type string
       *  @default Show _MENU_ entries
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.lengthMenu
       *
       *  @example
       *    // Language change only
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "lengthMenu": "Display _MENU_ records"
       *        }
       *      } );
       *    } );
       *
       *  @example
       *    // Language and options change
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "lengthMenu": 'Display <select>'+
       *            '<option value="10">10</option>'+
       *            '<option value="20">20</option>'+
       *            '<option value="30">30</option>'+
       *            '<option value="40">40</option>'+
       *            '<option value="50">50</option>'+
       *            '<option value="-1">All</option>'+
       *            '</select> records'
       *        }
       *      } );
       *    } );
       */
      "sLengthMenu": "Show _MENU_ entries",

      /**
       * When using Ajax sourced data and during the first draw when DataTables is
       * gathering the data, this message is shown in an empty row in the table to
       * indicate to the end user the the data is being loaded. Note that this
       * parameter is not used when loading data by server-side processing, just
       * Ajax sourced data with client-side processing.
       *  @type string
       *  @default Loading...
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.loadingRecords
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "loadingRecords": "Please wait - loading..."
       *        }
       *      } );
       *    } );
       */
      "sLoadingRecords": "Loading...",

      /**
       * Text which is displayed when the table is processing a user action
       * (usually a sort command or similar).
       *  @type string
       *  @default Processing...
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.processing
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "processing": "DataTables is currently busy"
       *        }
       *      } );
       *    } );
       */
      "sProcessing": "Processing...",

      /**
       * Details the actions that will be taken when the user types into the
       * filtering input text box. The variable "_INPUT_", if used in the string,
       * is replaced with the HTML text box for the filtering input allowing
       * control over where it appears in the string. If "_INPUT_" is not given
       * then the input box is appended to the string automatically.
       *  @type string
       *  @default Search:
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.search
       *
       *  @example
       *    // Input text box will be appended at the end automatically
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "search": "Filter records:"
       *        }
       *      } );
       *    } );
       *
       *  @example
       *    // Specify where the filter should appear
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "search": "Apply filter _INPUT_ to table"
       *        }
       *      } );
       *    } );
       */
      "sSearch": "Search:",

      /**
       * Assign a `placeholder` attribute to the search `input` element
       *  @type string
       *  @default 
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.searchPlaceholder
       */
      "sSearchPlaceholder": "",

      /**
       * All of the language information can be stored in a file on the
       * server-side, which DataTables will look up if this parameter is passed.
       * It must store the URL of the language file, which is in a JSON format,
       * and the object has the same properties as the oLanguage object in the
       * initialiser object (i.e. the above parameters). Please refer to one of
       * the example language files to see how this works in action.
       *  @type string
       *  @default <i>Empty string - i.e. disabled</i>
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.url
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "url": "http://www.sprymedia.co.uk/dataTables/lang.txt"
       *        }
       *      } );
       *    } );
       */
      "sUrl": "",

      /**
       * Text shown inside the table records when the is no information to be
       * displayed after filtering. `emptyTable` is shown when there is simply no
       * information in the table at all (regardless of filtering).
       *  @type string
       *  @default No matching records found
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.zeroRecords
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "zeroRecords": "No records to display"
       *        }
       *      } );
       *    } );
       */
      "sZeroRecords": "No matching records found"
    },

    /**
     * This parameter allows you to have define the global filtering state at
     * initialisation time. As an object the `search` parameter must be
     * defined, but all other parameters are optional. When `regex` is true,
     * the search string will be treated as a regular expression, when false
     * (default) it will be treated as a straight string. When `smart`
     * DataTables will use it's smart filtering methods (to word match at
     * any point in the data), when false this will not be done.
     *  @namespace
     *  @extends DataTable.models.oSearch
     *
     *  @dtopt Options
     *  @name DataTable.defaults.search
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "search": {"search": "Initial search"}
     *      } );
     *    } )
     */
    "oSearch": $.extend({}, DataTable.models.oSearch),

    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * By default DataTables will look for the property `data` (or `aaData` for
     * compatibility with DataTables 1.9-) when obtaining data from an Ajax
     * source or for server-side processing - this parameter allows that
     * property to be changed. You can use Javascript dotted object notation to
     * get a data source for multiple levels of nesting.
     *  @type string
     *  @default data
     *
     *  @dtopt Options
     *  @dtopt Server-side
     *  @name DataTable.defaults.ajaxDataProp
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "sAjaxDataProp": "data",

    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * You can instruct DataTables to load data from an external
     * source using this parameter (use aData if you want to pass data in you
     * already have). Simply provide a url a JSON object can be obtained from.
     *  @type string
     *  @default null
     *
     *  @dtopt Options
     *  @dtopt Server-side
     *  @name DataTable.defaults.ajaxSource
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "sAjaxSource": null,

    /**
     * This initialisation variable allows you to specify exactly where in the
     * DOM you want DataTables to inject the various controls it adds to the page
     * (for example you might want the pagination controls at the top of the
     * table). DIV elements (with or without a custom class) can also be added to
     * aid styling. The follow syntax is used:
     *   <ul>
     *     <li>The following options are allowed:
     *       <ul>
     *         <li>'l' - Length changing</li>
     *         <li>'f' - Filtering input</li>
     *         <li>'t' - The table!</li>
     *         <li>'i' - Information</li>
     *         <li>'p' - Pagination</li>
     *         <li>'r' - pRocessing</li>
     *       </ul>
     *     </li>
     *     <li>The following constants are allowed:
     *       <ul>
     *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
     *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
     *       </ul>
     *     </li>
     *     <li>The following syntax is expected:
     *       <ul>
     *         <li>'&lt;' and '&gt;' - div elements</li>
     *         <li>'&lt;"class" and '&gt;' - div with a class</li>
     *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
     *       </ul>
     *     </li>
     *     <li>Examples:
     *       <ul>
     *         <li>'&lt;"wrapper"flipt&gt;'</li>
     *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
     *       </ul>
     *     </li>
     *   </ul>
     *  @type string
     *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>
     *    <"H"lfr>t<"F"ip> <i>(when `jQueryUI` is true)</i>
     *
     *  @dtopt Options
     *  @name DataTable.defaults.dom
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "dom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
     *      } );
     *    } );
     */
    "sDom": "lfrtip",

    /**
     * Search delay option. This will throttle full table searches that use the
     * DataTables provided search input element (it does not effect calls to
     * `dt-api search()`, providing a delay before the search is made.
     *  @type integer
     *  @default 0
     *
     *  @dtopt Options
     *  @name DataTable.defaults.searchDelay
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "searchDelay": 200
     *      } );
     *    } )
     */
    "searchDelay": null,

    /**
     * DataTables features six different built-in options for the buttons to
     * display for pagination control:
     *
     * * `numbers` - Page number buttons only
     * * `simple` - 'Previous' and 'Next' buttons only
     * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
     * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
     * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
     * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
     *  
     * Further methods can be added using {@link DataTable.ext.oPagination}.
     *  @type string
     *  @default simple_numbers
     *
     *  @dtopt Options
     *  @name DataTable.defaults.pagingType
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "pagingType": "full_numbers"
     *      } );
     *    } )
     */
    "sPaginationType": "simple_numbers",

    /**
     * Enable horizontal scrolling. When a table is too wide to fit into a
     * certain layout, or you have a large number of columns in the table, you
     * can enable x-scrolling to show the table in a viewport, which can be
     * scrolled. This property can be `true` which will allow the table to
     * scroll horizontally when needed, or any CSS unit, or a number (in which
     * case it will be treated as a pixel measurement). Setting as simply `true`
     * is recommended.
     *  @type boolean|string
     *  @default <i>blank string - i.e. disabled</i>
     *
     *  @dtopt Features
     *  @name DataTable.defaults.scrollX
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollX": true,
     *        "scrollCollapse": true
     *      } );
     *    } );
     */
    "sScrollX": "",

    /**
     * This property can be used to force a DataTable to use more width than it
     * might otherwise do when x-scrolling is enabled. For example if you have a
     * table which requires to be well spaced, this parameter is useful for
     * "over-sizing" the table, and thus forcing scrolling. This property can by
     * any CSS unit, or a number (in which case it will be treated as a pixel
     * measurement).
     *  @type string
     *  @default <i>blank string - i.e. disabled</i>
     *
     *  @dtopt Options
     *  @name DataTable.defaults.scrollXInner
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollX": "100%",
     *        "scrollXInner": "110%"
     *      } );
     *    } );
     */
    "sScrollXInner": "",

    /**
     * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
     * to the given height, and enable scrolling for any data which overflows the
     * current viewport. This can be used as an alternative to paging to display
     * a lot of data in a small area (although paging and scrolling can both be
     * enabled at the same time). This property can be any CSS unit, or a number
     * (in which case it will be treated as a pixel measurement).
     *  @type string
     *  @default <i>blank string - i.e. disabled</i>
     *
     *  @dtopt Features
     *  @name DataTable.defaults.scrollY
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollY": "200px",
     *        "paginate": false
     *      } );
     *    } );
     */
    "sScrollY": "",

    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * Set the HTTP method that is used to make the Ajax call for server-side
     * processing or Ajax sourced data.
     *  @type string
     *  @default GET
     *
     *  @dtopt Options
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverMethod
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "sServerMethod": "GET",

    /**
     * DataTables makes use of renderers when displaying HTML elements for
     * a table. These renderers can be added or modified by plug-ins to
     * generate suitable mark-up for a site. For example the Bootstrap
     * integration plug-in for DataTables uses a paging button renderer to
     * display pagination buttons in the mark-up required by Bootstrap.
     *
     * For further information about the renderers available see
     * DataTable.ext.renderer
     *  @type string|object
     *  @default null
     *
     *  @name DataTable.defaults.renderer
     *
     */
    "renderer": null,

    /**
     * Set the data property name that DataTables should use to get a row's id
     * to set as the `id` property in the node.
     *  @type string
     *  @default DT_RowId
     *
     *  @name DataTable.defaults.rowId
     */
    "rowId": "DT_RowId"
  };

  _fnHungarianMap(DataTable.defaults);
  /*
   * Developer note - See note in model.defaults.js about the use of Hungarian
   * notation and camel case.
   */

  /**
   * Column options that can be given to DataTables at initialisation time.
   *  @namespace
   */


  DataTable.defaults.column = {
    /**
     * Define which column(s) an order will occur on for this column. This
     * allows a column's ordering to take multiple columns into account when
     * doing a sort or use the data from a different column. For example first
     * name / last name columns make sense to do a multi-column sort over the
     * two columns.
     *  @type array|int
     *  @default null <i>Takes the value of the column index automatically</i>
     *
     *  @name DataTable.defaults.column.orderData
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderData": [ 0, 1 ], "targets": [ 0 ] },
     *          { "orderData": [ 1, 0 ], "targets": [ 1 ] },
     *          { "orderData": 2, "targets": [ 2 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "orderData": [ 0, 1 ] },
     *          { "orderData": [ 1, 0 ] },
     *          { "orderData": 2 },
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "aDataSort": null,
    "iDataSort": -1,

    /**
     * You can control the default ordering direction, and even alter the
     * behaviour of the sort handler (i.e. only allow ascending ordering etc)
     * using this parameter.
     *  @type array
     *  @default [ 'asc', 'desc' ]
     *
     *  @name DataTable.defaults.column.orderSequence
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderSequence": [ "asc" ], "targets": [ 1 ] },
     *          { "orderSequence": [ "desc", "asc", "asc" ], "targets": [ 2 ] },
     *          { "orderSequence": [ "desc" ], "targets": [ 3 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          { "orderSequence": [ "asc" ] },
     *          { "orderSequence": [ "desc", "asc", "asc" ] },
     *          { "orderSequence": [ "desc" ] },
     *          null
     *        ]
     *      } );
     *    } );
     */
    "asSorting": ['asc', 'desc'],

    /**
     * Enable or disable filtering on the data in this column.
     *  @type boolean
     *  @default true
     *
     *  @name DataTable.defaults.column.searchable
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "searchable": false, "targets": [ 0 ] }
     *        ] } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "searchable": false },
     *          null,
     *          null,
     *          null,
     *          null
     *        ] } );
     *    } );
     */
    "bSearchable": true,

    /**
     * Enable or disable ordering on this column.
     *  @type boolean
     *  @default true
     *
     *  @name DataTable.defaults.column.orderable
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderable": false, "targets": [ 0 ] }
     *        ] } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "orderable": false },
     *          null,
     *          null,
     *          null,
     *          null
     *        ] } );
     *    } );
     */
    "bSortable": true,

    /**
     * Enable or disable the display of this column.
     *  @type boolean
     *  @default true
     *
     *  @name DataTable.defaults.column.visible
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "visible": false, "targets": [ 0 ] }
     *        ] } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "visible": false },
     *          null,
     *          null,
     *          null,
     *          null
     *        ] } );
     *    } );
     */
    "bVisible": true,

    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     *  @type function
     *  @param {element} td The TD node that has been created
     *  @param {*} cellData The Data for the cell
     *  @param {array|object} rowData The data for the whole row
     *  @param {int} row The row index for the aoData data store
     *  @param {int} col The column index for aoColumns
     *
     *  @name DataTable.defaults.column.createdCell
     *  @dtopt Columns
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [3],
     *          "createdCell": function (td, cellData, rowData, row, col) {
     *            if ( cellData == "1.7" ) {
     *              $(td).css('color', 'blue')
     *            }
     *          }
     *        } ]
     *      });
     *    } );
     */
    "fnCreatedCell": null,

    /**
     * This parameter has been replaced by `data` in DataTables to ensure naming
     * consistency. `dataProp` can still be used, as there is backwards
     * compatibility in DataTables for this option, but it is strongly
     * recommended that you use `data` in preference to `dataProp`.
     *  @name DataTable.defaults.column.dataProp
     */

    /**
     * This property can be used to read data from any data source property,
     * including deeply nested objects / properties. `data` can be given in a
     * number of different ways which effect its behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object. Note that
     *      function notation is recommended for use in `render` rather than
     *      `data` as it is much simpler to use as a renderer.
     * * `null` - use the original data source for the row rather than plucking
     *   data directly from it. This action has effects on two other
     *   initialisation options:
     *    * `defaultContent` - When null is given as the `data` option and
     *      `defaultContent` is specified for the column, the value defined by
     *      `defaultContent` will be used for the cell.
     *    * `render` - When null is used for the `data` option and the `render`
     *      option is specified for the column, the whole data source for the
     *      row is used for the renderer.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * `{array|object}` The data source for the row
     *      * `{string}` The type call data requested - this will be 'set' when
     *        setting data or 'filter', 'display', 'type', 'sort' or undefined
     *        when gathering data. Note that when `undefined` is given for the
     *        type DataTables expects to get the raw data for the object back<
     *      * `{*}` Data to set when the second parameter is 'set'.
     *    * Return:
     *      * The return value from the function is not required when 'set' is
     *        the type of call, but otherwise the return is what will be used
     *        for the data requested.
     *
     * Note that `data` is a getter and setter option. If you just require
     * formatting of data for output, you will likely want to use `render` which
     * is simply a getter and thus simpler to use.
     *
     * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
     * name change reflects the flexibility of this property and is consistent
     * with the naming of mRender. If 'mDataProp' is given, then it will still
     * be used by DataTables, as it automatically maps the old name to the new
     * if required.
     *
     *  @type string|int|function|null
     *  @default null <i>Use automatically calculated column index</i>
     *
     *  @name DataTable.defaults.column.data
     *  @dtopt Columns
     *
     *  @example
     *    // Read table data from objects
     *    // JSON structure for each row:
     *    //   {
     *    //      "engine": {value},
     *    //      "browser": {value},
     *    //      "platform": {value},
     *    //      "version": {value},
     *    //      "grade": {value}
     *    //   }
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajaxSource": "sources/objects.txt",
     *        "columns": [
     *          { "data": "engine" },
     *          { "data": "browser" },
     *          { "data": "platform" },
     *          { "data": "version" },
     *          { "data": "grade" }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Read information from deeply nested objects
     *    // JSON structure for each row:
     *    //   {
     *    //      "engine": {value},
     *    //      "browser": {value},
     *    //      "platform": {
     *    //         "inner": {value}
     *    //      },
     *    //      "details": [
     *    //         {value}, {value}
     *    //      ]
     *    //   }
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajaxSource": "sources/deep.txt",
     *        "columns": [
     *          { "data": "engine" },
     *          { "data": "browser" },
     *          { "data": "platform.inner" },
     *          { "data": "platform.details.0" },
     *          { "data": "platform.details.1" }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `data` as a function to provide different information for
     *    // sorting, filtering and display. In this case, currency (price)
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": function ( source, type, val ) {
     *            if (type === 'set') {
     *              source.price = val;
     *              // Store the computed dislay and filter values for efficiency
     *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
     *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
     *              return;
     *            }
     *            else if (type === 'display') {
     *              return source.price_display;
     *            }
     *            else if (type === 'filter') {
     *              return source.price_filter;
     *            }
     *            // 'sort', 'type' and undefined all just use the integer
     *            return source.price;
     *          }
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using default content
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": null,
     *          "defaultContent": "Click to edit"
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using array notation - outputting a list from an array
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": "name[, ]"
     *        } ]
     *      } );
     *    } );
     *
     */
    "mData": null,

    /**
     * This property is the rendering partner to `data` and it is suggested that
     * when you want to manipulate data for display (including filtering,
     * sorting etc) without altering the underlying data for the table, use this
     * property. `render` can be considered to be the the read only companion to
     * `data` which is read / write (then as such more complex). Like `data`
     * this option can be given in a number of different ways to effect its
     * behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object.
     * * `object` - use different data for the different data types requested by
     *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
     *   of the object is the data type the property refers to and the value can
     *   defined using an integer, string or function using the same rules as
     *   `render` normally does. Note that an `_` option _must_ be specified.
     *   This is the default value to use if you haven't specified a value for
     *   the data type requested by DataTables.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * {array|object} The data source for the row (based on `data`)
     *      * {string} The type call data requested - this will be 'filter',
     *        'display', 'type' or 'sort'.
     *      * {array|object} The full data source for the row (not based on
     *        `data`)
     *    * Return:
     *      * The return value from the function is what will be used for the
     *        data requested.
     *
     *  @type string|int|function|object|null
     *  @default null Use the data source value.
     *
     *  @name DataTable.defaults.column.render
     *  @dtopt Columns
     *
     *  @example
     *    // Create a comma separated list from an array of objects
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajaxSource": "sources/deep.txt",
     *        "columns": [
     *          { "data": "engine" },
     *          { "data": "browser" },
     *          {
     *            "data": "platform",
     *            "render": "[, ].name"
     *          }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Execute a function to obtain data
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": null, // Use the full data source object for the renderer's source
     *          "render": "browserName()"
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // As an object, extracting different data for the different types
     *    // This would be used with a data source such as:
     *    //   { "phone": 5552368, "phone_filter": "5552368 555-2368", "phone_display": "555-2368" }
     *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`
     *    // (which has both forms) is used for filtering for if a user inputs either format, while
     *    // the formatted phone number is the one that is shown in the table.
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": null, // Use the full data source object for the renderer's source
     *          "render": {
     *            "_": "phone",
     *            "filter": "phone_filter",
     *            "display": "phone_display"
     *          }
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // Use as a function to create a link from the data source
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": "download_link",
     *          "render": function ( data, type, full ) {
     *            return '<a href="'+data+'">Download</a>';
     *          }
     *        } ]
     *      } );
     *    } );
     */
    "mRender": null,

    /**
     * Change the cell type created for the column - either TD cells or TH cells. This
     * can be useful as TH cells have semantic meaning in the table body, allowing them
     * to act as a header for a row (you may wish to add scope='row' to the TH elements).
     *  @type string
     *  @default td
     *
     *  @name DataTable.defaults.column.cellType
     *  @dtopt Columns
     *
     *  @example
     *    // Make the first column use TH cells
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "cellType": "th"
     *        } ]
     *      } );
     *    } );
     */
    "sCellType": "td",

    /**
     * Class to give to each cell in this column.
     *  @type string
     *  @default <i>Empty string</i>
     *
     *  @name DataTable.defaults.column.class
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "class": "my_class", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "class": "my_class" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sClass": "",

    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     * Generally you shouldn't need this!
     *  @type string
     *  @default <i>Empty string<i>
     *
     *  @name DataTable.defaults.column.contentPadding
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          null,
     *          null,
     *          {
     *            "contentPadding": "mmm"
     *          }
     *        ]
     *      } );
     *    } );
     */
    "sContentPadding": "",

    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because `data`
     * is set to null, or because the data source itself is null).
     *  @type string
     *  @default null
     *
     *  @name DataTable.defaults.column.defaultContent
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          {
     *            "data": null,
     *            "defaultContent": "Edit",
     *            "targets": [ -1 ]
     *          }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          null,
     *          null,
     *          {
     *            "data": null,
     *            "defaultContent": "Edit"
     *          }
     *        ]
     *      } );
     *    } );
     */
    "sDefaultContent": null,

    /**
     * This parameter is only used in DataTables' server-side processing. It can
     * be exceptionally useful to know what columns are being displayed on the
     * client side, and to map these to database fields. When defined, the names
     * also allow DataTables to reorder information from the server if it comes
     * back in an unexpected order (i.e. if you switch your columns around on the
     * client-side, your server-side code does not also need updating).
     *  @type string
     *  @default <i>Empty string</i>
     *
     *  @name DataTable.defaults.column.name
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "name": "engine", "targets": [ 0 ] },
     *          { "name": "browser", "targets": [ 1 ] },
     *          { "name": "platform", "targets": [ 2 ] },
     *          { "name": "version", "targets": [ 3 ] },
     *          { "name": "grade", "targets": [ 4 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "name": "engine" },
     *          { "name": "browser" },
     *          { "name": "platform" },
     *          { "name": "version" },
     *          { "name": "grade" }
     *        ]
     *      } );
     *    } );
     */
    "sName": "",

    /**
     * Defines a data source type for the ordering which can be used to read
     * real-time information from the table (updating the internally cached
     * version) prior to ordering. This allows ordering to occur on user
     * editable elements such as form inputs.
     *  @type string
     *  @default std
     *
     *  @name DataTable.defaults.column.orderDataType
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderDataType": "dom-text", "targets": [ 2, 3 ] },
     *          { "type": "numeric", "targets": [ 3 ] },
     *          { "orderDataType": "dom-select", "targets": [ 4 ] },
     *          { "orderDataType": "dom-checkbox", "targets": [ 5 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          null,
     *          { "orderDataType": "dom-text" },
     *          { "orderDataType": "dom-text", "type": "numeric" },
     *          { "orderDataType": "dom-select" },
     *          { "orderDataType": "dom-checkbox" }
     *        ]
     *      } );
     *    } );
     */
    "sSortDataType": "std",

    /**
     * The title of this column.
     *  @type string
     *  @default null <i>Derived from the 'TH' value for this column in the
     *    original HTML table.</i>
     *
     *  @name DataTable.defaults.column.title
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "title": "My column title", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "title": "My column title" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sTitle": null,

    /**
     * The type allows you to specify how the data for this column will be
     * ordered. Four types (string, numeric, date and html (which will strip
     * HTML tags before ordering)) are currently available. Note that only date
     * formats understood by Javascript's Date() object will be accepted as type
     * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
     * 'numeric', 'date' or 'html' (by default). Further types can be adding
     * through plug-ins.
     *  @type string
     *  @default null <i>Auto-detected from raw data</i>
     *
     *  @name DataTable.defaults.column.type
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "type": "html", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "type": "html" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sType": null,

    /**
     * Defining the width of the column, this parameter may take any CSS value
     * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
     * been given a specific width through this interface ensuring that the table
     * remains readable.
     *  @type string
     *  @default null <i>Automatic</i>
     *
     *  @name DataTable.defaults.column.width
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "width": "20%", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "width": "20%" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sWidth": null
  };

  _fnHungarianMap(DataTable.defaults.column);
  /**
   * DataTables settings object - this holds all the information needed for a
   * given table, including configuration, data and current application of the
   * table options. DataTables does not have a single instance for each DataTable
   * with the settings attached to that instance, but rather instances of the
   * DataTable "class" are created on-the-fly as needed (typically by a
   * $().dataTable() call) and the settings object is then applied to that
   * instance.
   *
   * Note that this object is related to {@link DataTable.defaults} but this
   * one is the internal data store for DataTables's cache of columns. It should
   * NOT be manipulated outside of DataTables. Any configuration should be done
   * through the initialisation options.
   *  @namespace
   *  @todo Really should attach the settings object to individual instances so we
   *    don't need to create new instances on each $().dataTable() call (if the
   *    table already exists). It would also save passing oSettings around and
   *    into every single function. However, this is a very significant
   *    architecture change for DataTables and will almost certainly break
   *    backwards compatibility with older installations. This is something that
   *    will be done in 2.0.
   */


  DataTable.models.oSettings = {
    /**
     * Primary features of DataTables and their enablement state.
     *  @namespace
     */
    "oFeatures": {
      /**
       * Flag to say if DataTables should automatically try to calculate the
       * optimum table and columns widths (true) or not (false).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bAutoWidth": null,

      /**
       * Delay the creation of TR and TD elements until they are actually
       * needed by a driven page draw. This can give a significant speed
       * increase for Ajax source and Javascript source data, but makes no
       * difference at all fro DOM and server-side processing tables.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bDeferRender": null,

      /**
       * Enable filtering on the table or not. Note that if this is disabled
       * then there is no filtering at all on the table, including fnFilter.
       * To just remove the filtering input use sDom and remove the 'f' option.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bFilter": null,

      /**
       * Table information element (the 'Showing x of y records' div) enable
       * flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bInfo": null,

      /**
       * Present a user control allowing the end user to change the page size
       * when pagination is enabled.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bLengthChange": null,

      /**
       * Pagination enabled or not. Note that if this is disabled then length
       * changing must also be disabled.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bPaginate": null,

      /**
       * Processing indicator enable flag whenever DataTables is enacting a
       * user request - typically an Ajax request for server-side processing.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bProcessing": null,

      /**
       * Server-side processing enabled flag - when enabled DataTables will
       * get all data from the server for every draw - there is no filtering,
       * sorting or paging done on the client-side.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bServerSide": null,

      /**
       * Sorting enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSort": null,

      /**
       * Multi-column sorting
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSortMulti": null,

      /**
       * Apply a class to the columns which are being sorted to provide a
       * visual highlight or not. This can slow things down when enabled since
       * there is a lot of DOM interaction.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSortClasses": null,

      /**
       * State saving enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bStateSave": null
    },

    /**
     * Scrolling settings for a table.
     *  @namespace
     */
    "oScroll": {
      /**
       * When the table is shorter in height than sScrollY, collapse the
       * table container down to the height of the table (when true).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bCollapse": null,

      /**
       * Width of the scrollbar for the web-browser's platform. Calculated
       * during table initialisation.
       *  @type int
       *  @default 0
       */
      "iBarWidth": 0,

      /**
       * Viewport width for horizontal scrolling. Horizontal scrolling is
       * disabled if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       */
      "sX": null,

      /**
       * Width to expand the table to when using x-scrolling. Typically you
       * should not need to use this.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       *  @deprecated
       */
      "sXInner": null,

      /**
       * Viewport height for vertical scrolling. Vertical scrolling is disabled
       * if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       */
      "sY": null
    },

    /**
     * Language information for the table.
     *  @namespace
     *  @extends DataTable.defaults.oLanguage
     */
    "oLanguage": {
      /**
       * Information callback function. See
       * {@link DataTable.defaults.fnInfoCallback}
       *  @type function
       *  @default null
       */
      "fnInfoCallback": null
    },

    /**
     * Browser support parameters
     *  @namespace
     */
    "oBrowser": {
      /**
       * Indicate if the browser incorrectly calculates width:100% inside a
       * scrolling element (IE6/7)
       *  @type boolean
       *  @default false
       */
      "bScrollOversize": false,

      /**
       * Determine if the vertical scrollbar is on the right or left of the
       * scrolling container - needed for rtl language layout, although not
       * all browsers move the scrollbar (Safari).
       *  @type boolean
       *  @default false
       */
      "bScrollbarLeft": false,

      /**
       * Flag for if `getBoundingClientRect` is fully supported or not
       *  @type boolean
       *  @default false
       */
      "bBounding": false,

      /**
       * Browser scrollbar width
       *  @type integer
       *  @default 0
       */
      "barWidth": 0
    },
    "ajax": null,

    /**
     * Array referencing the nodes which are used for the features. The
     * parameters of this object match what is allowed by sDom - i.e.
     *   <ul>
     *     <li>'l' - Length changing</li>
     *     <li>'f' - Filtering input</li>
     *     <li>'t' - The table!</li>
     *     <li>'i' - Information</li>
     *     <li>'p' - Pagination</li>
     *     <li>'r' - pRocessing</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aanFeatures": [],

    /**
     * Store data information - see {@link DataTable.models.oRow} for detailed
     * information.
     *  @type array
     *  @default []
     */
    "aoData": [],

    /**
     * Array of indexes which are in the current display (after filtering etc)
     *  @type array
     *  @default []
     */
    "aiDisplay": [],

    /**
     * Array of indexes for display - no filtering
     *  @type array
     *  @default []
     */
    "aiDisplayMaster": [],

    /**
     * Map of row ids to data indexes
     *  @type object
     *  @default {}
     */
    "aIds": {},

    /**
     * Store information about each column that is in use
     *  @type array
     *  @default []
     */
    "aoColumns": [],

    /**
     * Store information about the table's header
     *  @type array
     *  @default []
     */
    "aoHeader": [],

    /**
     * Store information about the table's footer
     *  @type array
     *  @default []
     */
    "aoFooter": [],

    /**
     * Store the applied global search information in case we want to force a
     * research or compare the old search to a new one.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @namespace
     *  @extends DataTable.models.oSearch
     */
    "oPreviousSearch": {},

    /**
     * Store the applied search for each column - see
     * {@link DataTable.models.oSearch} for the format that is used for the
     * filtering information for each column.
     *  @type array
     *  @default []
     */
    "aoPreSearchCols": [],

    /**
     * Sorting that is applied to the table. Note that the inner arrays are
     * used in the following manner:
     * <ul>
     *   <li>Index 0 - column number</li>
     *   <li>Index 1 - current sorting direction</li>
     * </ul>
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @todo These inner arrays should really be objects
     */
    "aaSorting": null,

    /**
     * Sorting that is always applied to the table (i.e. prefixed in front of
     * aaSorting).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @default []
     */
    "aaSortingFixed": [],

    /**
     * Classes to use for the striping of a table.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @default []
     */
    "asStripeClasses": null,

    /**
     * If restoring a table - we should restore its striping classes as well
     *  @type array
     *  @default []
     */
    "asDestroyStripes": [],

    /**
     * If restoring a table - we should restore its width
     *  @type int
     *  @default 0
     */
    "sDestroyWidth": 0,

    /**
     * Callback functions array for every time a row is inserted (i.e. on a draw).
     *  @type array
     *  @default []
     */
    "aoRowCallback": [],

    /**
     * Callback functions for the header on each draw.
     *  @type array
     *  @default []
     */
    "aoHeaderCallback": [],

    /**
     * Callback function for the footer on each draw.
     *  @type array
     *  @default []
     */
    "aoFooterCallback": [],

    /**
     * Array of callback functions for draw callback functions
     *  @type array
     *  @default []
     */
    "aoDrawCallback": [],

    /**
     * Array of callback functions for row created function
     *  @type array
     *  @default []
     */
    "aoRowCreatedCallback": [],

    /**
     * Callback functions for just before the table is redrawn. A return of
     * false will be used to cancel the draw.
     *  @type array
     *  @default []
     */
    "aoPreDrawCallback": [],

    /**
     * Callback functions for when the table has been initialised.
     *  @type array
     *  @default []
     */
    "aoInitComplete": [],

    /**
     * Callbacks for modifying the settings to be stored for state saving, prior to
     * saving state.
     *  @type array
     *  @default []
     */
    "aoStateSaveParams": [],

    /**
     * Callbacks for modifying the settings that have been stored for state saving
     * prior to using the stored values to restore the state.
     *  @type array
     *  @default []
     */
    "aoStateLoadParams": [],

    /**
     * Callbacks for operating on the settings object once the saved state has been
     * loaded
     *  @type array
     *  @default []
     */
    "aoStateLoaded": [],

    /**
     * Cache the table ID for quick access
     *  @type string
     *  @default <i>Empty string</i>
     */
    "sTableId": "",

    /**
     * The TABLE node for the main table
     *  @type node
     *  @default null
     */
    "nTable": null,

    /**
     * Permanent ref to the thead element
     *  @type node
     *  @default null
     */
    "nTHead": null,

    /**
     * Permanent ref to the tfoot element - if it exists
     *  @type node
     *  @default null
     */
    "nTFoot": null,

    /**
     * Permanent ref to the tbody element
     *  @type node
     *  @default null
     */
    "nTBody": null,

    /**
     * Cache the wrapper node (contains all DataTables controlled elements)
     *  @type node
     *  @default null
     */
    "nTableWrapper": null,

    /**
     * Indicate if when using server-side processing the loading of data
     * should be deferred until the second draw.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type boolean
     *  @default false
     */
    "bDeferLoading": false,

    /**
     * Indicate if all required information has been read in
     *  @type boolean
     *  @default false
     */
    "bInitialised": false,

    /**
     * Information about open rows. Each object in the array has the parameters
     * 'nTr' and 'nParent'
     *  @type array
     *  @default []
     */
    "aoOpenRows": [],

    /**
     * Dictate the positioning of DataTables' control elements - see
     * {@link DataTable.model.oInit.sDom}.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default null
     */
    "sDom": null,

    /**
     * Search delay (in mS)
     *  @type integer
     *  @default null
     */
    "searchDelay": null,

    /**
     * Which type of pagination should be used.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default two_button
     */
    "sPaginationType": "two_button",

    /**
     * The state duration (for `stateSave`) in seconds.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type int
     *  @default 0
     */
    "iStateDuration": 0,

    /**
     * Array of callback functions for state saving. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the JSON string to save that has been thus far created. Returns
     *       a JSON string to be inserted into a json object
     *       (i.e. '"param": [ 0, 1, 2]')</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aoStateSave": [],

    /**
     * Array of callback functions for state loading. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the object stored. May return false to cancel state loading</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aoStateLoad": [],

    /**
     * State that was saved. Useful for back reference
     *  @type object
     *  @default null
     */
    "oSavedState": null,

    /**
     * State that was loaded. Useful for back reference
     *  @type object
     *  @default null
     */
    "oLoadedState": null,

    /**
     * Source url for AJAX data for the table.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default null
     */
    "sAjaxSource": null,

    /**
     * Property from a given object from which to read the table data from. This
     * can be an empty string (when not server-side processing), in which case
     * it is  assumed an an array is given directly.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     */
    "sAjaxDataProp": null,

    /**
     * Note if draw should be blocked while getting data
     *  @type boolean
     *  @default true
     */
    "bAjaxDataGet": true,

    /**
     * The last jQuery XHR object that was used for server-side data gathering.
     * This can be used for working with the XHR information in one of the
     * callbacks
     *  @type object
     *  @default null
     */
    "jqXHR": null,

    /**
     * JSON returned from the server in the last Ajax request
     *  @type object
     *  @default undefined
     */
    "json": undefined,

    /**
     * Data submitted as part of the last Ajax request
     *  @type object
     *  @default undefined
     */
    "oAjaxData": undefined,

    /**
     * Function to get the server-side data.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type function
     */
    "fnServerData": null,

    /**
     * Functions which are called prior to sending an Ajax request so extra
     * parameters can easily be sent to the server
     *  @type array
     *  @default []
     */
    "aoServerParams": [],

    /**
     * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
     * required).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     */
    "sServerMethod": null,

    /**
     * Format numbers for display.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type function
     */
    "fnFormatNumber": null,

    /**
     * List of options that can be used for the user selectable length menu.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @default []
     */
    "aLengthMenu": null,

    /**
     * Counter for the draws that the table does. Also used as a tracker for
     * server-side processing
     *  @type int
     *  @default 0
     */
    "iDraw": 0,

    /**
     * Indicate if a redraw is being done - useful for Ajax
     *  @type boolean
     *  @default false
     */
    "bDrawing": false,

    /**
     * Draw index (iDraw) of the last error when parsing the returned data
     *  @type int
     *  @default -1
     */
    "iDrawError": -1,

    /**
     * Paging display length
     *  @type int
     *  @default 10
     */
    "_iDisplayLength": 10,

    /**
     * Paging start point - aiDisplay index
     *  @type int
     *  @default 0
     */
    "_iDisplayStart": 0,

    /**
     * Server-side processing - number of records in the result set
     * (i.e. before filtering), Use fnRecordsTotal rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     *  @type int
     *  @default 0
     *  @private
     */
    "_iRecordsTotal": 0,

    /**
     * Server-side processing - number of records in the current display set
     * (i.e. after filtering). Use fnRecordsDisplay rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     *  @type boolean
     *  @default 0
     *  @private
     */
    "_iRecordsDisplay": 0,

    /**
     * The classes to use for the table
     *  @type object
     *  @default {}
     */
    "oClasses": {},

    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if filtering has been done in the draw. Deprecated in favour of
     * events.
     *  @type boolean
     *  @default false
     *  @deprecated
     */
    "bFiltered": false,

    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if sorting has been done in the draw. Deprecated in favour of
     * events.
     *  @type boolean
     *  @default false
     *  @deprecated
     */
    "bSorted": false,

    /**
     * Indicate that if multiple rows are in the header and there is more than
     * one unique cell per column, if the top one (true) or bottom one (false)
     * should be used for sorting / title by DataTables.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type boolean
     */
    "bSortCellsTop": null,

    /**
     * Initialisation object that is used for the table
     *  @type object
     *  @default null
     */
    "oInit": null,

    /**
     * Destroy callback functions - for plug-ins to attach themselves to the
     * destroy so they can clean up markup and events.
     *  @type array
     *  @default []
     */
    "aoDestroyCallback": [],

    /**
     * Get the number of records in the current record set, before filtering
     *  @type function
     */
    "fnRecordsTotal": function fnRecordsTotal() {
      return _fnDataSource(this) == 'ssp' ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length;
    },

    /**
     * Get the number of records in the current record set, after filtering
     *  @type function
     */
    "fnRecordsDisplay": function fnRecordsDisplay() {
      return _fnDataSource(this) == 'ssp' ? this._iRecordsDisplay * 1 : this.aiDisplay.length;
    },

    /**
     * Get the display end point - aiDisplay index
     *  @type function
     */
    "fnDisplayEnd": function fnDisplayEnd() {
      var len = this._iDisplayLength,
          start = this._iDisplayStart,
          calc = start + len,
          records = this.aiDisplay.length,
          features = this.oFeatures,
          paginate = features.bPaginate;

      if (features.bServerSide) {
        return paginate === false || len === -1 ? start + records : Math.min(start + len, this._iRecordsDisplay);
      } else {
        return !paginate || calc > records || len === -1 ? records : calc;
      }
    },

    /**
     * The DataTables object for this table
     *  @type object
     *  @default null
     */
    "oInstance": null,

    /**
     * Unique identifier for each instance of the DataTables object. If there
     * is an ID on the table node, then it takes that value, otherwise an
     * incrementing internal counter is used.
     *  @type string
     *  @default null
     */
    "sInstance": null,

    /**
     * tabindex attribute value that is added to DataTables control elements, allowing
     * keyboard navigation of the table and its controls.
     */
    "iTabIndex": 0,

    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollHead": null,

    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollFoot": null,

    /**
     * Last applied sort
     *  @type array
     *  @default []
     */
    "aLastSort": [],

    /**
     * Stored plug-in instances
     *  @type object
     *  @default {}
     */
    "oPlugins": {},

    /**
     * Function used to get a row's id from the row's data
     *  @type function
     *  @default null
     */
    "rowIdFn": null,

    /**
     * Data location where to store a row's id
     *  @type string
     *  @default null
     */
    "rowId": null
  };
  /**
   * Extension object for DataTables that is used to provide all extension
   * options.
   *
   * Note that the `DataTable.ext` object is available through
   * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
   * also aliased to `jQuery.fn.dataTableExt` for historic reasons.
   *  @namespace
   *  @extends DataTable.models.ext
   */

  /**
   * DataTables extensions
   * 
   * This namespace acts as a collection area for plug-ins that can be used to
   * extend DataTables capabilities. Indeed many of the build in methods
   * use this method to provide their own capabilities (sorting methods for
   * example).
   *
   * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
   * reasons
   *
   *  @namespace
   */

  DataTable.ext = _ext = {
    /**
     * Buttons. For use with the Buttons extension for DataTables. This is
     * defined here so other extensions can define buttons regardless of load
     * order. It is _not_ used by DataTables core.
     *
     *  @type object
     *  @default {}
     */
    buttons: {},

    /**
     * Element class names
     *
     *  @type object
     *  @default {}
     */
    classes: {},

    /**
     * DataTables build type (expanded by the download builder)
     *
     *  @type string
     */
    builder: "-source-",

    /**
     * Error reporting.
     * 
     * How should DataTables report an error. Can take the value 'alert',
     * 'throw', 'none' or a function.
     *
     *  @type string|function
     *  @default alert
     */
    errMode: "alert",

    /**
     * Feature plug-ins.
     * 
     * This is an array of objects which describe the feature plug-ins that are
     * available to DataTables. These feature plug-ins are then available for
     * use through the `dom` initialisation option.
     * 
     * Each feature plug-in is described by an object which must have the
     * following properties:
     * 
     * * `fnInit` - function that is used to initialise the plug-in,
     * * `cFeature` - a character so the feature can be enabled by the `dom`
     *   instillation option. This is case sensitive.
     *
     * The `fnInit` function has the following input parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     *
     * And the following return is expected:
     * 
     * * {node|null} The element which contains your feature. Note that the
     *   return may also be void if your plug-in does not require to inject any
     *   DOM elements into DataTables control (`dom`) - for example this might
     *   be useful when developing a plug-in which allows table control via
     *   keyboard entry
     *
     *  @type array
     *
     *  @example
     *    $.fn.dataTable.ext.features.push( {
     *      "fnInit": function( oSettings ) {
     *        return new TableTools( { "oDTSettings": oSettings } );
     *      },
     *      "cFeature": "T"
     *    } );
     */
    feature: [],

    /**
     * Row searching.
     * 
     * This method of searching is complimentary to the default type based
     * searching, and a lot more comprehensive as it allows you complete control
     * over the searching logic. Each element in this array is a function
     * (parameters described below) that is called for every row in the table,
     * and your logic decides if it should be included in the searching data set
     * or not.
     *
     * Searching functions have the following input parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{array|object}` Data for the row to be processed (same as the
     *    original format that was passed in as the data source, or an array
     *    from a DOM data source
     * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
     *    can be useful to retrieve the `TR` element if you need DOM interaction.
     *
     * And the following return is expected:
     *
     * * {boolean} Include the row in the searched result set (true) or not
     *   (false)
     *
     * Note that as with the main search ability in DataTables, technically this
     * is "filtering", since it is subtractive. However, for consistency in
     * naming we call it searching here.
     *
     *  @type array
     *  @default []
     *
     *  @example
     *    // The following example shows custom search being applied to the
     *    // fourth column (i.e. the data[3] index) based on two input values
     *    // from the end-user, matching the data in a certain range.
     *    $.fn.dataTable.ext.search.push(
     *      function( settings, data, dataIndex ) {
     *        var min = document.getElementById('min').value * 1;
     *        var max = document.getElementById('max').value * 1;
     *        var version = data[3] == "-" ? 0 : data[3]*1;
     *
     *        if ( min == "" && max == "" ) {
     *          return true;
     *        }
     *        else if ( min == "" && version < max ) {
     *          return true;
     *        }
     *        else if ( min < version && "" == max ) {
     *          return true;
     *        }
     *        else if ( min < version && version < max ) {
     *          return true;
     *        }
     *        return false;
     *      }
     *    );
     */
    search: [],

    /**
     * Selector extensions
     *
     * The `selector` option can be used to extend the options available for the
     * selector modifier options (`selector-modifier` object data type) that
     * each of the three built in selector types offer (row, column and cell +
     * their plural counterparts). For example the Select extension uses this
     * mechanism to provide an option to select only rows, columns and cells
     * that have been marked as selected by the end user (`{selected: true}`),
     * which can be used in conjunction with the existing built in selector
     * options.
     *
     * Each property is an array to which functions can be pushed. The functions
     * take three attributes:
     *
     * * Settings object for the host table
     * * Options object (`selector-modifier` object type)
     * * Array of selected item indexes
     *
     * The return is an array of the resulting item indexes after the custom
     * selector has been applied.
     *
     *  @type object
     */
    selector: {
      cell: [],
      column: [],
      row: []
    },

    /**
     * Internal functions, exposed for used in plug-ins.
     * 
     * Please note that you should not need to use the internal methods for
     * anything other than a plug-in (and even then, try to avoid if possible).
     * The internal function may change between releases.
     *
     *  @type object
     *  @default {}
     */
    internal: {},

    /**
     * Legacy configuration options. Enable and disable legacy options that
     * are available in DataTables.
     *
     *  @type object
     */
    legacy: {
      /**
       * Enable / disable DataTables 1.9 compatible server-side processing
       * requests
       *
       *  @type boolean
       *  @default null
       */
      ajax: null
    },

    /**
     * Pagination plug-in methods.
     * 
     * Each entry in this object is a function and defines which buttons should
     * be shown by the pagination rendering method that is used for the table:
     * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
     * buttons are displayed in the document, while the functions here tell it
     * what buttons to display. This is done by returning an array of button
     * descriptions (what each button will do).
     *
     * Pagination types (the four built in options and any additional plug-in
     * options defined here) can be used through the `paginationType`
     * initialisation parameter.
     *
     * The functions defined take two parameters:
     *
     * 1. `{int} page` The current page index
     * 2. `{int} pages` The number of pages in the table
     *
     * Each function is expected to return an array where each element of the
     * array can be one of:
     *
     * * `first` - Jump to first page when activated
     * * `last` - Jump to last page when activated
     * * `previous` - Show previous page when activated
     * * `next` - Show next page when activated
     * * `{int}` - Show page of the index given
     * * `{array}` - A nested array containing the above elements to add a
     *   containing 'DIV' element (might be useful for styling).
     *
     * Note that DataTables v1.9- used this object slightly differently whereby
     * an object with two functions would be defined for each plug-in. That
     * ability is still supported by DataTables 1.10+ to provide backwards
     * compatibility, but this option of use is now decremented and no longer
     * documented in DataTables 1.10+.
     *
     *  @type object
     *  @default {}
     *
     *  @example
     *    // Show previous, next and current page buttons only
     *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
     *      return [ 'previous', page, 'next' ];
     *    };
     */
    pager: {},
    renderer: {
      pageButton: {},
      header: {}
    },

    /**
     * Ordering plug-ins - custom data source
     * 
     * The extension options for ordering of data available here is complimentary
     * to the default type based ordering that DataTables typically uses. It
     * allows much greater control over the the data that is being used to
     * order a column, but is necessarily therefore more complex.
     * 
     * This type of ordering is useful if you want to do ordering based on data
     * live from the DOM (for example the contents of an 'input' element) rather
     * than just the static string that DataTables knows of.
     * 
     * The way these plug-ins work is that you create an array of the values you
     * wish to be ordering for the column in question and then return that
     * array. The data in the array much be in the index order of the rows in
     * the table (not the currently ordering order!). Which order data gathering
     * function is run here depends on the `dt-init columns.orderDataType`
     * parameter that is used for the column (if any).
     *
     * The functions defined take two parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{int}` Target column index
     *
     * Each function is expected to return an array:
     *
     * * `{array}` Data for the column to be ordering upon
     *
     *  @type array
     *
     *  @example
     *    // Ordering using `input` node values
     *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
     *    {
     *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
     *        return $('input', td).val();
     *      } );
     *    }
     */
    order: {},

    /**
     * Type based plug-ins.
     *
     * Each column in DataTables has a type assigned to it, either by automatic
     * detection or by direct assignment using the `type` option for the column.
     * The type of a column will effect how it is ordering and search (plug-ins
     * can also make use of the column type if required).
     *
     * @namespace
     */
    type: {
      /**
       * Type detection functions.
       *
       * The functions defined in this object are used to automatically detect
       * a column's type, making initialisation of DataTables super easy, even
       * when complex data is in the table.
       *
       * The functions defined take two parameters:
       *
          *  1. `{*}` Data from the column cell to be analysed
          *  2. `{settings}` DataTables settings object. This can be used to
          *     perform context specific type detection - for example detection
          *     based on language settings such as using a comma for a decimal
          *     place. Generally speaking the options from the settings will not
          *     be required
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Data type detected, or null if unknown (and thus
       *   pass it on to the other type detection functions.
       *
       *  @type array
       *
       *  @example
       *    // Currency type detection plug-in:
       *    $.fn.dataTable.ext.type.detect.push(
       *      function ( data, settings ) {
       *        // Check the numeric part
       *        if ( ! $.isNumeric( data.substring(1) ) ) {
       *          return null;
       *        }
       *
       *        // Check prefixed by currency
       *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
       *          return 'currency';
       *        }
       *        return null;
       *      }
       *    );
       */
      detect: [],

      /**
       * Type based search formatting.
       *
       * The type based searching functions can be used to pre-format the
       * data to be search on. For example, it can be used to strip HTML
       * tags or to de-format telephone numbers for numeric only searching.
       *
       * Note that is a search is not defined for a column of a given type,
       * no search formatting will be performed.
       * 
       * Pre-processing of searching data plug-ins - When you assign the sType
       * for a column (or have it automatically detected for you by DataTables
       * or a type detection plug-in), you will typically be using this for
       * custom sorting, but it can also be used to provide custom searching
       * by allowing you to pre-processing the data and returning the data in
       * the format that should be searched upon. This is done by adding
       * functions this object with a parameter name which matches the sType
       * for that target column. This is the corollary of <i>afnSortData</i>
       * for searching data.
       *
       * The functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for searching
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Formatted string that will be used for the searching.
       *
       *  @type object
       *  @default {}
       *
       *  @example
       *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
       *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
       *    }
       */
      search: {},

      /**
       * Type based ordering.
       *
       * The column type tells DataTables what ordering to apply to the table
       * when a column is sorted upon. The order for each type that is defined,
       * is defined by the functions available in this object.
       *
       * Each ordering option can be described by three properties added to
       * this object:
       *
       * * `{type}-pre` - Pre-formatting function
       * * `{type}-asc` - Ascending order function
       * * `{type}-desc` - Descending order function
       *
       * All three can be used together, only `{type}-pre` or only
       * `{type}-asc` and `{type}-desc` together. It is generally recommended
       * that only `{type}-pre` is used, as this provides the optimal
       * implementation in terms of speed, although the others are provided
       * for compatibility with existing Javascript sort functions.
       *
       * `{type}-pre`: Functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for ordering
       *
       * And return:
       *
       * * `{*}` Data to be sorted upon
       *
       * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
       * functions, taking two parameters:
       *
          *  1. `{*}` Data to compare to the second parameter
          *  2. `{*}` Data to compare to the first parameter
       *
       * And returning:
       *
       * * `{*}` Ordering match: <0 if first parameter should be sorted lower
       *   than the second parameter, ===0 if the two parameters are equal and
       *   >0 if the first parameter should be sorted height than the second
       *   parameter.
       * 
       *  @type object
       *  @default {}
       *
       *  @example
       *    // Numeric ordering of formatted numbers with a pre-formatter
       *    $.extend( $.fn.dataTable.ext.type.order, {
       *      "string-pre": function(x) {
       *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
       *        return parseFloat( a );
       *      }
       *    } );
       *
       *  @example
       *    // Case-sensitive string ordering, with no pre-formatting method
       *    $.extend( $.fn.dataTable.ext.order, {
       *      "string-case-asc": function(x,y) {
       *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
       *      },
       *      "string-case-desc": function(x,y) {
       *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
       *      }
       *    } );
       */
      order: {}
    },

    /**
     * Unique DataTables instance counter
     *
     * @type int
     * @private
     */
    _unique: 0,
    //
    // Depreciated
    // The following properties are retained for backwards compatiblity only.
    // The should not be used in new projects and will be removed in a future
    // version
    //

    /**
     * Version check function.
     *  @type function
     *  @depreciated Since 1.10
     */
    fnVersionCheck: DataTable.fnVersionCheck,

    /**
     * Index for what 'this' index API functions should use
     *  @type int
     *  @deprecated Since v1.10
     */
    iApiIndex: 0,

    /**
     * jQuery UI class container
     *  @type object
     *  @deprecated Since v1.10
     */
    oJUIClasses: {},

    /**
     * Software version
     *  @type string
     *  @deprecated Since v1.10
     */
    sVersion: DataTable.version
  }; //
  // Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
  //

  $.extend(_ext, {
    afnFiltering: _ext.search,
    aTypes: _ext.type.detect,
    ofnSearch: _ext.type.search,
    oSort: _ext.type.order,
    afnSortData: _ext.order,
    aoFeatures: _ext.feature,
    oApi: _ext.internal,
    oStdClasses: _ext.classes,
    oPagination: _ext.pager
  });
  $.extend(DataTable.ext.classes, {
    "sTable": "dataTable",
    "sNoFooter": "no-footer",

    /* Paging buttons */
    "sPageButton": "paginate_button",
    "sPageButtonActive": "current",
    "sPageButtonDisabled": "disabled",

    /* Striping classes */
    "sStripeOdd": "odd",
    "sStripeEven": "even",

    /* Empty row */
    "sRowEmpty": "dataTables_empty",

    /* Features */
    "sWrapper": "dataTables_wrapper",
    "sFilter": "dataTables_filter",
    "sInfo": "dataTables_info",
    "sPaging": "dataTables_paginate paging_",

    /* Note that the type is postfixed */
    "sLength": "dataTables_length",
    "sProcessing": "dataTables_processing",

    /* Sorting */
    "sSortAsc": "sorting_asc",
    "sSortDesc": "sorting_desc",
    "sSortable": "sorting",

    /* Sortable in both directions */
    "sSortableAsc": "sorting_asc_disabled",
    "sSortableDesc": "sorting_desc_disabled",
    "sSortableNone": "sorting_disabled",
    "sSortColumn": "sorting_",

    /* Note that an int is postfixed for the sorting order */

    /* Filtering */
    "sFilterInput": "",

    /* Page length */
    "sLengthSelect": "",

    /* Scrolling */
    "sScrollWrapper": "dataTables_scroll",
    "sScrollHead": "dataTables_scrollHead",
    "sScrollHeadInner": "dataTables_scrollHeadInner",
    "sScrollBody": "dataTables_scrollBody",
    "sScrollFoot": "dataTables_scrollFoot",
    "sScrollFootInner": "dataTables_scrollFootInner",

    /* Misc */
    "sHeaderTH": "",
    "sFooterTH": "",
    // Deprecated
    "sSortJUIAsc": "",
    "sSortJUIDesc": "",
    "sSortJUI": "",
    "sSortJUIAscAllowed": "",
    "sSortJUIDescAllowed": "",
    "sSortJUIWrapper": "",
    "sSortIcon": "",
    "sJUIHeader": "",
    "sJUIFooter": ""
  });
  var extPagination = DataTable.ext.pager;

  function _numbers(page, pages) {
    var numbers = [],
        buttons = extPagination.numbers_length,
        half = Math.floor(buttons / 2),
        i = 1;

    if (pages <= buttons) {
      numbers = _range(0, pages);
    } else if (page <= half) {
      numbers = _range(0, buttons - 2);
      numbers.push('ellipsis');
      numbers.push(pages - 1);
    } else if (page >= pages - 1 - half) {
      numbers = _range(pages - (buttons - 2), pages);
      numbers.splice(0, 0, 'ellipsis'); // no unshift in ie6

      numbers.splice(0, 0, 0);
    } else {
      numbers = _range(page - half + 2, page + half - 1);
      numbers.push('ellipsis');
      numbers.push(pages - 1);
      numbers.splice(0, 0, 'ellipsis');
      numbers.splice(0, 0, 0);
    }

    numbers.DT_el = 'span';
    return numbers;
  }

  $.extend(extPagination, {
    simple: function simple(page, pages) {
      return ['previous', 'next'];
    },
    full: function full(page, pages) {
      return ['first', 'previous', 'next', 'last'];
    },
    numbers: function numbers(page, pages) {
      return [_numbers(page, pages)];
    },
    simple_numbers: function simple_numbers(page, pages) {
      return ['previous', _numbers(page, pages), 'next'];
    },
    full_numbers: function full_numbers(page, pages) {
      return ['first', 'previous', _numbers(page, pages), 'next', 'last'];
    },
    first_last_numbers: function first_last_numbers(page, pages) {
      return ['first', _numbers(page, pages), 'last'];
    },
    // For testing and plug-ins to use
    _numbers: _numbers,
    // Number of number buttons (including ellipsis) to show. _Must be odd!_
    numbers_length: 7
  });
  $.extend(true, DataTable.ext.renderer, {
    pageButton: {
      _: function _(settings, host, idx, buttons, page, pages) {
        var classes = settings.oClasses;
        var lang = settings.oLanguage.oPaginate;
        var aria = settings.oLanguage.oAria.paginate || {};
        var btnDisplay,
            btnClass,
            counter = 0;

        var attach = function attach(container, buttons) {
          var i, ien, node, button;

          var clickHandler = function clickHandler(e) {
            _fnPageChange(settings, e.data.action, true);
          };

          for (i = 0, ien = buttons.length; i < ien; i++) {
            button = buttons[i];

            if ($.isArray(button)) {
              var inner = $('<' + (button.DT_el || 'div') + '/>').appendTo(container);
              attach(inner, button);
            } else {
              btnDisplay = null;
              btnClass = '';

              switch (button) {
                case 'ellipsis':
                  container.append('<span class="ellipsis">&#x2026;</span>');
                  break;

                case 'first':
                  btnDisplay = lang.sFirst;
                  btnClass = button + (page > 0 ? '' : ' ' + classes.sPageButtonDisabled);
                  break;

                case 'previous':
                  btnDisplay = lang.sPrevious;
                  btnClass = button + (page > 0 ? '' : ' ' + classes.sPageButtonDisabled);
                  break;

                case 'next':
                  btnDisplay = lang.sNext;
                  btnClass = button + (page < pages - 1 ? '' : ' ' + classes.sPageButtonDisabled);
                  break;

                case 'last':
                  btnDisplay = lang.sLast;
                  btnClass = button + (page < pages - 1 ? '' : ' ' + classes.sPageButtonDisabled);
                  break;

                default:
                  btnDisplay = button + 1;
                  btnClass = page === button ? classes.sPageButtonActive : '';
                  break;
              }

              if (btnDisplay !== null) {
                node = $('<a>', {
                  'class': classes.sPageButton + ' ' + btnClass,
                  'aria-controls': settings.sTableId,
                  'aria-label': aria[button],
                  'data-dt-idx': counter,
                  'tabindex': settings.iTabIndex,
                  'id': idx === 0 && typeof button === 'string' ? settings.sTableId + '_' + button : null
                }).html(btnDisplay).appendTo(container);

                _fnBindAction(node, {
                  action: button
                }, clickHandler);

                counter++;
              }
            }
          }
        }; // IE9 throws an 'unknown error' if document.activeElement is used
        // inside an iframe or frame. Try / catch the error. Not good for
        // accessibility, but neither are frames.


        var activeEl;

        try {
          // Because this approach is destroying and recreating the paging
          // elements, focus is lost on the select button which is bad for
          // accessibility. So we want to restore focus once the draw has
          // completed
          activeEl = $(host).find(document.activeElement).data('dt-idx');
        } catch (e) {}

        attach($(host).empty(), buttons);

        if (activeEl !== undefined) {
          $(host).find('[data-dt-idx=' + activeEl + ']').focus();
        }
      }
    }
  }); // Built in type detection. See model.ext.aTypes for information about
  // what is required from this methods.

  $.extend(DataTable.ext.type.detect, [// Plain numbers - first since V8 detects some plain numbers as dates
  // e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).
  function (d, settings) {
    var decimal = settings.oLanguage.sDecimal;
    return _isNumber(d, decimal) ? 'num' + decimal : null;
  }, // Dates (only those recognised by the browser's Date.parse)
  function (d, settings) {
    // V8 tries _very_ hard to make a string passed into `Date.parse()`
    // valid, so we need to use a regex to restrict date formats. Use a
    // plug-in for anything other than ISO8601 style strings
    if (d && !(d instanceof Date) && !_re_date.test(d)) {
      return null;
    }

    var parsed = Date.parse(d);
    return parsed !== null && !isNaN(parsed) || _empty(d) ? 'date' : null;
  }, // Formatted numbers
  function (d, settings) {
    var decimal = settings.oLanguage.sDecimal;
    return _isNumber(d, decimal, true) ? 'num-fmt' + decimal : null;
  }, // HTML numeric
  function (d, settings) {
    var decimal = settings.oLanguage.sDecimal;
    return _htmlNumeric(d, decimal) ? 'html-num' + decimal : null;
  }, // HTML numeric, formatted
  function (d, settings) {
    var decimal = settings.oLanguage.sDecimal;
    return _htmlNumeric(d, decimal, true) ? 'html-num-fmt' + decimal : null;
  }, // HTML (this is strict checking - there must be html)
  function (d, settings) {
    return _empty(d) || typeof d === 'string' && d.indexOf('<') !== -1 ? 'html' : null;
  }]); // Filter formatting functions. See model.ext.ofnSearch for information about
  // what is required from these methods.
  // 
  // Note that additional search methods are added for the html numbers and
  // html formatted numbers by `_addNumericSort()` when we know what the decimal
  // place is

  $.extend(DataTable.ext.type.search, {
    html: function html(data) {
      return _empty(data) ? data : typeof data === 'string' ? data.replace(_re_new_lines, " ").replace(_re_html, "") : '';
    },
    string: function string(data) {
      return _empty(data) ? data : typeof data === 'string' ? data.replace(_re_new_lines, " ") : data;
    }
  });

  var __numericReplace = function __numericReplace(d, decimalPlace, re1, re2) {
    if (d !== 0 && (!d || d === '-')) {
      return -Infinity;
    } // If a decimal place other than `.` is used, it needs to be given to the
    // function so we can detect it and replace with a `.` which is the only
    // decimal place Javascript recognises - it is not locale aware.


    if (decimalPlace) {
      d = _numToDecimal(d, decimalPlace);
    }

    if (d.replace) {
      if (re1) {
        d = d.replace(re1, '');
      }

      if (re2) {
        d = d.replace(re2, '');
      }
    }

    return d * 1;
  }; // Add the numeric 'deformatting' functions for sorting and search. This is done
  // in a function to provide an easy ability for the language options to add
  // additional methods if a non-period decimal place is used.


  function _addNumericSort(decimalPlace) {
    $.each({
      // Plain numbers
      "num": function num(d) {
        return __numericReplace(d, decimalPlace);
      },
      // Formatted numbers
      "num-fmt": function numFmt(d) {
        return __numericReplace(d, decimalPlace, _re_formatted_numeric);
      },
      // HTML numeric
      "html-num": function htmlNum(d) {
        return __numericReplace(d, decimalPlace, _re_html);
      },
      // HTML numeric, formatted
      "html-num-fmt": function htmlNumFmt(d) {
        return __numericReplace(d, decimalPlace, _re_html, _re_formatted_numeric);
      }
    }, function (key, fn) {
      // Add the ordering method
      _ext.type.order[key + decimalPlace + '-pre'] = fn; // For HTML types add a search formatter that will strip the HTML

      if (key.match(/^html\-/)) {
        _ext.type.search[key + decimalPlace] = _ext.type.search.html;
      }
    });
  } // Default sort methods


  $.extend(_ext.type.order, {
    // Dates
    "date-pre": function datePre(d) {
      return Date.parse(d) || -Infinity;
    },
    // html
    "html-pre": function htmlPre(a) {
      return _empty(a) ? '' : a.replace ? a.replace(/<.*?>/g, "").toLowerCase() : a + '';
    },
    // string
    "string-pre": function stringPre(a) {
      // This is a little complex, but faster than always calling toString,
      // http://jsperf.com/tostring-v-check
      return _empty(a) ? '' : typeof a === 'string' ? a.toLowerCase() : !a.toString ? '' : a.toString();
    },
    // string-asc and -desc are retained only for compatibility with the old
    // sort methods
    "string-asc": function stringAsc(x, y) {
      return x < y ? -1 : x > y ? 1 : 0;
    },
    "string-desc": function stringDesc(x, y) {
      return x < y ? 1 : x > y ? -1 : 0;
    }
  }); // Numeric sorting types - order doesn't matter here

  _addNumericSort('');

  $.extend(true, DataTable.ext.renderer, {
    header: {
      _: function _(settings, cell, column, classes) {
        // No additional mark-up required
        // Attach a sort listener to update on sort - note that using the
        // `DT` namespace will allow the event to be removed automatically
        // on destroy, while the `dt` namespaced event is the one we are
        // listening for
        $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {
          if (settings !== ctx) {
            // need to check this this is the host
            return; // table, not a nested one
          }

          var colIdx = column.idx;
          cell.removeClass(column.sSortingClass + ' ' + classes.sSortAsc + ' ' + classes.sSortDesc).addClass(columns[colIdx] == 'asc' ? classes.sSortAsc : columns[colIdx] == 'desc' ? classes.sSortDesc : column.sSortingClass);
        });
      },
      jqueryui: function jqueryui(settings, cell, column, classes) {
        $('<div/>').addClass(classes.sSortJUIWrapper).append(cell.contents()).append($('<span/>').addClass(classes.sSortIcon + ' ' + column.sSortingClassJUI)).appendTo(cell); // Attach a sort listener to update on sort

        $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {
          if (settings !== ctx) {
            return;
          }

          var colIdx = column.idx;
          cell.removeClass(classes.sSortAsc + " " + classes.sSortDesc).addClass(columns[colIdx] == 'asc' ? classes.sSortAsc : columns[colIdx] == 'desc' ? classes.sSortDesc : column.sSortingClass);
          cell.find('span.' + classes.sSortIcon).removeClass(classes.sSortJUIAsc + " " + classes.sSortJUIDesc + " " + classes.sSortJUI + " " + classes.sSortJUIAscAllowed + " " + classes.sSortJUIDescAllowed).addClass(columns[colIdx] == 'asc' ? classes.sSortJUIAsc : columns[colIdx] == 'desc' ? classes.sSortJUIDesc : column.sSortingClassJUI);
        });
      }
    }
  });
  /*
   * Public helper functions. These aren't used internally by DataTables, or
   * called by any of the options passed into DataTables, but they can be used
   * externally by developers working with DataTables. They are helper functions
   * to make working with DataTables a little bit easier.
   */

  var __htmlEscapeEntities = function __htmlEscapeEntities(d) {
    return typeof d === 'string' ? d.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;') : d;
  };
  /**
   * Helpers for `columns.render`.
   *
   * The options defined here can be used with the `columns.render` initialisation
   * option to provide a display renderer. The following functions are defined:
   *
   * * `number` - Will format numeric data (defined by `columns.data`) for
   *   display, retaining the original unformatted data for sorting and filtering.
   *   It takes 5 parameters:
   *   * `string` - Thousands grouping separator
   *   * `string` - Decimal point indicator
   *   * `integer` - Number of decimal points to show
   *   * `string` (optional) - Prefix.
   *   * `string` (optional) - Postfix (/suffix).
   * * `text` - Escape HTML to help prevent XSS attacks. It has no optional
   *   parameters.
   *
   * @example
   *   // Column definition using the number renderer
   *   {
   *     data: "salary",
   *     render: $.fn.dataTable.render.number( '\'', '.', 0, '$' )
   *   }
   *
   * @namespace
   */


  DataTable.render = {
    number: function number(thousands, decimal, precision, prefix, postfix) {
      return {
        display: function display(d) {
          if (typeof d !== 'number' && typeof d !== 'string') {
            return d;
          }

          var negative = d < 0 ? '-' : '';
          var flo = parseFloat(d); // If NaN then there isn't much formatting that we can do - just
          // return immediately, escaping any HTML (this was supposed to
          // be a number after all)

          if (isNaN(flo)) {
            return __htmlEscapeEntities(d);
          }

          flo = flo.toFixed(precision);
          d = Math.abs(flo);
          var intPart = parseInt(d, 10);
          var floatPart = precision ? decimal + (d - intPart).toFixed(precision).substring(2) : '';
          return negative + (prefix || '') + intPart.toString().replace(/\B(?=(\d{3})+(?!\d))/g, thousands) + floatPart + (postfix || '');
        }
      };
    },
    text: function text() {
      return {
        display: __htmlEscapeEntities
      };
    }
  };
  /*
   * This is really a good bit rubbish this method of exposing the internal methods
   * publicly... - To be fixed in 2.0 using methods on the prototype
   */

  /**
   * Create a wrapper function for exporting an internal functions to an external API.
   *  @param {string} fn API function name
   *  @returns {function} wrapped function
   *  @memberof DataTable#internal
   */

  function _fnExternApiFunc(fn) {
    return function () {
      var args = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat(Array.prototype.slice.call(arguments));
      return DataTable.ext.internal[fn].apply(this, args);
    };
  }
  /**
   * Reference to internal functions for use by plug-in developers. Note that
   * these methods are references to internal functions and are considered to be
   * private. If you use these methods, be aware that they are liable to change
   * between versions.
   *  @namespace
   */


  $.extend(DataTable.ext.internal, {
    _fnExternApiFunc: _fnExternApiFunc,
    _fnBuildAjax: _fnBuildAjax,
    _fnAjaxUpdate: _fnAjaxUpdate,
    _fnAjaxParameters: _fnAjaxParameters,
    _fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
    _fnAjaxDataSrc: _fnAjaxDataSrc,
    _fnAddColumn: _fnAddColumn,
    _fnColumnOptions: _fnColumnOptions,
    _fnAdjustColumnSizing: _fnAdjustColumnSizing,
    _fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
    _fnColumnIndexToVisible: _fnColumnIndexToVisible,
    _fnVisbleColumns: _fnVisbleColumns,
    _fnGetColumns: _fnGetColumns,
    _fnColumnTypes: _fnColumnTypes,
    _fnApplyColumnDefs: _fnApplyColumnDefs,
    _fnHungarianMap: _fnHungarianMap,
    _fnCamelToHungarian: _fnCamelToHungarian,
    _fnLanguageCompat: _fnLanguageCompat,
    _fnBrowserDetect: _fnBrowserDetect,
    _fnAddData: _fnAddData,
    _fnAddTr: _fnAddTr,
    _fnNodeToDataIndex: _fnNodeToDataIndex,
    _fnNodeToColumnIndex: _fnNodeToColumnIndex,
    _fnGetCellData: _fnGetCellData,
    _fnSetCellData: _fnSetCellData,
    _fnSplitObjNotation: _fnSplitObjNotation,
    _fnGetObjectDataFn: _fnGetObjectDataFn,
    _fnSetObjectDataFn: _fnSetObjectDataFn,
    _fnGetDataMaster: _fnGetDataMaster,
    _fnClearTable: _fnClearTable,
    _fnDeleteIndex: _fnDeleteIndex,
    _fnInvalidate: _fnInvalidate,
    _fnGetRowElements: _fnGetRowElements,
    _fnCreateTr: _fnCreateTr,
    _fnBuildHead: _fnBuildHead,
    _fnDrawHead: _fnDrawHead,
    _fnDraw: _fnDraw,
    _fnReDraw: _fnReDraw,
    _fnAddOptionsHtml: _fnAddOptionsHtml,
    _fnDetectHeader: _fnDetectHeader,
    _fnGetUniqueThs: _fnGetUniqueThs,
    _fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
    _fnFilterComplete: _fnFilterComplete,
    _fnFilterCustom: _fnFilterCustom,
    _fnFilterColumn: _fnFilterColumn,
    _fnFilter: _fnFilter,
    _fnFilterCreateSearch: _fnFilterCreateSearch,
    _fnEscapeRegex: _fnEscapeRegex,
    _fnFilterData: _fnFilterData,
    _fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
    _fnUpdateInfo: _fnUpdateInfo,
    _fnInfoMacros: _fnInfoMacros,
    _fnInitialise: _fnInitialise,
    _fnInitComplete: _fnInitComplete,
    _fnLengthChange: _fnLengthChange,
    _fnFeatureHtmlLength: _fnFeatureHtmlLength,
    _fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
    _fnPageChange: _fnPageChange,
    _fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
    _fnProcessingDisplay: _fnProcessingDisplay,
    _fnFeatureHtmlTable: _fnFeatureHtmlTable,
    _fnScrollDraw: _fnScrollDraw,
    _fnApplyToChildren: _fnApplyToChildren,
    _fnCalculateColumnWidths: _fnCalculateColumnWidths,
    _fnThrottle: _fnThrottle,
    _fnConvertToWidth: _fnConvertToWidth,
    _fnGetWidestNode: _fnGetWidestNode,
    _fnGetMaxLenString: _fnGetMaxLenString,
    _fnStringToCss: _fnStringToCss,
    _fnSortFlatten: _fnSortFlatten,
    _fnSort: _fnSort,
    _fnSortAria: _fnSortAria,
    _fnSortListener: _fnSortListener,
    _fnSortAttachListener: _fnSortAttachListener,
    _fnSortingClasses: _fnSortingClasses,
    _fnSortData: _fnSortData,
    _fnSaveState: _fnSaveState,
    _fnLoadState: _fnLoadState,
    _fnSettingsFromNode: _fnSettingsFromNode,
    _fnLog: _fnLog,
    _fnMap: _fnMap,
    _fnBindAction: _fnBindAction,
    _fnCallbackReg: _fnCallbackReg,
    _fnCallbackFire: _fnCallbackFire,
    _fnLengthOverflow: _fnLengthOverflow,
    _fnRenderer: _fnRenderer,
    _fnDataSource: _fnDataSource,
    _fnRowAttributes: _fnRowAttributes,
    _fnCalculateEnd: function _fnCalculateEnd() {} // Used by a lot of plug-ins, but redundant
    // in 1.10, so this dead-end function is
    // added to prevent errors

  }); // jQuery access

  $.fn.dataTable = DataTable; // Provide access to the host jQuery object (circular reference)

  DataTable.$ = $; // Legacy aliases

  $.fn.dataTableSettings = DataTable.settings;
  $.fn.dataTableExt = DataTable.ext; // With a capital `D` we return a DataTables API instance rather than a
  // jQuery object

  $.fn.DataTable = function (opts) {
    return $(this).dataTable(opts).api();
  }; // All properties that are available to $.fn.dataTable should also be
  // available on $.fn.DataTable


  $.each(DataTable, function (prop, val) {
    $.fn.DataTable[prop] = val;
  }); // Information about events fired by DataTables - for documentation.

  /**
   * Draw event, fired whenever the table is redrawn on the page, at the same
   * point as fnDrawCallback. This may be useful for binding events or
   * performing calculations when the table is altered at all.
   *  @name DataTable#draw.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Search event, fired when the searching applied to the table (using the
   * built-in global search, or column filters) is altered.
   *  @name DataTable#search.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Page change event, fired when the paging of the table is altered.
   *  @name DataTable#page.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Order event, fired when the ordering applied to the table is altered.
   *  @name DataTable#order.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * DataTables initialisation complete event, fired when the table is fully
   * drawn, including Ajax data loaded, if Ajax data is required.
   *  @name DataTable#init.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The JSON object request from the server - only
   *    present if client-side Ajax sourced data is used</li></ol>
   */

  /**
   * State save event, fired when the table has changed state a new state save
   * is required. This event allows modification of the state saving object
   * prior to actually doing the save, including addition or other state
   * properties (for plug-ins) or modification of a DataTables core property.
   *  @name DataTable#stateSaveParams.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The state information to be saved
   */

  /**
   * State load event, fired when the table is loading state from the stored
   * data, but prior to the settings object being modified by the saved state
   * - allowing modification of the saved state is required or loading of
   * state for a plug-in.
   *  @name DataTable#stateLoadParams.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The saved state information
   */

  /**
   * State loaded event, fired when state has been loaded from stored data and
   * the settings object has been modified by the loaded data.
   *  @name DataTable#stateLoaded.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {object} json The saved state information
   */

  /**
   * Processing event, fired when DataTables is doing some kind of processing
   * (be it, order, searcg or anything else). It can be used to indicate to
   * the end user that there is something happening, or that something has
   * finished.
   *  @name DataTable#processing.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} oSettings DataTables settings object
   *  @param {boolean} bShow Flag for if DataTables is doing processing or not
   */

  /**
   * Ajax (XHR) event, fired whenever an Ajax request is completed from a
   * request to made to the server for new data. This event is called before
   * DataTables processed the returned data, so it can also be used to pre-
   * process the data returned from the server, if needed.
   *
   * Note that this trigger is called in `fnServerData`, if you override
   * `fnServerData` and which to use this event, you need to trigger it in you
   * success function.
   *  @name DataTable#xhr.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   *  @param {object} json JSON returned from the server
   *
   *  @example
   *     // Use a custom property returned from the server in another DOM element
   *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
   *       $('#status').html( json.status );
   *     } );
   *
   *  @example
   *     // Pre-process the data returned from the server
   *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
   *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {
   *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;
   *       }
   *       // Note no return - manipulate the data directly in the JSON object.
   *     } );
   */

  /**
   * Destroy event, fired when the DataTable is destroyed by calling fnDestroy
   * or passing the bDestroy:true parameter in the initialisation object. This
   * can be used to remove bound events, added DOM nodes, etc.
   *  @name DataTable#destroy.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Page length change event, fired when number of records to show on each
   * page (the length) is changed.
   *  @name DataTable#length.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   *  @param {integer} len New length
   */

  /**
   * Column sizing has changed.
   *  @name DataTable#column-sizing.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   */

  /**
   * Column visibility has changed.
   *  @name DataTable#column-visibility.dt
   *  @event
   *  @param {event} e jQuery event object
   *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
   *  @param {int} column Column index
   *  @param {bool} vis `false` if column now hidden, or `true` if visible
   */

  return $.fn.dataTable;
});

/***/ }),

/***/ "./resources/assets/js/off-canvas.js":
/*!*******************************************!*\
  !*** ./resources/assets/js/off-canvas.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {(function ($) {
  'use strict';

  $(function () {
    $('[data-toggle="offcanvas"]').on("click", function () {
      $('.sidebar-offcanvas').toggleClass('active');
    });
  });
})(jQuery);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./resources/assets/js/template.js":
/*!*****************************************!*\
  !*** ./resources/assets/js/template.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {(function ($) {
  'use strict';

  $(function () {
    var body = $('body');
    var contentWrapper = $('.content-wrapper');
    var scroller = $('.container-scroller');
    var footer = $('.footer');
    var sidebar = $('.sidebar'); //Add active class to nav-link based on url dynamically
    //Active class can be hard coded directly in html file also as required

    function addActiveClass(element) {
      if (current === "") {
        //for root url
        if (element.attr('href').indexOf("index.html") !== -1) {
          element.parents('.nav-item').last().addClass('active');

          if (element.parents('.sub-menu').length) {
            element.closest('.collapse').addClass('show');
            element.addClass('active');
          }
        }
      } else {
        //for other url
        if (element.attr('href').indexOf(current) !== -1) {
          element.parents('.nav-item').last().addClass('active');

          if (element.parents('.sub-menu').length) {
            element.closest('.collapse').addClass('show');
            element.addClass('active');
          }

          if (element.parents('.submenu-item').length) {
            element.addClass('active');
          }
        }
      }
    }

    var current = location.pathname.split("/").slice(-1)[0].replace(/^\/|\/$/g, '');
    $('.nav li a', sidebar).each(function () {
      var $this = $(this);
      addActiveClass($this);
    }); //Close other submenu in sidebar on opening any

    sidebar.on('show.bs.collapse', '.collapse', function () {
      sidebar.find('.collapse.show').collapse('hide');
    }); //Change sidebar

    $('[data-toggle="minimize"]').on("click", function () {
      body.toggleClass('sidebar-icon-only');
    }); //checkbox and radios

    $(".form-check label,.form-radio label").append('<i class="input-helper"></i>'); // Remove pro banner on close

    document.querySelector('#bannerClose').addEventListener('click', function () {
      document.querySelector('#proBanner').classList.add('d-none');
    });
  });
})(jQuery);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./resources/assets/vendors/base/vendor.bundle.base.js":
/*!*************************************************************!*\
  !*** ./resources/assets/vendors/base/vendor.bundle.base.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_0__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*! jQuery v3.4.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function (e, t) {
  "use strict";

  "object" == ( false ? undefined : _typeof(module)) && "object" == _typeof(module.exports) ? module.exports = e.document ? t(e, !0) : function (e) {
    if (!e.document) throw new Error("jQuery requires a window with a document");
    return t(e);
  } : t(e);
}("undefined" != typeof window ? window : this, function (C, e) {
  "use strict";

  var t = [],
      E = C.document,
      r = Object.getPrototypeOf,
      s = t.slice,
      g = t.concat,
      u = t.push,
      i = t.indexOf,
      n = {},
      o = n.toString,
      v = n.hasOwnProperty,
      a = v.toString,
      l = a.call(Object),
      y = {},
      m = function m(e) {
    return "function" == typeof e && "number" != typeof e.nodeType;
  },
      x = function x(e) {
    return null != e && e === e.window;
  },
      c = {
    type: !0,
    src: !0,
    nonce: !0,
    noModule: !0
  };

  function b(e, t, n) {
    var r,
        i,
        o = (n = n || E).createElement("script");
    if (o.text = e, t) for (r in c) {
      (i = t[r] || t.getAttribute && t.getAttribute(r)) && o.setAttribute(r, i);
    }
    n.head.appendChild(o).parentNode.removeChild(o);
  }

  function w(e) {
    return null == e ? e + "" : "object" == _typeof(e) || "function" == typeof e ? n[o.call(e)] || "object" : _typeof(e);
  }

  var f = "3.4.1",
      k = function k(e, t) {
    return new k.fn.init(e, t);
  },
      p = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

  function d(e) {
    var t = !!e && "length" in e && e.length,
        n = w(e);
    return !m(e) && !x(e) && ("array" === n || 0 === t || "number" == typeof t && 0 < t && t - 1 in e);
  }

  k.fn = k.prototype = {
    jquery: f,
    constructor: k,
    length: 0,
    toArray: function toArray() {
      return s.call(this);
    },
    get: function get(e) {
      return null == e ? s.call(this) : e < 0 ? this[e + this.length] : this[e];
    },
    pushStack: function pushStack(e) {
      var t = k.merge(this.constructor(), e);
      return t.prevObject = this, t;
    },
    each: function each(e) {
      return k.each(this, e);
    },
    map: function map(n) {
      return this.pushStack(k.map(this, function (e, t) {
        return n.call(e, t, e);
      }));
    },
    slice: function slice() {
      return this.pushStack(s.apply(this, arguments));
    },
    first: function first() {
      return this.eq(0);
    },
    last: function last() {
      return this.eq(-1);
    },
    eq: function eq(e) {
      var t = this.length,
          n = +e + (e < 0 ? t : 0);
      return this.pushStack(0 <= n && n < t ? [this[n]] : []);
    },
    end: function end() {
      return this.prevObject || this.constructor();
    },
    push: u,
    sort: t.sort,
    splice: t.splice
  }, k.extend = k.fn.extend = function () {
    var e,
        t,
        n,
        r,
        i,
        o,
        a = arguments[0] || {},
        s = 1,
        u = arguments.length,
        l = !1;

    for ("boolean" == typeof a && (l = a, a = arguments[s] || {}, s++), "object" == _typeof(a) || m(a) || (a = {}), s === u && (a = this, s--); s < u; s++) {
      if (null != (e = arguments[s])) for (t in e) {
        r = e[t], "__proto__" !== t && a !== r && (l && r && (k.isPlainObject(r) || (i = Array.isArray(r))) ? (n = a[t], o = i && !Array.isArray(n) ? [] : i || k.isPlainObject(n) ? n : {}, i = !1, a[t] = k.extend(l, o, r)) : void 0 !== r && (a[t] = r));
      }
    }

    return a;
  }, k.extend({
    expando: "jQuery" + (f + Math.random()).replace(/\D/g, ""),
    isReady: !0,
    error: function error(e) {
      throw new Error(e);
    },
    noop: function noop() {},
    isPlainObject: function isPlainObject(e) {
      var t, n;
      return !(!e || "[object Object]" !== o.call(e)) && (!(t = r(e)) || "function" == typeof (n = v.call(t, "constructor") && t.constructor) && a.call(n) === l);
    },
    isEmptyObject: function isEmptyObject(e) {
      var t;

      for (t in e) {
        return !1;
      }

      return !0;
    },
    globalEval: function globalEval(e, t) {
      b(e, {
        nonce: t && t.nonce
      });
    },
    each: function each(e, t) {
      var n,
          r = 0;

      if (d(e)) {
        for (n = e.length; r < n; r++) {
          if (!1 === t.call(e[r], r, e[r])) break;
        }
      } else for (r in e) {
        if (!1 === t.call(e[r], r, e[r])) break;
      }

      return e;
    },
    trim: function trim(e) {
      return null == e ? "" : (e + "").replace(p, "");
    },
    makeArray: function makeArray(e, t) {
      var n = t || [];
      return null != e && (d(Object(e)) ? k.merge(n, "string" == typeof e ? [e] : e) : u.call(n, e)), n;
    },
    inArray: function inArray(e, t, n) {
      return null == t ? -1 : i.call(t, e, n);
    },
    merge: function merge(e, t) {
      for (var n = +t.length, r = 0, i = e.length; r < n; r++) {
        e[i++] = t[r];
      }

      return e.length = i, e;
    },
    grep: function grep(e, t, n) {
      for (var r = [], i = 0, o = e.length, a = !n; i < o; i++) {
        !t(e[i], i) !== a && r.push(e[i]);
      }

      return r;
    },
    map: function map(e, t, n) {
      var r,
          i,
          o = 0,
          a = [];
      if (d(e)) for (r = e.length; o < r; o++) {
        null != (i = t(e[o], o, n)) && a.push(i);
      } else for (o in e) {
        null != (i = t(e[o], o, n)) && a.push(i);
      }
      return g.apply([], a);
    },
    guid: 1,
    support: y
  }), "function" == typeof Symbol && (k.fn[Symbol.iterator] = t[Symbol.iterator]), k.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (e, t) {
    n["[object " + t + "]"] = t.toLowerCase();
  });

  var h = function (n) {
    var e,
        d,
        b,
        o,
        i,
        h,
        f,
        g,
        w,
        u,
        l,
        T,
        C,
        a,
        E,
        v,
        s,
        c,
        y,
        k = "sizzle" + 1 * new Date(),
        m = n.document,
        S = 0,
        r = 0,
        p = ue(),
        x = ue(),
        N = ue(),
        A = ue(),
        D = function D(e, t) {
      return e === t && (l = !0), 0;
    },
        j = {}.hasOwnProperty,
        t = [],
        q = t.pop,
        L = t.push,
        H = t.push,
        O = t.slice,
        P = function P(e, t) {
      for (var n = 0, r = e.length; n < r; n++) {
        if (e[n] === t) return n;
      }

      return -1;
    },
        R = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        M = "[\\x20\\t\\r\\n\\f]",
        I = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
        W = "\\[" + M + "*(" + I + ")(?:" + M + "*([*^$|!~]?=)" + M + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + I + "))|)" + M + "*\\]",
        $ = ":(" + I + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + W + ")*)|.*)\\)|)",
        F = new RegExp(M + "+", "g"),
        B = new RegExp("^" + M + "+|((?:^|[^\\\\])(?:\\\\.)*)" + M + "+$", "g"),
        _ = new RegExp("^" + M + "*," + M + "*"),
        z = new RegExp("^" + M + "*([>+~]|" + M + ")" + M + "*"),
        U = new RegExp(M + "|>"),
        X = new RegExp($),
        V = new RegExp("^" + I + "$"),
        G = {
      ID: new RegExp("^#(" + I + ")"),
      CLASS: new RegExp("^\\.(" + I + ")"),
      TAG: new RegExp("^(" + I + "|[*])"),
      ATTR: new RegExp("^" + W),
      PSEUDO: new RegExp("^" + $),
      CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + M + "*(even|odd|(([+-]|)(\\d*)n|)" + M + "*(?:([+-]|)" + M + "*(\\d+)|))" + M + "*\\)|)", "i"),
      bool: new RegExp("^(?:" + R + ")$", "i"),
      needsContext: new RegExp("^" + M + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + M + "*((?:-\\d)?\\d*)" + M + "*\\)|)(?=[^-]|$)", "i")
    },
        Y = /HTML$/i,
        Q = /^(?:input|select|textarea|button)$/i,
        J = /^h\d$/i,
        K = /^[^{]+\{\s*\[native \w/,
        Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        ee = /[+~]/,
        te = new RegExp("\\\\([\\da-f]{1,6}" + M + "?|(" + M + ")|.)", "ig"),
        ne = function ne(e, t, n) {
      var r = "0x" + t - 65536;
      return r != r || n ? t : r < 0 ? String.fromCharCode(r + 65536) : String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320);
    },
        re = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
        ie = function ie(e, t) {
      return t ? "\0" === e ? "\uFFFD" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e;
    },
        oe = function oe() {
      T();
    },
        ae = be(function (e) {
      return !0 === e.disabled && "fieldset" === e.nodeName.toLowerCase();
    }, {
      dir: "parentNode",
      next: "legend"
    });

    try {
      H.apply(t = O.call(m.childNodes), m.childNodes), t[m.childNodes.length].nodeType;
    } catch (e) {
      H = {
        apply: t.length ? function (e, t) {
          L.apply(e, O.call(t));
        } : function (e, t) {
          var n = e.length,
              r = 0;

          while (e[n++] = t[r++]) {
            ;
          }

          e.length = n - 1;
        }
      };
    }

    function se(t, e, n, r) {
      var i,
          o,
          a,
          s,
          u,
          l,
          c,
          f = e && e.ownerDocument,
          p = e ? e.nodeType : 9;
      if (n = n || [], "string" != typeof t || !t || 1 !== p && 9 !== p && 11 !== p) return n;

      if (!r && ((e ? e.ownerDocument || e : m) !== C && T(e), e = e || C, E)) {
        if (11 !== p && (u = Z.exec(t))) if (i = u[1]) {
          if (9 === p) {
            if (!(a = e.getElementById(i))) return n;
            if (a.id === i) return n.push(a), n;
          } else if (f && (a = f.getElementById(i)) && y(e, a) && a.id === i) return n.push(a), n;
        } else {
          if (u[2]) return H.apply(n, e.getElementsByTagName(t)), n;
          if ((i = u[3]) && d.getElementsByClassName && e.getElementsByClassName) return H.apply(n, e.getElementsByClassName(i)), n;
        }

        if (d.qsa && !A[t + " "] && (!v || !v.test(t)) && (1 !== p || "object" !== e.nodeName.toLowerCase())) {
          if (c = t, f = e, 1 === p && U.test(t)) {
            (s = e.getAttribute("id")) ? s = s.replace(re, ie) : e.setAttribute("id", s = k), o = (l = h(t)).length;

            while (o--) {
              l[o] = "#" + s + " " + xe(l[o]);
            }

            c = l.join(","), f = ee.test(t) && ye(e.parentNode) || e;
          }

          try {
            return H.apply(n, f.querySelectorAll(c)), n;
          } catch (e) {
            A(t, !0);
          } finally {
            s === k && e.removeAttribute("id");
          }
        }
      }

      return g(t.replace(B, "$1"), e, n, r);
    }

    function ue() {
      var r = [];
      return function e(t, n) {
        return r.push(t + " ") > b.cacheLength && delete e[r.shift()], e[t + " "] = n;
      };
    }

    function le(e) {
      return e[k] = !0, e;
    }

    function ce(e) {
      var t = C.createElement("fieldset");

      try {
        return !!e(t);
      } catch (e) {
        return !1;
      } finally {
        t.parentNode && t.parentNode.removeChild(t), t = null;
      }
    }

    function fe(e, t) {
      var n = e.split("|"),
          r = n.length;

      while (r--) {
        b.attrHandle[n[r]] = t;
      }
    }

    function pe(e, t) {
      var n = t && e,
          r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
      if (r) return r;
      if (n) while (n = n.nextSibling) {
        if (n === t) return -1;
      }
      return e ? 1 : -1;
    }

    function de(t) {
      return function (e) {
        return "input" === e.nodeName.toLowerCase() && e.type === t;
      };
    }

    function he(n) {
      return function (e) {
        var t = e.nodeName.toLowerCase();
        return ("input" === t || "button" === t) && e.type === n;
      };
    }

    function ge(t) {
      return function (e) {
        return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && ae(e) === t : e.disabled === t : "label" in e && e.disabled === t;
      };
    }

    function ve(a) {
      return le(function (o) {
        return o = +o, le(function (e, t) {
          var n,
              r = a([], e.length, o),
              i = r.length;

          while (i--) {
            e[n = r[i]] && (e[n] = !(t[n] = e[n]));
          }
        });
      });
    }

    function ye(e) {
      return e && "undefined" != typeof e.getElementsByTagName && e;
    }

    for (e in d = se.support = {}, i = se.isXML = function (e) {
      var t = e.namespaceURI,
          n = (e.ownerDocument || e).documentElement;
      return !Y.test(t || n && n.nodeName || "HTML");
    }, T = se.setDocument = function (e) {
      var t,
          n,
          r = e ? e.ownerDocument || e : m;
      return r !== C && 9 === r.nodeType && r.documentElement && (a = (C = r).documentElement, E = !i(C), m !== C && (n = C.defaultView) && n.top !== n && (n.addEventListener ? n.addEventListener("unload", oe, !1) : n.attachEvent && n.attachEvent("onunload", oe)), d.attributes = ce(function (e) {
        return e.className = "i", !e.getAttribute("className");
      }), d.getElementsByTagName = ce(function (e) {
        return e.appendChild(C.createComment("")), !e.getElementsByTagName("*").length;
      }), d.getElementsByClassName = K.test(C.getElementsByClassName), d.getById = ce(function (e) {
        return a.appendChild(e).id = k, !C.getElementsByName || !C.getElementsByName(k).length;
      }), d.getById ? (b.filter.ID = function (e) {
        var t = e.replace(te, ne);
        return function (e) {
          return e.getAttribute("id") === t;
        };
      }, b.find.ID = function (e, t) {
        if ("undefined" != typeof t.getElementById && E) {
          var n = t.getElementById(e);
          return n ? [n] : [];
        }
      }) : (b.filter.ID = function (e) {
        var n = e.replace(te, ne);
        return function (e) {
          var t = "undefined" != typeof e.getAttributeNode && e.getAttributeNode("id");
          return t && t.value === n;
        };
      }, b.find.ID = function (e, t) {
        if ("undefined" != typeof t.getElementById && E) {
          var n,
              r,
              i,
              o = t.getElementById(e);

          if (o) {
            if ((n = o.getAttributeNode("id")) && n.value === e) return [o];
            i = t.getElementsByName(e), r = 0;

            while (o = i[r++]) {
              if ((n = o.getAttributeNode("id")) && n.value === e) return [o];
            }
          }

          return [];
        }
      }), b.find.TAG = d.getElementsByTagName ? function (e, t) {
        return "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : d.qsa ? t.querySelectorAll(e) : void 0;
      } : function (e, t) {
        var n,
            r = [],
            i = 0,
            o = t.getElementsByTagName(e);

        if ("*" === e) {
          while (n = o[i++]) {
            1 === n.nodeType && r.push(n);
          }

          return r;
        }

        return o;
      }, b.find.CLASS = d.getElementsByClassName && function (e, t) {
        if ("undefined" != typeof t.getElementsByClassName && E) return t.getElementsByClassName(e);
      }, s = [], v = [], (d.qsa = K.test(C.querySelectorAll)) && (ce(function (e) {
        a.appendChild(e).innerHTML = "<a id='" + k + "'></a><select id='" + k + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && v.push("[*^$]=" + M + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || v.push("\\[" + M + "*(?:value|" + R + ")"), e.querySelectorAll("[id~=" + k + "-]").length || v.push("~="), e.querySelectorAll(":checked").length || v.push(":checked"), e.querySelectorAll("a#" + k + "+*").length || v.push(".#.+[+~]");
      }), ce(function (e) {
        e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
        var t = C.createElement("input");
        t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && v.push("name" + M + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && v.push(":enabled", ":disabled"), a.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && v.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), v.push(",.*:");
      })), (d.matchesSelector = K.test(c = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && ce(function (e) {
        d.disconnectedMatch = c.call(e, "*"), c.call(e, "[s!='']:x"), s.push("!=", $);
      }), v = v.length && new RegExp(v.join("|")), s = s.length && new RegExp(s.join("|")), t = K.test(a.compareDocumentPosition), y = t || K.test(a.contains) ? function (e, t) {
        var n = 9 === e.nodeType ? e.documentElement : e,
            r = t && t.parentNode;
        return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)));
      } : function (e, t) {
        if (t) while (t = t.parentNode) {
          if (t === e) return !0;
        }
        return !1;
      }, D = t ? function (e, t) {
        if (e === t) return l = !0, 0;
        var n = !e.compareDocumentPosition - !t.compareDocumentPosition;
        return n || (1 & (n = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !d.sortDetached && t.compareDocumentPosition(e) === n ? e === C || e.ownerDocument === m && y(m, e) ? -1 : t === C || t.ownerDocument === m && y(m, t) ? 1 : u ? P(u, e) - P(u, t) : 0 : 4 & n ? -1 : 1);
      } : function (e, t) {
        if (e === t) return l = !0, 0;
        var n,
            r = 0,
            i = e.parentNode,
            o = t.parentNode,
            a = [e],
            s = [t];
        if (!i || !o) return e === C ? -1 : t === C ? 1 : i ? -1 : o ? 1 : u ? P(u, e) - P(u, t) : 0;
        if (i === o) return pe(e, t);
        n = e;

        while (n = n.parentNode) {
          a.unshift(n);
        }

        n = t;

        while (n = n.parentNode) {
          s.unshift(n);
        }

        while (a[r] === s[r]) {
          r++;
        }

        return r ? pe(a[r], s[r]) : a[r] === m ? -1 : s[r] === m ? 1 : 0;
      }), C;
    }, se.matches = function (e, t) {
      return se(e, null, null, t);
    }, se.matchesSelector = function (e, t) {
      if ((e.ownerDocument || e) !== C && T(e), d.matchesSelector && E && !A[t + " "] && (!s || !s.test(t)) && (!v || !v.test(t))) try {
        var n = c.call(e, t);
        if (n || d.disconnectedMatch || e.document && 11 !== e.document.nodeType) return n;
      } catch (e) {
        A(t, !0);
      }
      return 0 < se(t, C, null, [e]).length;
    }, se.contains = function (e, t) {
      return (e.ownerDocument || e) !== C && T(e), y(e, t);
    }, se.attr = function (e, t) {
      (e.ownerDocument || e) !== C && T(e);
      var n = b.attrHandle[t.toLowerCase()],
          r = n && j.call(b.attrHandle, t.toLowerCase()) ? n(e, t, !E) : void 0;
      return void 0 !== r ? r : d.attributes || !E ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null;
    }, se.escape = function (e) {
      return (e + "").replace(re, ie);
    }, se.error = function (e) {
      throw new Error("Syntax error, unrecognized expression: " + e);
    }, se.uniqueSort = function (e) {
      var t,
          n = [],
          r = 0,
          i = 0;

      if (l = !d.detectDuplicates, u = !d.sortStable && e.slice(0), e.sort(D), l) {
        while (t = e[i++]) {
          t === e[i] && (r = n.push(i));
        }

        while (r--) {
          e.splice(n[r], 1);
        }
      }

      return u = null, e;
    }, o = se.getText = function (e) {
      var t,
          n = "",
          r = 0,
          i = e.nodeType;

      if (i) {
        if (1 === i || 9 === i || 11 === i) {
          if ("string" == typeof e.textContent) return e.textContent;

          for (e = e.firstChild; e; e = e.nextSibling) {
            n += o(e);
          }
        } else if (3 === i || 4 === i) return e.nodeValue;
      } else while (t = e[r++]) {
        n += o(t);
      }

      return n;
    }, (b = se.selectors = {
      cacheLength: 50,
      createPseudo: le,
      match: G,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: !0
        },
        " ": {
          dir: "parentNode"
        },
        "+": {
          dir: "previousSibling",
          first: !0
        },
        "~": {
          dir: "previousSibling"
        }
      },
      preFilter: {
        ATTR: function ATTR(e) {
          return e[1] = e[1].replace(te, ne), e[3] = (e[3] || e[4] || e[5] || "").replace(te, ne), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4);
        },
        CHILD: function CHILD(e) {
          return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || se.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && se.error(e[0]), e;
        },
        PSEUDO: function PSEUDO(e) {
          var t,
              n = !e[6] && e[2];
          return G.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && X.test(n) && (t = h(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3));
        }
      },
      filter: {
        TAG: function TAG(e) {
          var t = e.replace(te, ne).toLowerCase();
          return "*" === e ? function () {
            return !0;
          } : function (e) {
            return e.nodeName && e.nodeName.toLowerCase() === t;
          };
        },
        CLASS: function CLASS(e) {
          var t = p[e + " "];
          return t || (t = new RegExp("(^|" + M + ")" + e + "(" + M + "|$)")) && p(e, function (e) {
            return t.test("string" == typeof e.className && e.className || "undefined" != typeof e.getAttribute && e.getAttribute("class") || "");
          });
        },
        ATTR: function ATTR(n, r, i) {
          return function (e) {
            var t = se.attr(e, n);
            return null == t ? "!=" === r : !r || (t += "", "=" === r ? t === i : "!=" === r ? t !== i : "^=" === r ? i && 0 === t.indexOf(i) : "*=" === r ? i && -1 < t.indexOf(i) : "$=" === r ? i && t.slice(-i.length) === i : "~=" === r ? -1 < (" " + t.replace(F, " ") + " ").indexOf(i) : "|=" === r && (t === i || t.slice(0, i.length + 1) === i + "-"));
          };
        },
        CHILD: function CHILD(h, e, t, g, v) {
          var y = "nth" !== h.slice(0, 3),
              m = "last" !== h.slice(-4),
              x = "of-type" === e;
          return 1 === g && 0 === v ? function (e) {
            return !!e.parentNode;
          } : function (e, t, n) {
            var r,
                i,
                o,
                a,
                s,
                u,
                l = y !== m ? "nextSibling" : "previousSibling",
                c = e.parentNode,
                f = x && e.nodeName.toLowerCase(),
                p = !n && !x,
                d = !1;

            if (c) {
              if (y) {
                while (l) {
                  a = e;

                  while (a = a[l]) {
                    if (x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) return !1;
                  }

                  u = l = "only" === h && !u && "nextSibling";
                }

                return !0;
              }

              if (u = [m ? c.firstChild : c.lastChild], m && p) {
                d = (s = (r = (i = (o = (a = c)[k] || (a[k] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === S && r[1]) && r[2], a = s && c.childNodes[s];

                while (a = ++s && a && a[l] || (d = s = 0) || u.pop()) {
                  if (1 === a.nodeType && ++d && a === e) {
                    i[h] = [S, s, d];
                    break;
                  }
                }
              } else if (p && (d = s = (r = (i = (o = (a = e)[k] || (a[k] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === S && r[1]), !1 === d) while (a = ++s && a && a[l] || (d = s = 0) || u.pop()) {
                if ((x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) && ++d && (p && ((i = (o = a[k] || (a[k] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] = [S, d]), a === e)) break;
              }

              return (d -= v) === g || d % g == 0 && 0 <= d / g;
            }
          };
        },
        PSEUDO: function PSEUDO(e, o) {
          var t,
              a = b.pseudos[e] || b.setFilters[e.toLowerCase()] || se.error("unsupported pseudo: " + e);
          return a[k] ? a(o) : 1 < a.length ? (t = [e, e, "", o], b.setFilters.hasOwnProperty(e.toLowerCase()) ? le(function (e, t) {
            var n,
                r = a(e, o),
                i = r.length;

            while (i--) {
              e[n = P(e, r[i])] = !(t[n] = r[i]);
            }
          }) : function (e) {
            return a(e, 0, t);
          }) : a;
        }
      },
      pseudos: {
        not: le(function (e) {
          var r = [],
              i = [],
              s = f(e.replace(B, "$1"));
          return s[k] ? le(function (e, t, n, r) {
            var i,
                o = s(e, null, r, []),
                a = e.length;

            while (a--) {
              (i = o[a]) && (e[a] = !(t[a] = i));
            }
          }) : function (e, t, n) {
            return r[0] = e, s(r, null, n, i), r[0] = null, !i.pop();
          };
        }),
        has: le(function (t) {
          return function (e) {
            return 0 < se(t, e).length;
          };
        }),
        contains: le(function (t) {
          return t = t.replace(te, ne), function (e) {
            return -1 < (e.textContent || o(e)).indexOf(t);
          };
        }),
        lang: le(function (n) {
          return V.test(n || "") || se.error("unsupported lang: " + n), n = n.replace(te, ne).toLowerCase(), function (e) {
            var t;

            do {
              if (t = E ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (t = t.toLowerCase()) === n || 0 === t.indexOf(n + "-");
            } while ((e = e.parentNode) && 1 === e.nodeType);

            return !1;
          };
        }),
        target: function target(e) {
          var t = n.location && n.location.hash;
          return t && t.slice(1) === e.id;
        },
        root: function root(e) {
          return e === a;
        },
        focus: function focus(e) {
          return e === C.activeElement && (!C.hasFocus || C.hasFocus()) && !!(e.type || e.href || ~e.tabIndex);
        },
        enabled: ge(!1),
        disabled: ge(!0),
        checked: function checked(e) {
          var t = e.nodeName.toLowerCase();
          return "input" === t && !!e.checked || "option" === t && !!e.selected;
        },
        selected: function selected(e) {
          return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected;
        },
        empty: function empty(e) {
          for (e = e.firstChild; e; e = e.nextSibling) {
            if (e.nodeType < 6) return !1;
          }

          return !0;
        },
        parent: function parent(e) {
          return !b.pseudos.empty(e);
        },
        header: function header(e) {
          return J.test(e.nodeName);
        },
        input: function input(e) {
          return Q.test(e.nodeName);
        },
        button: function button(e) {
          var t = e.nodeName.toLowerCase();
          return "input" === t && "button" === e.type || "button" === t;
        },
        text: function text(e) {
          var t;
          return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase());
        },
        first: ve(function () {
          return [0];
        }),
        last: ve(function (e, t) {
          return [t - 1];
        }),
        eq: ve(function (e, t, n) {
          return [n < 0 ? n + t : n];
        }),
        even: ve(function (e, t) {
          for (var n = 0; n < t; n += 2) {
            e.push(n);
          }

          return e;
        }),
        odd: ve(function (e, t) {
          for (var n = 1; n < t; n += 2) {
            e.push(n);
          }

          return e;
        }),
        lt: ve(function (e, t, n) {
          for (var r = n < 0 ? n + t : t < n ? t : n; 0 <= --r;) {
            e.push(r);
          }

          return e;
        }),
        gt: ve(function (e, t, n) {
          for (var r = n < 0 ? n + t : n; ++r < t;) {
            e.push(r);
          }

          return e;
        })
      }
    }).pseudos.nth = b.pseudos.eq, {
      radio: !0,
      checkbox: !0,
      file: !0,
      password: !0,
      image: !0
    }) {
      b.pseudos[e] = de(e);
    }

    for (e in {
      submit: !0,
      reset: !0
    }) {
      b.pseudos[e] = he(e);
    }

    function me() {}

    function xe(e) {
      for (var t = 0, n = e.length, r = ""; t < n; t++) {
        r += e[t].value;
      }

      return r;
    }

    function be(s, e, t) {
      var u = e.dir,
          l = e.next,
          c = l || u,
          f = t && "parentNode" === c,
          p = r++;
      return e.first ? function (e, t, n) {
        while (e = e[u]) {
          if (1 === e.nodeType || f) return s(e, t, n);
        }

        return !1;
      } : function (e, t, n) {
        var r,
            i,
            o,
            a = [S, p];

        if (n) {
          while (e = e[u]) {
            if ((1 === e.nodeType || f) && s(e, t, n)) return !0;
          }
        } else while (e = e[u]) {
          if (1 === e.nodeType || f) if (i = (o = e[k] || (e[k] = {}))[e.uniqueID] || (o[e.uniqueID] = {}), l && l === e.nodeName.toLowerCase()) e = e[u] || e;else {
            if ((r = i[c]) && r[0] === S && r[1] === p) return a[2] = r[2];
            if ((i[c] = a)[2] = s(e, t, n)) return !0;
          }
        }

        return !1;
      };
    }

    function we(i) {
      return 1 < i.length ? function (e, t, n) {
        var r = i.length;

        while (r--) {
          if (!i[r](e, t, n)) return !1;
        }

        return !0;
      } : i[0];
    }

    function Te(e, t, n, r, i) {
      for (var o, a = [], s = 0, u = e.length, l = null != t; s < u; s++) {
        (o = e[s]) && (n && !n(o, r, i) || (a.push(o), l && t.push(s)));
      }

      return a;
    }

    function Ce(d, h, g, v, y, e) {
      return v && !v[k] && (v = Ce(v)), y && !y[k] && (y = Ce(y, e)), le(function (e, t, n, r) {
        var i,
            o,
            a,
            s = [],
            u = [],
            l = t.length,
            c = e || function (e, t, n) {
          for (var r = 0, i = t.length; r < i; r++) {
            se(e, t[r], n);
          }

          return n;
        }(h || "*", n.nodeType ? [n] : n, []),
            f = !d || !e && h ? c : Te(c, s, d, n, r),
            p = g ? y || (e ? d : l || v) ? [] : t : f;

        if (g && g(f, p, n, r), v) {
          i = Te(p, u), v(i, [], n, r), o = i.length;

          while (o--) {
            (a = i[o]) && (p[u[o]] = !(f[u[o]] = a));
          }
        }

        if (e) {
          if (y || d) {
            if (y) {
              i = [], o = p.length;

              while (o--) {
                (a = p[o]) && i.push(f[o] = a);
              }

              y(null, p = [], i, r);
            }

            o = p.length;

            while (o--) {
              (a = p[o]) && -1 < (i = y ? P(e, a) : s[o]) && (e[i] = !(t[i] = a));
            }
          }
        } else p = Te(p === t ? p.splice(l, p.length) : p), y ? y(null, t, p, r) : H.apply(t, p);
      });
    }

    function Ee(e) {
      for (var i, t, n, r = e.length, o = b.relative[e[0].type], a = o || b.relative[" "], s = o ? 1 : 0, u = be(function (e) {
        return e === i;
      }, a, !0), l = be(function (e) {
        return -1 < P(i, e);
      }, a, !0), c = [function (e, t, n) {
        var r = !o && (n || t !== w) || ((i = t).nodeType ? u(e, t, n) : l(e, t, n));
        return i = null, r;
      }]; s < r; s++) {
        if (t = b.relative[e[s].type]) c = [be(we(c), t)];else {
          if ((t = b.filter[e[s].type].apply(null, e[s].matches))[k]) {
            for (n = ++s; n < r; n++) {
              if (b.relative[e[n].type]) break;
            }

            return Ce(1 < s && we(c), 1 < s && xe(e.slice(0, s - 1).concat({
              value: " " === e[s - 2].type ? "*" : ""
            })).replace(B, "$1"), t, s < n && Ee(e.slice(s, n)), n < r && Ee(e = e.slice(n)), n < r && xe(e));
          }

          c.push(t);
        }
      }

      return we(c);
    }

    return me.prototype = b.filters = b.pseudos, b.setFilters = new me(), h = se.tokenize = function (e, t) {
      var n,
          r,
          i,
          o,
          a,
          s,
          u,
          l = x[e + " "];
      if (l) return t ? 0 : l.slice(0);
      a = e, s = [], u = b.preFilter;

      while (a) {
        for (o in n && !(r = _.exec(a)) || (r && (a = a.slice(r[0].length) || a), s.push(i = [])), n = !1, (r = z.exec(a)) && (n = r.shift(), i.push({
          value: n,
          type: r[0].replace(B, " ")
        }), a = a.slice(n.length)), b.filter) {
          !(r = G[o].exec(a)) || u[o] && !(r = u[o](r)) || (n = r.shift(), i.push({
            value: n,
            type: o,
            matches: r
          }), a = a.slice(n.length));
        }

        if (!n) break;
      }

      return t ? a.length : a ? se.error(e) : x(e, s).slice(0);
    }, f = se.compile = function (e, t) {
      var n,
          v,
          y,
          m,
          x,
          r,
          i = [],
          o = [],
          a = N[e + " "];

      if (!a) {
        t || (t = h(e)), n = t.length;

        while (n--) {
          (a = Ee(t[n]))[k] ? i.push(a) : o.push(a);
        }

        (a = N(e, (v = o, m = 0 < (y = i).length, x = 0 < v.length, r = function r(e, t, n, _r, i) {
          var o,
              a,
              s,
              u = 0,
              l = "0",
              c = e && [],
              f = [],
              p = w,
              d = e || x && b.find.TAG("*", i),
              h = S += null == p ? 1 : Math.random() || .1,
              g = d.length;

          for (i && (w = t === C || t || i); l !== g && null != (o = d[l]); l++) {
            if (x && o) {
              a = 0, t || o.ownerDocument === C || (T(o), n = !E);

              while (s = v[a++]) {
                if (s(o, t || C, n)) {
                  _r.push(o);

                  break;
                }
              }

              i && (S = h);
            }

            m && ((o = !s && o) && u--, e && c.push(o));
          }

          if (u += l, m && l !== u) {
            a = 0;

            while (s = y[a++]) {
              s(c, f, t, n);
            }

            if (e) {
              if (0 < u) while (l--) {
                c[l] || f[l] || (f[l] = q.call(_r));
              }
              f = Te(f);
            }

            H.apply(_r, f), i && !e && 0 < f.length && 1 < u + y.length && se.uniqueSort(_r);
          }

          return i && (S = h, w = p), c;
        }, m ? le(r) : r))).selector = e;
      }

      return a;
    }, g = se.select = function (e, t, n, r) {
      var i,
          o,
          a,
          s,
          u,
          l = "function" == typeof e && e,
          c = !r && h(e = l.selector || e);

      if (n = n || [], 1 === c.length) {
        if (2 < (o = c[0] = c[0].slice(0)).length && "ID" === (a = o[0]).type && 9 === t.nodeType && E && b.relative[o[1].type]) {
          if (!(t = (b.find.ID(a.matches[0].replace(te, ne), t) || [])[0])) return n;
          l && (t = t.parentNode), e = e.slice(o.shift().value.length);
        }

        i = G.needsContext.test(e) ? 0 : o.length;

        while (i--) {
          if (a = o[i], b.relative[s = a.type]) break;

          if ((u = b.find[s]) && (r = u(a.matches[0].replace(te, ne), ee.test(o[0].type) && ye(t.parentNode) || t))) {
            if (o.splice(i, 1), !(e = r.length && xe(o))) return H.apply(n, r), n;
            break;
          }
        }
      }

      return (l || f(e, c))(r, t, !E, n, !t || ee.test(e) && ye(t.parentNode) || t), n;
    }, d.sortStable = k.split("").sort(D).join("") === k, d.detectDuplicates = !!l, T(), d.sortDetached = ce(function (e) {
      return 1 & e.compareDocumentPosition(C.createElement("fieldset"));
    }), ce(function (e) {
      return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href");
    }) || fe("type|href|height|width", function (e, t, n) {
      if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2);
    }), d.attributes && ce(function (e) {
      return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value");
    }) || fe("value", function (e, t, n) {
      if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue;
    }), ce(function (e) {
      return null == e.getAttribute("disabled");
    }) || fe(R, function (e, t, n) {
      var r;
      if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null;
    }), se;
  }(C);

  k.find = h, k.expr = h.selectors, k.expr[":"] = k.expr.pseudos, k.uniqueSort = k.unique = h.uniqueSort, k.text = h.getText, k.isXMLDoc = h.isXML, k.contains = h.contains, k.escapeSelector = h.escape;

  var T = function T(e, t, n) {
    var r = [],
        i = void 0 !== n;

    while ((e = e[t]) && 9 !== e.nodeType) {
      if (1 === e.nodeType) {
        if (i && k(e).is(n)) break;
        r.push(e);
      }
    }

    return r;
  },
      S = function S(e, t) {
    for (var n = []; e; e = e.nextSibling) {
      1 === e.nodeType && e !== t && n.push(e);
    }

    return n;
  },
      N = k.expr.match.needsContext;

  function A(e, t) {
    return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase();
  }

  var D = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

  function j(e, n, r) {
    return m(n) ? k.grep(e, function (e, t) {
      return !!n.call(e, t, e) !== r;
    }) : n.nodeType ? k.grep(e, function (e) {
      return e === n !== r;
    }) : "string" != typeof n ? k.grep(e, function (e) {
      return -1 < i.call(n, e) !== r;
    }) : k.filter(n, e, r);
  }

  k.filter = function (e, t, n) {
    var r = t[0];
    return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? k.find.matchesSelector(r, e) ? [r] : [] : k.find.matches(e, k.grep(t, function (e) {
      return 1 === e.nodeType;
    }));
  }, k.fn.extend({
    find: function find(e) {
      var t,
          n,
          r = this.length,
          i = this;
      if ("string" != typeof e) return this.pushStack(k(e).filter(function () {
        for (t = 0; t < r; t++) {
          if (k.contains(i[t], this)) return !0;
        }
      }));

      for (n = this.pushStack([]), t = 0; t < r; t++) {
        k.find(e, i[t], n);
      }

      return 1 < r ? k.uniqueSort(n) : n;
    },
    filter: function filter(e) {
      return this.pushStack(j(this, e || [], !1));
    },
    not: function not(e) {
      return this.pushStack(j(this, e || [], !0));
    },
    is: function is(e) {
      return !!j(this, "string" == typeof e && N.test(e) ? k(e) : e || [], !1).length;
    }
  });
  var q,
      L = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
  (k.fn.init = function (e, t, n) {
    var r, i;
    if (!e) return this;

    if (n = n || q, "string" == typeof e) {
      if (!(r = "<" === e[0] && ">" === e[e.length - 1] && 3 <= e.length ? [null, e, null] : L.exec(e)) || !r[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e);

      if (r[1]) {
        if (t = t instanceof k ? t[0] : t, k.merge(this, k.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : E, !0)), D.test(r[1]) && k.isPlainObject(t)) for (r in t) {
          m(this[r]) ? this[r](t[r]) : this.attr(r, t[r]);
        }
        return this;
      }

      return (i = E.getElementById(r[2])) && (this[0] = i, this.length = 1), this;
    }

    return e.nodeType ? (this[0] = e, this.length = 1, this) : m(e) ? void 0 !== n.ready ? n.ready(e) : e(k) : k.makeArray(e, this);
  }).prototype = k.fn, q = k(E);
  var H = /^(?:parents|prev(?:Until|All))/,
      O = {
    children: !0,
    contents: !0,
    next: !0,
    prev: !0
  };

  function P(e, t) {
    while ((e = e[t]) && 1 !== e.nodeType) {
      ;
    }

    return e;
  }

  k.fn.extend({
    has: function has(e) {
      var t = k(e, this),
          n = t.length;
      return this.filter(function () {
        for (var e = 0; e < n; e++) {
          if (k.contains(this, t[e])) return !0;
        }
      });
    },
    closest: function closest(e, t) {
      var n,
          r = 0,
          i = this.length,
          o = [],
          a = "string" != typeof e && k(e);
      if (!N.test(e)) for (; r < i; r++) {
        for (n = this[r]; n && n !== t; n = n.parentNode) {
          if (n.nodeType < 11 && (a ? -1 < a.index(n) : 1 === n.nodeType && k.find.matchesSelector(n, e))) {
            o.push(n);
            break;
          }
        }
      }
      return this.pushStack(1 < o.length ? k.uniqueSort(o) : o);
    },
    index: function index(e) {
      return e ? "string" == typeof e ? i.call(k(e), this[0]) : i.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
    },
    add: function add(e, t) {
      return this.pushStack(k.uniqueSort(k.merge(this.get(), k(e, t))));
    },
    addBack: function addBack(e) {
      return this.add(null == e ? this.prevObject : this.prevObject.filter(e));
    }
  }), k.each({
    parent: function parent(e) {
      var t = e.parentNode;
      return t && 11 !== t.nodeType ? t : null;
    },
    parents: function parents(e) {
      return T(e, "parentNode");
    },
    parentsUntil: function parentsUntil(e, t, n) {
      return T(e, "parentNode", n);
    },
    next: function next(e) {
      return P(e, "nextSibling");
    },
    prev: function prev(e) {
      return P(e, "previousSibling");
    },
    nextAll: function nextAll(e) {
      return T(e, "nextSibling");
    },
    prevAll: function prevAll(e) {
      return T(e, "previousSibling");
    },
    nextUntil: function nextUntil(e, t, n) {
      return T(e, "nextSibling", n);
    },
    prevUntil: function prevUntil(e, t, n) {
      return T(e, "previousSibling", n);
    },
    siblings: function siblings(e) {
      return S((e.parentNode || {}).firstChild, e);
    },
    children: function children(e) {
      return S(e.firstChild);
    },
    contents: function contents(e) {
      return "undefined" != typeof e.contentDocument ? e.contentDocument : (A(e, "template") && (e = e.content || e), k.merge([], e.childNodes));
    }
  }, function (r, i) {
    k.fn[r] = function (e, t) {
      var n = k.map(this, i, e);
      return "Until" !== r.slice(-5) && (t = e), t && "string" == typeof t && (n = k.filter(t, n)), 1 < this.length && (O[r] || k.uniqueSort(n), H.test(r) && n.reverse()), this.pushStack(n);
    };
  });
  var R = /[^\x20\t\r\n\f]+/g;

  function M(e) {
    return e;
  }

  function I(e) {
    throw e;
  }

  function W(e, t, n, r) {
    var i;

    try {
      e && m(i = e.promise) ? i.call(e).done(t).fail(n) : e && m(i = e.then) ? i.call(e, t, n) : t.apply(void 0, [e].slice(r));
    } catch (e) {
      n.apply(void 0, [e]);
    }
  }

  k.Callbacks = function (r) {
    var e, n;
    r = "string" == typeof r ? (e = r, n = {}, k.each(e.match(R) || [], function (e, t) {
      n[t] = !0;
    }), n) : k.extend({}, r);

    var i,
        t,
        o,
        a,
        s = [],
        u = [],
        l = -1,
        c = function c() {
      for (a = a || r.once, o = i = !0; u.length; l = -1) {
        t = u.shift();

        while (++l < s.length) {
          !1 === s[l].apply(t[0], t[1]) && r.stopOnFalse && (l = s.length, t = !1);
        }
      }

      r.memory || (t = !1), i = !1, a && (s = t ? [] : "");
    },
        f = {
      add: function add() {
        return s && (t && !i && (l = s.length - 1, u.push(t)), function n(e) {
          k.each(e, function (e, t) {
            m(t) ? r.unique && f.has(t) || s.push(t) : t && t.length && "string" !== w(t) && n(t);
          });
        }(arguments), t && !i && c()), this;
      },
      remove: function remove() {
        return k.each(arguments, function (e, t) {
          var n;

          while (-1 < (n = k.inArray(t, s, n))) {
            s.splice(n, 1), n <= l && l--;
          }
        }), this;
      },
      has: function has(e) {
        return e ? -1 < k.inArray(e, s) : 0 < s.length;
      },
      empty: function empty() {
        return s && (s = []), this;
      },
      disable: function disable() {
        return a = u = [], s = t = "", this;
      },
      disabled: function disabled() {
        return !s;
      },
      lock: function lock() {
        return a = u = [], t || i || (s = t = ""), this;
      },
      locked: function locked() {
        return !!a;
      },
      fireWith: function fireWith(e, t) {
        return a || (t = [e, (t = t || []).slice ? t.slice() : t], u.push(t), i || c()), this;
      },
      fire: function fire() {
        return f.fireWith(this, arguments), this;
      },
      fired: function fired() {
        return !!o;
      }
    };

    return f;
  }, k.extend({
    Deferred: function Deferred(e) {
      var o = [["notify", "progress", k.Callbacks("memory"), k.Callbacks("memory"), 2], ["resolve", "done", k.Callbacks("once memory"), k.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", k.Callbacks("once memory"), k.Callbacks("once memory"), 1, "rejected"]],
          i = "pending",
          a = {
        state: function state() {
          return i;
        },
        always: function always() {
          return s.done(arguments).fail(arguments), this;
        },
        "catch": function _catch(e) {
          return a.then(null, e);
        },
        pipe: function pipe() {
          var i = arguments;
          return k.Deferred(function (r) {
            k.each(o, function (e, t) {
              var n = m(i[t[4]]) && i[t[4]];
              s[t[1]](function () {
                var e = n && n.apply(this, arguments);
                e && m(e.promise) ? e.promise().progress(r.notify).done(r.resolve).fail(r.reject) : r[t[0] + "With"](this, n ? [e] : arguments);
              });
            }), i = null;
          }).promise();
        },
        then: function then(t, n, r) {
          var u = 0;

          function l(i, o, a, s) {
            return function () {
              var n = this,
                  r = arguments,
                  e = function e() {
                var e, t;

                if (!(i < u)) {
                  if ((e = a.apply(n, r)) === o.promise()) throw new TypeError("Thenable self-resolution");
                  t = e && ("object" == _typeof(e) || "function" == typeof e) && e.then, m(t) ? s ? t.call(e, l(u, o, M, s), l(u, o, I, s)) : (u++, t.call(e, l(u, o, M, s), l(u, o, I, s), l(u, o, M, o.notifyWith))) : (a !== M && (n = void 0, r = [e]), (s || o.resolveWith)(n, r));
                }
              },
                  t = s ? e : function () {
                try {
                  e();
                } catch (e) {
                  k.Deferred.exceptionHook && k.Deferred.exceptionHook(e, t.stackTrace), u <= i + 1 && (a !== I && (n = void 0, r = [e]), o.rejectWith(n, r));
                }
              };

              i ? t() : (k.Deferred.getStackHook && (t.stackTrace = k.Deferred.getStackHook()), C.setTimeout(t));
            };
          }

          return k.Deferred(function (e) {
            o[0][3].add(l(0, e, m(r) ? r : M, e.notifyWith)), o[1][3].add(l(0, e, m(t) ? t : M)), o[2][3].add(l(0, e, m(n) ? n : I));
          }).promise();
        },
        promise: function promise(e) {
          return null != e ? k.extend(e, a) : a;
        }
      },
          s = {};
      return k.each(o, function (e, t) {
        var n = t[2],
            r = t[5];
        a[t[1]] = n.add, r && n.add(function () {
          i = r;
        }, o[3 - e][2].disable, o[3 - e][3].disable, o[0][2].lock, o[0][3].lock), n.add(t[3].fire), s[t[0]] = function () {
          return s[t[0] + "With"](this === s ? void 0 : this, arguments), this;
        }, s[t[0] + "With"] = n.fireWith;
      }), a.promise(s), e && e.call(s, s), s;
    },
    when: function when(e) {
      var n = arguments.length,
          t = n,
          r = Array(t),
          i = s.call(arguments),
          o = k.Deferred(),
          a = function a(t) {
        return function (e) {
          r[t] = this, i[t] = 1 < arguments.length ? s.call(arguments) : e, --n || o.resolveWith(r, i);
        };
      };

      if (n <= 1 && (W(e, o.done(a(t)).resolve, o.reject, !n), "pending" === o.state() || m(i[t] && i[t].then))) return o.then();

      while (t--) {
        W(i[t], a(t), o.reject);
      }

      return o.promise();
    }
  });
  var $ = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
  k.Deferred.exceptionHook = function (e, t) {
    C.console && C.console.warn && e && $.test(e.name) && C.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t);
  }, k.readyException = function (e) {
    C.setTimeout(function () {
      throw e;
    });
  };
  var F = k.Deferred();

  function B() {
    E.removeEventListener("DOMContentLoaded", B), C.removeEventListener("load", B), k.ready();
  }

  k.fn.ready = function (e) {
    return F.then(e)["catch"](function (e) {
      k.readyException(e);
    }), this;
  }, k.extend({
    isReady: !1,
    readyWait: 1,
    ready: function ready(e) {
      (!0 === e ? --k.readyWait : k.isReady) || (k.isReady = !0) !== e && 0 < --k.readyWait || F.resolveWith(E, [k]);
    }
  }), k.ready.then = F.then, "complete" === E.readyState || "loading" !== E.readyState && !E.documentElement.doScroll ? C.setTimeout(k.ready) : (E.addEventListener("DOMContentLoaded", B), C.addEventListener("load", B));

  var _ = function _(e, t, n, r, i, o, a) {
    var s = 0,
        u = e.length,
        l = null == n;
    if ("object" === w(n)) for (s in i = !0, n) {
      _(e, t, s, n[s], !0, o, a);
    } else if (void 0 !== r && (i = !0, m(r) || (a = !0), l && (a ? (t.call(e, r), t = null) : (l = t, t = function t(e, _t2, n) {
      return l.call(k(e), n);
    })), t)) for (; s < u; s++) {
      t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n)));
    }
    return i ? e : l ? t.call(e) : u ? t(e[0], n) : o;
  },
      z = /^-ms-/,
      U = /-([a-z])/g;

  function X(e, t) {
    return t.toUpperCase();
  }

  function V(e) {
    return e.replace(z, "ms-").replace(U, X);
  }

  var G = function G(e) {
    return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType;
  };

  function Y() {
    this.expando = k.expando + Y.uid++;
  }

  Y.uid = 1, Y.prototype = {
    cache: function cache(e) {
      var t = e[this.expando];
      return t || (t = {}, G(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, {
        value: t,
        configurable: !0
      }))), t;
    },
    set: function set(e, t, n) {
      var r,
          i = this.cache(e);
      if ("string" == typeof t) i[V(t)] = n;else for (r in t) {
        i[V(r)] = t[r];
      }
      return i;
    },
    get: function get(e, t) {
      return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][V(t)];
    },
    access: function access(e, t, n) {
      return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t);
    },
    remove: function remove(e, t) {
      var n,
          r = e[this.expando];

      if (void 0 !== r) {
        if (void 0 !== t) {
          n = (t = Array.isArray(t) ? t.map(V) : (t = V(t)) in r ? [t] : t.match(R) || []).length;

          while (n--) {
            delete r[t[n]];
          }
        }

        (void 0 === t || k.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]);
      }
    },
    hasData: function hasData(e) {
      var t = e[this.expando];
      return void 0 !== t && !k.isEmptyObject(t);
    }
  };
  var Q = new Y(),
      J = new Y(),
      K = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      Z = /[A-Z]/g;

  function ee(e, t, n) {
    var r, i;
    if (void 0 === n && 1 === e.nodeType) if (r = "data-" + t.replace(Z, "-$&").toLowerCase(), "string" == typeof (n = e.getAttribute(r))) {
      try {
        n = "true" === (i = n) || "false" !== i && ("null" === i ? null : i === +i + "" ? +i : K.test(i) ? JSON.parse(i) : i);
      } catch (e) {}

      J.set(e, t, n);
    } else n = void 0;
    return n;
  }

  k.extend({
    hasData: function hasData(e) {
      return J.hasData(e) || Q.hasData(e);
    },
    data: function data(e, t, n) {
      return J.access(e, t, n);
    },
    removeData: function removeData(e, t) {
      J.remove(e, t);
    },
    _data: function _data(e, t, n) {
      return Q.access(e, t, n);
    },
    _removeData: function _removeData(e, t) {
      Q.remove(e, t);
    }
  }), k.fn.extend({
    data: function data(n, e) {
      var t,
          r,
          i,
          o = this[0],
          a = o && o.attributes;

      if (void 0 === n) {
        if (this.length && (i = J.get(o), 1 === o.nodeType && !Q.get(o, "hasDataAttrs"))) {
          t = a.length;

          while (t--) {
            a[t] && 0 === (r = a[t].name).indexOf("data-") && (r = V(r.slice(5)), ee(o, r, i[r]));
          }

          Q.set(o, "hasDataAttrs", !0);
        }

        return i;
      }

      return "object" == _typeof(n) ? this.each(function () {
        J.set(this, n);
      }) : _(this, function (e) {
        var t;
        if (o && void 0 === e) return void 0 !== (t = J.get(o, n)) ? t : void 0 !== (t = ee(o, n)) ? t : void 0;
        this.each(function () {
          J.set(this, n, e);
        });
      }, null, e, 1 < arguments.length, null, !0);
    },
    removeData: function removeData(e) {
      return this.each(function () {
        J.remove(this, e);
      });
    }
  }), k.extend({
    queue: function queue(e, t, n) {
      var r;
      if (e) return t = (t || "fx") + "queue", r = Q.get(e, t), n && (!r || Array.isArray(n) ? r = Q.access(e, t, k.makeArray(n)) : r.push(n)), r || [];
    },
    dequeue: function dequeue(e, t) {
      t = t || "fx";

      var n = k.queue(e, t),
          r = n.length,
          i = n.shift(),
          o = k._queueHooks(e, t);

      "inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, function () {
        k.dequeue(e, t);
      }, o)), !r && o && o.empty.fire();
    },
    _queueHooks: function _queueHooks(e, t) {
      var n = t + "queueHooks";
      return Q.get(e, n) || Q.access(e, n, {
        empty: k.Callbacks("once memory").add(function () {
          Q.remove(e, [t + "queue", n]);
        })
      });
    }
  }), k.fn.extend({
    queue: function queue(t, n) {
      var e = 2;
      return "string" != typeof t && (n = t, t = "fx", e--), arguments.length < e ? k.queue(this[0], t) : void 0 === n ? this : this.each(function () {
        var e = k.queue(this, t, n);
        k._queueHooks(this, t), "fx" === t && "inprogress" !== e[0] && k.dequeue(this, t);
      });
    },
    dequeue: function dequeue(e) {
      return this.each(function () {
        k.dequeue(this, e);
      });
    },
    clearQueue: function clearQueue(e) {
      return this.queue(e || "fx", []);
    },
    promise: function promise(e, t) {
      var n,
          r = 1,
          i = k.Deferred(),
          o = this,
          a = this.length,
          s = function s() {
        --r || i.resolveWith(o, [o]);
      };

      "string" != typeof e && (t = e, e = void 0), e = e || "fx";

      while (a--) {
        (n = Q.get(o[a], e + "queueHooks")) && n.empty && (r++, n.empty.add(s));
      }

      return s(), i.promise(t);
    }
  });

  var te = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
      ne = new RegExp("^(?:([+-])=|)(" + te + ")([a-z%]*)$", "i"),
      re = ["Top", "Right", "Bottom", "Left"],
      ie = E.documentElement,
      oe = function oe(e) {
    return k.contains(e.ownerDocument, e);
  },
      ae = {
    composed: !0
  };

  ie.getRootNode && (oe = function oe(e) {
    return k.contains(e.ownerDocument, e) || e.getRootNode(ae) === e.ownerDocument;
  });

  var se = function se(e, t) {
    return "none" === (e = t || e).style.display || "" === e.style.display && oe(e) && "none" === k.css(e, "display");
  },
      ue = function ue(e, t, n, r) {
    var i,
        o,
        a = {};

    for (o in t) {
      a[o] = e.style[o], e.style[o] = t[o];
    }

    for (o in i = n.apply(e, r || []), t) {
      e.style[o] = a[o];
    }

    return i;
  };

  function le(e, t, n, r) {
    var i,
        o,
        a = 20,
        s = r ? function () {
      return r.cur();
    } : function () {
      return k.css(e, t, "");
    },
        u = s(),
        l = n && n[3] || (k.cssNumber[t] ? "" : "px"),
        c = e.nodeType && (k.cssNumber[t] || "px" !== l && +u) && ne.exec(k.css(e, t));

    if (c && c[3] !== l) {
      u /= 2, l = l || c[3], c = +u || 1;

      while (a--) {
        k.style(e, t, c + l), (1 - o) * (1 - (o = s() / u || .5)) <= 0 && (a = 0), c /= o;
      }

      c *= 2, k.style(e, t, c + l), n = n || [];
    }

    return n && (c = +c || +u || 0, i = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = c, r.end = i)), i;
  }

  var ce = {};

  function fe(e, t) {
    for (var n, r, i, o, a, s, u, l = [], c = 0, f = e.length; c < f; c++) {
      (r = e[c]).style && (n = r.style.display, t ? ("none" === n && (l[c] = Q.get(r, "display") || null, l[c] || (r.style.display = "")), "" === r.style.display && se(r) && (l[c] = (u = a = o = void 0, a = (i = r).ownerDocument, s = i.nodeName, (u = ce[s]) || (o = a.body.appendChild(a.createElement(s)), u = k.css(o, "display"), o.parentNode.removeChild(o), "none" === u && (u = "block"), ce[s] = u)))) : "none" !== n && (l[c] = "none", Q.set(r, "display", n)));
    }

    for (c = 0; c < f; c++) {
      null != l[c] && (e[c].style.display = l[c]);
    }

    return e;
  }

  k.fn.extend({
    show: function show() {
      return fe(this, !0);
    },
    hide: function hide() {
      return fe(this);
    },
    toggle: function toggle(e) {
      return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function () {
        se(this) ? k(this).show() : k(this).hide();
      });
    }
  });
  var pe = /^(?:checkbox|radio)$/i,
      de = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
      he = /^$|^module$|\/(?:java|ecma)script/i,
      ge = {
    option: [1, "<select multiple='multiple'>", "</select>"],
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""]
  };

  function ve(e, t) {
    var n;
    return n = "undefined" != typeof e.getElementsByTagName ? e.getElementsByTagName(t || "*") : "undefined" != typeof e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && A(e, t) ? k.merge([e], n) : n;
  }

  function ye(e, t) {
    for (var n = 0, r = e.length; n < r; n++) {
      Q.set(e[n], "globalEval", !t || Q.get(t[n], "globalEval"));
    }
  }

  ge.optgroup = ge.option, ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td;
  var me,
      xe,
      be = /<|&#?\w+;/;

  function we(e, t, n, r, i) {
    for (var o, a, s, u, l, c, f = t.createDocumentFragment(), p = [], d = 0, h = e.length; d < h; d++) {
      if ((o = e[d]) || 0 === o) if ("object" === w(o)) k.merge(p, o.nodeType ? [o] : o);else if (be.test(o)) {
        a = a || f.appendChild(t.createElement("div")), s = (de.exec(o) || ["", ""])[1].toLowerCase(), u = ge[s] || ge._default, a.innerHTML = u[1] + k.htmlPrefilter(o) + u[2], c = u[0];

        while (c--) {
          a = a.lastChild;
        }

        k.merge(p, a.childNodes), (a = f.firstChild).textContent = "";
      } else p.push(t.createTextNode(o));
    }

    f.textContent = "", d = 0;

    while (o = p[d++]) {
      if (r && -1 < k.inArray(o, r)) i && i.push(o);else if (l = oe(o), a = ve(f.appendChild(o), "script"), l && ye(a), n) {
        c = 0;

        while (o = a[c++]) {
          he.test(o.type || "") && n.push(o);
        }
      }
    }

    return f;
  }

  me = E.createDocumentFragment().appendChild(E.createElement("div")), (xe = E.createElement("input")).setAttribute("type", "radio"), xe.setAttribute("checked", "checked"), xe.setAttribute("name", "t"), me.appendChild(xe), y.checkClone = me.cloneNode(!0).cloneNode(!0).lastChild.checked, me.innerHTML = "<textarea>x</textarea>", y.noCloneChecked = !!me.cloneNode(!0).lastChild.defaultValue;
  var Te = /^key/,
      Ce = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
      Ee = /^([^.]*)(?:\.(.+)|)/;

  function ke() {
    return !0;
  }

  function Se() {
    return !1;
  }

  function Ne(e, t) {
    return e === function () {
      try {
        return E.activeElement;
      } catch (e) {}
    }() == ("focus" === t);
  }

  function Ae(e, t, n, r, i, o) {
    var a, s;

    if ("object" == _typeof(t)) {
      for (s in "string" != typeof n && (r = r || n, n = void 0), t) {
        Ae(e, s, n, r, t[s], o);
      }

      return e;
    }

    if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i) i = Se;else if (!i) return e;
    return 1 === o && (a = i, (i = function i(e) {
      return k().off(e), a.apply(this, arguments);
    }).guid = a.guid || (a.guid = k.guid++)), e.each(function () {
      k.event.add(this, t, i, r, n);
    });
  }

  function De(e, i, o) {
    o ? (Q.set(e, i, !1), k.event.add(e, i, {
      namespace: !1,
      handler: function handler(e) {
        var t,
            n,
            r = Q.get(this, i);

        if (1 & e.isTrigger && this[i]) {
          if (r.length) (k.event.special[i] || {}).delegateType && e.stopPropagation();else if (r = s.call(arguments), Q.set(this, i, r), t = o(this, i), this[i](), r !== (n = Q.get(this, i)) || t ? Q.set(this, i, !1) : n = {}, r !== n) return e.stopImmediatePropagation(), e.preventDefault(), n.value;
        } else r.length && (Q.set(this, i, {
          value: k.event.trigger(k.extend(r[0], k.Event.prototype), r.slice(1), this)
        }), e.stopImmediatePropagation());
      }
    })) : void 0 === Q.get(e, i) && k.event.add(e, i, ke);
  }

  k.event = {
    global: {},
    add: function add(t, e, n, r, i) {
      var o,
          a,
          s,
          u,
          l,
          c,
          f,
          p,
          d,
          h,
          g,
          v = Q.get(t);

      if (v) {
        n.handler && (n = (o = n).handler, i = o.selector), i && k.find.matchesSelector(ie, i), n.guid || (n.guid = k.guid++), (u = v.events) || (u = v.events = {}), (a = v.handle) || (a = v.handle = function (e) {
          return "undefined" != typeof k && k.event.triggered !== e.type ? k.event.dispatch.apply(t, arguments) : void 0;
        }), l = (e = (e || "").match(R) || [""]).length;

        while (l--) {
          d = g = (s = Ee.exec(e[l]) || [])[1], h = (s[2] || "").split(".").sort(), d && (f = k.event.special[d] || {}, d = (i ? f.delegateType : f.bindType) || d, f = k.event.special[d] || {}, c = k.extend({
            type: d,
            origType: g,
            data: r,
            handler: n,
            guid: n.guid,
            selector: i,
            needsContext: i && k.expr.match.needsContext.test(i),
            namespace: h.join(".")
          }, o), (p = u[d]) || ((p = u[d] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(t, r, h, a) || t.addEventListener && t.addEventListener(d, a)), f.add && (f.add.call(t, c), c.handler.guid || (c.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, c) : p.push(c), k.event.global[d] = !0);
        }
      }
    },
    remove: function remove(e, t, n, r, i) {
      var o,
          a,
          s,
          u,
          l,
          c,
          f,
          p,
          d,
          h,
          g,
          v = Q.hasData(e) && Q.get(e);

      if (v && (u = v.events)) {
        l = (t = (t || "").match(R) || [""]).length;

        while (l--) {
          if (d = g = (s = Ee.exec(t[l]) || [])[1], h = (s[2] || "").split(".").sort(), d) {
            f = k.event.special[d] || {}, p = u[d = (r ? f.delegateType : f.bindType) || d] || [], s = s[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = p.length;

            while (o--) {
              c = p[o], !i && g !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (p.splice(o, 1), c.selector && p.delegateCount--, f.remove && f.remove.call(e, c));
            }

            a && !p.length && (f.teardown && !1 !== f.teardown.call(e, h, v.handle) || k.removeEvent(e, d, v.handle), delete u[d]);
          } else for (d in u) {
            k.event.remove(e, d + t[l], n, r, !0);
          }
        }

        k.isEmptyObject(u) && Q.remove(e, "handle events");
      }
    },
    dispatch: function dispatch(e) {
      var t,
          n,
          r,
          i,
          o,
          a,
          s = k.event.fix(e),
          u = new Array(arguments.length),
          l = (Q.get(this, "events") || {})[s.type] || [],
          c = k.event.special[s.type] || {};

      for (u[0] = s, t = 1; t < arguments.length; t++) {
        u[t] = arguments[t];
      }

      if (s.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, s)) {
        a = k.event.handlers.call(this, s, l), t = 0;

        while ((i = a[t++]) && !s.isPropagationStopped()) {
          s.currentTarget = i.elem, n = 0;

          while ((o = i.handlers[n++]) && !s.isImmediatePropagationStopped()) {
            s.rnamespace && !1 !== o.namespace && !s.rnamespace.test(o.namespace) || (s.handleObj = o, s.data = o.data, void 0 !== (r = ((k.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, u)) && !1 === (s.result = r) && (s.preventDefault(), s.stopPropagation()));
          }
        }

        return c.postDispatch && c.postDispatch.call(this, s), s.result;
      }
    },
    handlers: function handlers(e, t) {
      var n,
          r,
          i,
          o,
          a,
          s = [],
          u = t.delegateCount,
          l = e.target;
      if (u && l.nodeType && !("click" === e.type && 1 <= e.button)) for (; l !== this; l = l.parentNode || this) {
        if (1 === l.nodeType && ("click" !== e.type || !0 !== l.disabled)) {
          for (o = [], a = {}, n = 0; n < u; n++) {
            void 0 === a[i = (r = t[n]).selector + " "] && (a[i] = r.needsContext ? -1 < k(i, this).index(l) : k.find(i, this, null, [l]).length), a[i] && o.push(r);
          }

          o.length && s.push({
            elem: l,
            handlers: o
          });
        }
      }
      return l = this, u < t.length && s.push({
        elem: l,
        handlers: t.slice(u)
      }), s;
    },
    addProp: function addProp(t, e) {
      Object.defineProperty(k.Event.prototype, t, {
        enumerable: !0,
        configurable: !0,
        get: m(e) ? function () {
          if (this.originalEvent) return e(this.originalEvent);
        } : function () {
          if (this.originalEvent) return this.originalEvent[t];
        },
        set: function set(e) {
          Object.defineProperty(this, t, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: e
          });
        }
      });
    },
    fix: function fix(e) {
      return e[k.expando] ? e : new k.Event(e);
    },
    special: {
      load: {
        noBubble: !0
      },
      click: {
        setup: function setup(e) {
          var t = this || e;
          return pe.test(t.type) && t.click && A(t, "input") && De(t, "click", ke), !1;
        },
        trigger: function trigger(e) {
          var t = this || e;
          return pe.test(t.type) && t.click && A(t, "input") && De(t, "click"), !0;
        },
        _default: function _default(e) {
          var t = e.target;
          return pe.test(t.type) && t.click && A(t, "input") && Q.get(t, "click") || A(t, "a");
        }
      },
      beforeunload: {
        postDispatch: function postDispatch(e) {
          void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result);
        }
      }
    }
  }, k.removeEvent = function (e, t, n) {
    e.removeEventListener && e.removeEventListener(t, n);
  }, k.Event = function (e, t) {
    if (!(this instanceof k.Event)) return new k.Event(e, t);
    e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? ke : Se, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && k.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[k.expando] = !0;
  }, k.Event.prototype = {
    constructor: k.Event,
    isDefaultPrevented: Se,
    isPropagationStopped: Se,
    isImmediatePropagationStopped: Se,
    isSimulated: !1,
    preventDefault: function preventDefault() {
      var e = this.originalEvent;
      this.isDefaultPrevented = ke, e && !this.isSimulated && e.preventDefault();
    },
    stopPropagation: function stopPropagation() {
      var e = this.originalEvent;
      this.isPropagationStopped = ke, e && !this.isSimulated && e.stopPropagation();
    },
    stopImmediatePropagation: function stopImmediatePropagation() {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = ke, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation();
    }
  }, k.each({
    altKey: !0,
    bubbles: !0,
    cancelable: !0,
    changedTouches: !0,
    ctrlKey: !0,
    detail: !0,
    eventPhase: !0,
    metaKey: !0,
    pageX: !0,
    pageY: !0,
    shiftKey: !0,
    view: !0,
    "char": !0,
    code: !0,
    charCode: !0,
    key: !0,
    keyCode: !0,
    button: !0,
    buttons: !0,
    clientX: !0,
    clientY: !0,
    offsetX: !0,
    offsetY: !0,
    pointerId: !0,
    pointerType: !0,
    screenX: !0,
    screenY: !0,
    targetTouches: !0,
    toElement: !0,
    touches: !0,
    which: function which(e) {
      var t = e.button;
      return null == e.which && Te.test(e.type) ? null != e.charCode ? e.charCode : e.keyCode : !e.which && void 0 !== t && Ce.test(e.type) ? 1 & t ? 1 : 2 & t ? 3 : 4 & t ? 2 : 0 : e.which;
    }
  }, k.event.addProp), k.each({
    focus: "focusin",
    blur: "focusout"
  }, function (e, t) {
    k.event.special[e] = {
      setup: function setup() {
        return De(this, e, Ne), !1;
      },
      trigger: function trigger() {
        return De(this, e), !0;
      },
      delegateType: t
    };
  }), k.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function (e, i) {
    k.event.special[e] = {
      delegateType: i,
      bindType: i,
      handle: function handle(e) {
        var t,
            n = e.relatedTarget,
            r = e.handleObj;
        return n && (n === this || k.contains(this, n)) || (e.type = r.origType, t = r.handler.apply(this, arguments), e.type = i), t;
      }
    };
  }), k.fn.extend({
    on: function on(e, t, n, r) {
      return Ae(this, e, t, n, r);
    },
    one: function one(e, t, n, r) {
      return Ae(this, e, t, n, r, 1);
    },
    off: function off(e, t, n) {
      var r, i;
      if (e && e.preventDefault && e.handleObj) return r = e.handleObj, k(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this;

      if ("object" == _typeof(e)) {
        for (i in e) {
          this.off(i, t, e[i]);
        }

        return this;
      }

      return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = Se), this.each(function () {
        k.event.remove(this, e, n, t);
      });
    }
  });
  var je = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
      qe = /<script|<style|<link/i,
      Le = /checked\s*(?:[^=]|=\s*.checked.)/i,
      He = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

  function Oe(e, t) {
    return A(e, "table") && A(11 !== t.nodeType ? t : t.firstChild, "tr") && k(e).children("tbody")[0] || e;
  }

  function Pe(e) {
    return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e;
  }

  function Re(e) {
    return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e;
  }

  function Me(e, t) {
    var n, r, i, o, a, s, u, l;

    if (1 === t.nodeType) {
      if (Q.hasData(e) && (o = Q.access(e), a = Q.set(t, o), l = o.events)) for (i in delete a.handle, a.events = {}, l) {
        for (n = 0, r = l[i].length; n < r; n++) {
          k.event.add(t, i, l[i][n]);
        }
      }
      J.hasData(e) && (s = J.access(e), u = k.extend({}, s), J.set(t, u));
    }
  }

  function Ie(n, r, i, o) {
    r = g.apply([], r);
    var e,
        t,
        a,
        s,
        u,
        l,
        c = 0,
        f = n.length,
        p = f - 1,
        d = r[0],
        h = m(d);
    if (h || 1 < f && "string" == typeof d && !y.checkClone && Le.test(d)) return n.each(function (e) {
      var t = n.eq(e);
      h && (r[0] = d.call(this, e, t.html())), Ie(t, r, i, o);
    });

    if (f && (t = (e = we(r, n[0].ownerDocument, !1, n, o)).firstChild, 1 === e.childNodes.length && (e = t), t || o)) {
      for (s = (a = k.map(ve(e, "script"), Pe)).length; c < f; c++) {
        u = e, c !== p && (u = k.clone(u, !0, !0), s && k.merge(a, ve(u, "script"))), i.call(n[c], u, c);
      }

      if (s) for (l = a[a.length - 1].ownerDocument, k.map(a, Re), c = 0; c < s; c++) {
        u = a[c], he.test(u.type || "") && !Q.access(u, "globalEval") && k.contains(l, u) && (u.src && "module" !== (u.type || "").toLowerCase() ? k._evalUrl && !u.noModule && k._evalUrl(u.src, {
          nonce: u.nonce || u.getAttribute("nonce")
        }) : b(u.textContent.replace(He, ""), u, l));
      }
    }

    return n;
  }

  function We(e, t, n) {
    for (var r, i = t ? k.filter(t, e) : e, o = 0; null != (r = i[o]); o++) {
      n || 1 !== r.nodeType || k.cleanData(ve(r)), r.parentNode && (n && oe(r) && ye(ve(r, "script")), r.parentNode.removeChild(r));
    }

    return e;
  }

  k.extend({
    htmlPrefilter: function htmlPrefilter(e) {
      return e.replace(je, "<$1></$2>");
    },
    clone: function clone(e, t, n) {
      var r,
          i,
          o,
          a,
          s,
          u,
          l,
          c = e.cloneNode(!0),
          f = oe(e);
      if (!(y.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || k.isXMLDoc(e))) for (a = ve(c), r = 0, i = (o = ve(e)).length; r < i; r++) {
        s = o[r], u = a[r], void 0, "input" === (l = u.nodeName.toLowerCase()) && pe.test(s.type) ? u.checked = s.checked : "input" !== l && "textarea" !== l || (u.defaultValue = s.defaultValue);
      }
      if (t) if (n) for (o = o || ve(e), a = a || ve(c), r = 0, i = o.length; r < i; r++) {
        Me(o[r], a[r]);
      } else Me(e, c);
      return 0 < (a = ve(c, "script")).length && ye(a, !f && ve(e, "script")), c;
    },
    cleanData: function cleanData(e) {
      for (var t, n, r, i = k.event.special, o = 0; void 0 !== (n = e[o]); o++) {
        if (G(n)) {
          if (t = n[Q.expando]) {
            if (t.events) for (r in t.events) {
              i[r] ? k.event.remove(n, r) : k.removeEvent(n, r, t.handle);
            }
            n[Q.expando] = void 0;
          }

          n[J.expando] && (n[J.expando] = void 0);
        }
      }
    }
  }), k.fn.extend({
    detach: function detach(e) {
      return We(this, e, !0);
    },
    remove: function remove(e) {
      return We(this, e);
    },
    text: function text(e) {
      return _(this, function (e) {
        return void 0 === e ? k.text(this) : this.empty().each(function () {
          1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e);
        });
      }, null, e, arguments.length);
    },
    append: function append() {
      return Ie(this, arguments, function (e) {
        1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Oe(this, e).appendChild(e);
      });
    },
    prepend: function prepend() {
      return Ie(this, arguments, function (e) {
        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
          var t = Oe(this, e);
          t.insertBefore(e, t.firstChild);
        }
      });
    },
    before: function before() {
      return Ie(this, arguments, function (e) {
        this.parentNode && this.parentNode.insertBefore(e, this);
      });
    },
    after: function after() {
      return Ie(this, arguments, function (e) {
        this.parentNode && this.parentNode.insertBefore(e, this.nextSibling);
      });
    },
    empty: function empty() {
      for (var e, t = 0; null != (e = this[t]); t++) {
        1 === e.nodeType && (k.cleanData(ve(e, !1)), e.textContent = "");
      }

      return this;
    },
    clone: function clone(e, t) {
      return e = null != e && e, t = null == t ? e : t, this.map(function () {
        return k.clone(this, e, t);
      });
    },
    html: function html(e) {
      return _(this, function (e) {
        var t = this[0] || {},
            n = 0,
            r = this.length;
        if (void 0 === e && 1 === t.nodeType) return t.innerHTML;

        if ("string" == typeof e && !qe.test(e) && !ge[(de.exec(e) || ["", ""])[1].toLowerCase()]) {
          e = k.htmlPrefilter(e);

          try {
            for (; n < r; n++) {
              1 === (t = this[n] || {}).nodeType && (k.cleanData(ve(t, !1)), t.innerHTML = e);
            }

            t = 0;
          } catch (e) {}
        }

        t && this.empty().append(e);
      }, null, e, arguments.length);
    },
    replaceWith: function replaceWith() {
      var n = [];
      return Ie(this, arguments, function (e) {
        var t = this.parentNode;
        k.inArray(this, n) < 0 && (k.cleanData(ve(this)), t && t.replaceChild(e, this));
      }, n);
    }
  }), k.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function (e, a) {
    k.fn[e] = function (e) {
      for (var t, n = [], r = k(e), i = r.length - 1, o = 0; o <= i; o++) {
        t = o === i ? this : this.clone(!0), k(r[o])[a](t), u.apply(n, t.get());
      }

      return this.pushStack(n);
    };
  });

  var $e = new RegExp("^(" + te + ")(?!px)[a-z%]+$", "i"),
      Fe = function Fe(e) {
    var t = e.ownerDocument.defaultView;
    return t && t.opener || (t = C), t.getComputedStyle(e);
  },
      Be = new RegExp(re.join("|"), "i");

  function _e(e, t, n) {
    var r,
        i,
        o,
        a,
        s = e.style;
    return (n = n || Fe(e)) && ("" !== (a = n.getPropertyValue(t) || n[t]) || oe(e) || (a = k.style(e, t)), !y.pixelBoxStyles() && $e.test(a) && Be.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0 !== a ? a + "" : a;
  }

  function ze(e, t) {
    return {
      get: function get() {
        if (!e()) return (this.get = t).apply(this, arguments);
        delete this.get;
      }
    };
  }

  !function () {
    function e() {
      if (u) {
        s.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", u.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", ie.appendChild(s).appendChild(u);
        var e = C.getComputedStyle(u);
        n = "1%" !== e.top, a = 12 === t(e.marginLeft), u.style.right = "60%", o = 36 === t(e.right), r = 36 === t(e.width), u.style.position = "absolute", i = 12 === t(u.offsetWidth / 3), ie.removeChild(s), u = null;
      }
    }

    function t(e) {
      return Math.round(parseFloat(e));
    }

    var n,
        r,
        i,
        o,
        a,
        s = E.createElement("div"),
        u = E.createElement("div");
    u.style && (u.style.backgroundClip = "content-box", u.cloneNode(!0).style.backgroundClip = "", y.clearCloneStyle = "content-box" === u.style.backgroundClip, k.extend(y, {
      boxSizingReliable: function boxSizingReliable() {
        return e(), r;
      },
      pixelBoxStyles: function pixelBoxStyles() {
        return e(), o;
      },
      pixelPosition: function pixelPosition() {
        return e(), n;
      },
      reliableMarginLeft: function reliableMarginLeft() {
        return e(), a;
      },
      scrollboxSize: function scrollboxSize() {
        return e(), i;
      }
    }));
  }();
  var Ue = ["Webkit", "Moz", "ms"],
      Xe = E.createElement("div").style,
      Ve = {};

  function Ge(e) {
    var t = k.cssProps[e] || Ve[e];
    return t || (e in Xe ? e : Ve[e] = function (e) {
      var t = e[0].toUpperCase() + e.slice(1),
          n = Ue.length;

      while (n--) {
        if ((e = Ue[n] + t) in Xe) return e;
      }
    }(e) || e);
  }

  var Ye = /^(none|table(?!-c[ea]).+)/,
      Qe = /^--/,
      Je = {
    position: "absolute",
    visibility: "hidden",
    display: "block"
  },
      Ke = {
    letterSpacing: "0",
    fontWeight: "400"
  };

  function Ze(e, t, n) {
    var r = ne.exec(t);
    return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t;
  }

  function et(e, t, n, r, i, o) {
    var a = "width" === t ? 1 : 0,
        s = 0,
        u = 0;
    if (n === (r ? "border" : "content")) return 0;

    for (; a < 4; a += 2) {
      "margin" === n && (u += k.css(e, n + re[a], !0, i)), r ? ("content" === n && (u -= k.css(e, "padding" + re[a], !0, i)), "margin" !== n && (u -= k.css(e, "border" + re[a] + "Width", !0, i))) : (u += k.css(e, "padding" + re[a], !0, i), "padding" !== n ? u += k.css(e, "border" + re[a] + "Width", !0, i) : s += k.css(e, "border" + re[a] + "Width", !0, i));
    }

    return !r && 0 <= o && (u += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - u - s - .5)) || 0), u;
  }

  function tt(e, t, n) {
    var r = Fe(e),
        i = (!y.boxSizingReliable() || n) && "border-box" === k.css(e, "boxSizing", !1, r),
        o = i,
        a = _e(e, t, r),
        s = "offset" + t[0].toUpperCase() + t.slice(1);

    if ($e.test(a)) {
      if (!n) return a;
      a = "auto";
    }

    return (!y.boxSizingReliable() && i || "auto" === a || !parseFloat(a) && "inline" === k.css(e, "display", !1, r)) && e.getClientRects().length && (i = "border-box" === k.css(e, "boxSizing", !1, r), (o = s in e) && (a = e[s])), (a = parseFloat(a) || 0) + et(e, t, n || (i ? "border" : "content"), o, r, a) + "px";
  }

  function nt(e, t, n, r, i) {
    return new nt.prototype.init(e, t, n, r, i);
  }

  k.extend({
    cssHooks: {
      opacity: {
        get: function get(e, t) {
          if (t) {
            var n = _e(e, "opacity");

            return "" === n ? "1" : n;
          }
        }
      }
    },
    cssNumber: {
      animationIterationCount: !0,
      columnCount: !0,
      fillOpacity: !0,
      flexGrow: !0,
      flexShrink: !0,
      fontWeight: !0,
      gridArea: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnStart: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowStart: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0
    },
    cssProps: {},
    style: function style(e, t, n, r) {
      if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
        var i,
            o,
            a,
            s = V(t),
            u = Qe.test(t),
            l = e.style;
        if (u || (t = Ge(s)), a = k.cssHooks[t] || k.cssHooks[s], void 0 === n) return a && "get" in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t];
        "string" === (o = _typeof(n)) && (i = ne.exec(n)) && i[1] && (n = le(e, t, i), o = "number"), null != n && n == n && ("number" !== o || u || (n += i && i[3] || (k.cssNumber[s] ? "" : "px")), y.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, r)) || (u ? l.setProperty(t, n) : l[t] = n));
      }
    },
    css: function css(e, t, n, r) {
      var i,
          o,
          a,
          s = V(t);
      return Qe.test(t) || (t = Ge(s)), (a = k.cssHooks[t] || k.cssHooks[s]) && "get" in a && (i = a.get(e, !0, n)), void 0 === i && (i = _e(e, t, r)), "normal" === i && t in Ke && (i = Ke[t]), "" === n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i;
    }
  }), k.each(["height", "width"], function (e, u) {
    k.cssHooks[u] = {
      get: function get(e, t, n) {
        if (t) return !Ye.test(k.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? tt(e, u, n) : ue(e, Je, function () {
          return tt(e, u, n);
        });
      },
      set: function set(e, t, n) {
        var r,
            i = Fe(e),
            o = !y.scrollboxSize() && "absolute" === i.position,
            a = (o || n) && "border-box" === k.css(e, "boxSizing", !1, i),
            s = n ? et(e, u, n, a, i) : 0;
        return a && o && (s -= Math.ceil(e["offset" + u[0].toUpperCase() + u.slice(1)] - parseFloat(i[u]) - et(e, u, "border", !1, i) - .5)), s && (r = ne.exec(t)) && "px" !== (r[3] || "px") && (e.style[u] = t, t = k.css(e, u)), Ze(0, t, s);
      }
    };
  }), k.cssHooks.marginLeft = ze(y.reliableMarginLeft, function (e, t) {
    if (t) return (parseFloat(_e(e, "marginLeft")) || e.getBoundingClientRect().left - ue(e, {
      marginLeft: 0
    }, function () {
      return e.getBoundingClientRect().left;
    })) + "px";
  }), k.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function (i, o) {
    k.cssHooks[i + o] = {
      expand: function expand(e) {
        for (var t = 0, n = {}, r = "string" == typeof e ? e.split(" ") : [e]; t < 4; t++) {
          n[i + re[t] + o] = r[t] || r[t - 2] || r[0];
        }

        return n;
      }
    }, "margin" !== i && (k.cssHooks[i + o].set = Ze);
  }), k.fn.extend({
    css: function css(e, t) {
      return _(this, function (e, t, n) {
        var r,
            i,
            o = {},
            a = 0;

        if (Array.isArray(t)) {
          for (r = Fe(e), i = t.length; a < i; a++) {
            o[t[a]] = k.css(e, t[a], !1, r);
          }

          return o;
        }

        return void 0 !== n ? k.style(e, t, n) : k.css(e, t);
      }, e, t, 1 < arguments.length);
    }
  }), ((k.Tween = nt).prototype = {
    constructor: nt,
    init: function init(e, t, n, r, i, o) {
      this.elem = e, this.prop = n, this.easing = i || k.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (k.cssNumber[n] ? "" : "px");
    },
    cur: function cur() {
      var e = nt.propHooks[this.prop];
      return e && e.get ? e.get(this) : nt.propHooks._default.get(this);
    },
    run: function run(e) {
      var t,
          n = nt.propHooks[this.prop];
      return this.options.duration ? this.pos = t = k.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : nt.propHooks._default.set(this), this;
    }
  }).init.prototype = nt.prototype, (nt.propHooks = {
    _default: {
      get: function get(e) {
        var t;
        return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = k.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0;
      },
      set: function set(e) {
        k.fx.step[e.prop] ? k.fx.step[e.prop](e) : 1 !== e.elem.nodeType || !k.cssHooks[e.prop] && null == e.elem.style[Ge(e.prop)] ? e.elem[e.prop] = e.now : k.style(e.elem, e.prop, e.now + e.unit);
      }
    }
  }).scrollTop = nt.propHooks.scrollLeft = {
    set: function set(e) {
      e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now);
    }
  }, k.easing = {
    linear: function linear(e) {
      return e;
    },
    swing: function swing(e) {
      return .5 - Math.cos(e * Math.PI) / 2;
    },
    _default: "swing"
  }, k.fx = nt.prototype.init, k.fx.step = {};
  var rt,
      it,
      ot,
      at,
      st = /^(?:toggle|show|hide)$/,
      ut = /queueHooks$/;

  function lt() {
    it && (!1 === E.hidden && C.requestAnimationFrame ? C.requestAnimationFrame(lt) : C.setTimeout(lt, k.fx.interval), k.fx.tick());
  }

  function ct() {
    return C.setTimeout(function () {
      rt = void 0;
    }), rt = Date.now();
  }

  function ft(e, t) {
    var n,
        r = 0,
        i = {
      height: e
    };

    for (t = t ? 1 : 0; r < 4; r += 2 - t) {
      i["margin" + (n = re[r])] = i["padding" + n] = e;
    }

    return t && (i.opacity = i.width = e), i;
  }

  function pt(e, t, n) {
    for (var r, i = (dt.tweeners[t] || []).concat(dt.tweeners["*"]), o = 0, a = i.length; o < a; o++) {
      if (r = i[o].call(n, t, e)) return r;
    }
  }

  function dt(o, e, t) {
    var n,
        a,
        r = 0,
        i = dt.prefilters.length,
        s = k.Deferred().always(function () {
      delete u.elem;
    }),
        u = function u() {
      if (a) return !1;

      for (var e = rt || ct(), t = Math.max(0, l.startTime + l.duration - e), n = 1 - (t / l.duration || 0), r = 0, i = l.tweens.length; r < i; r++) {
        l.tweens[r].run(n);
      }

      return s.notifyWith(o, [l, n, t]), n < 1 && i ? t : (i || s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l]), !1);
    },
        l = s.promise({
      elem: o,
      props: k.extend({}, e),
      opts: k.extend(!0, {
        specialEasing: {},
        easing: k.easing._default
      }, t),
      originalProperties: e,
      originalOptions: t,
      startTime: rt || ct(),
      duration: t.duration,
      tweens: [],
      createTween: function createTween(e, t) {
        var n = k.Tween(o, l.opts, e, t, l.opts.specialEasing[e] || l.opts.easing);
        return l.tweens.push(n), n;
      },
      stop: function stop(e) {
        var t = 0,
            n = e ? l.tweens.length : 0;
        if (a) return this;

        for (a = !0; t < n; t++) {
          l.tweens[t].run(1);
        }

        return e ? (s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l, e])) : s.rejectWith(o, [l, e]), this;
      }
    }),
        c = l.props;

    for (!function (e, t) {
      var n, r, i, o, a;

      for (n in e) {
        if (i = t[r = V(n)], o = e[n], Array.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), (a = k.cssHooks[r]) && ("expand" in a)) for (n in o = a.expand(o), delete e[r], o) {
          (n in e) || (e[n] = o[n], t[n] = i);
        } else t[r] = i;
      }
    }(c, l.opts.specialEasing); r < i; r++) {
      if (n = dt.prefilters[r].call(l, o, c, l.opts)) return m(n.stop) && (k._queueHooks(l.elem, l.opts.queue).stop = n.stop.bind(n)), n;
    }

    return k.map(c, pt, l), m(l.opts.start) && l.opts.start.call(o, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), k.fx.timer(k.extend(u, {
      elem: o,
      anim: l,
      queue: l.opts.queue
    })), l;
  }

  k.Animation = k.extend(dt, {
    tweeners: {
      "*": [function (e, t) {
        var n = this.createTween(e, t);
        return le(n.elem, e, ne.exec(t), n), n;
      }]
    },
    tweener: function tweener(e, t) {
      m(e) ? (t = e, e = ["*"]) : e = e.match(R);

      for (var n, r = 0, i = e.length; r < i; r++) {
        n = e[r], dt.tweeners[n] = dt.tweeners[n] || [], dt.tweeners[n].unshift(t);
      }
    },
    prefilters: [function (e, t, n) {
      var r,
          i,
          o,
          a,
          s,
          u,
          l,
          c,
          f = "width" in t || "height" in t,
          p = this,
          d = {},
          h = e.style,
          g = e.nodeType && se(e),
          v = Q.get(e, "fxshow");

      for (r in n.queue || (null == (a = k._queueHooks(e, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function () {
        a.unqueued || s();
      }), a.unqueued++, p.always(function () {
        p.always(function () {
          a.unqueued--, k.queue(e, "fx").length || a.empty.fire();
        });
      })), t) {
        if (i = t[r], st.test(i)) {
          if (delete t[r], o = o || "toggle" === i, i === (g ? "hide" : "show")) {
            if ("show" !== i || !v || void 0 === v[r]) continue;
            g = !0;
          }

          d[r] = v && v[r] || k.style(e, r);
        }
      }

      if ((u = !k.isEmptyObject(t)) || !k.isEmptyObject(d)) for (r in f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = v && v.display) && (l = Q.get(e, "display")), "none" === (c = k.css(e, "display")) && (l ? c = l : (fe([e], !0), l = e.style.display || l, c = k.css(e, "display"), fe([e]))), ("inline" === c || "inline-block" === c && null != l) && "none" === k.css(e, "float") && (u || (p.done(function () {
        h.display = l;
      }), null == l && (c = h.display, l = "none" === c ? "" : c)), h.display = "inline-block")), n.overflow && (h.overflow = "hidden", p.always(function () {
        h.overflow = n.overflow[0], h.overflowX = n.overflow[1], h.overflowY = n.overflow[2];
      })), u = !1, d) {
        u || (v ? "hidden" in v && (g = v.hidden) : v = Q.access(e, "fxshow", {
          display: l
        }), o && (v.hidden = !g), g && fe([e], !0), p.done(function () {
          for (r in g || fe([e]), Q.remove(e, "fxshow"), d) {
            k.style(e, r, d[r]);
          }
        })), u = pt(g ? v[r] : 0, r, p), r in v || (v[r] = u.start, g && (u.end = u.start, u.start = 0));
      }
    }],
    prefilter: function prefilter(e, t) {
      t ? dt.prefilters.unshift(e) : dt.prefilters.push(e);
    }
  }), k.speed = function (e, t, n) {
    var r = e && "object" == _typeof(e) ? k.extend({}, e) : {
      complete: n || !n && t || m(e) && e,
      duration: e,
      easing: n && t || t && !m(t) && t
    };
    return k.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in k.fx.speeds ? r.duration = k.fx.speeds[r.duration] : r.duration = k.fx.speeds._default), null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function () {
      m(r.old) && r.old.call(this), r.queue && k.dequeue(this, r.queue);
    }, r;
  }, k.fn.extend({
    fadeTo: function fadeTo(e, t, n, r) {
      return this.filter(se).css("opacity", 0).show().end().animate({
        opacity: t
      }, e, n, r);
    },
    animate: function animate(t, e, n, r) {
      var i = k.isEmptyObject(t),
          o = k.speed(e, n, r),
          a = function a() {
        var e = dt(this, k.extend({}, t), o);
        (i || Q.get(this, "finish")) && e.stop(!0);
      };

      return a.finish = a, i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a);
    },
    stop: function stop(i, e, o) {
      var a = function a(e) {
        var t = e.stop;
        delete e.stop, t(o);
      };

      return "string" != typeof i && (o = e, e = i, i = void 0), e && !1 !== i && this.queue(i || "fx", []), this.each(function () {
        var e = !0,
            t = null != i && i + "queueHooks",
            n = k.timers,
            r = Q.get(this);
        if (t) r[t] && r[t].stop && a(r[t]);else for (t in r) {
          r[t] && r[t].stop && ut.test(t) && a(r[t]);
        }

        for (t = n.length; t--;) {
          n[t].elem !== this || null != i && n[t].queue !== i || (n[t].anim.stop(o), e = !1, n.splice(t, 1));
        }

        !e && o || k.dequeue(this, i);
      });
    },
    finish: function finish(a) {
      return !1 !== a && (a = a || "fx"), this.each(function () {
        var e,
            t = Q.get(this),
            n = t[a + "queue"],
            r = t[a + "queueHooks"],
            i = k.timers,
            o = n ? n.length : 0;

        for (t.finish = !0, k.queue(this, a, []), r && r.stop && r.stop.call(this, !0), e = i.length; e--;) {
          i[e].elem === this && i[e].queue === a && (i[e].anim.stop(!0), i.splice(e, 1));
        }

        for (e = 0; e < o; e++) {
          n[e] && n[e].finish && n[e].finish.call(this);
        }

        delete t.finish;
      });
    }
  }), k.each(["toggle", "show", "hide"], function (e, r) {
    var i = k.fn[r];

    k.fn[r] = function (e, t, n) {
      return null == e || "boolean" == typeof e ? i.apply(this, arguments) : this.animate(ft(r, !0), e, t, n);
    };
  }), k.each({
    slideDown: ft("show"),
    slideUp: ft("hide"),
    slideToggle: ft("toggle"),
    fadeIn: {
      opacity: "show"
    },
    fadeOut: {
      opacity: "hide"
    },
    fadeToggle: {
      opacity: "toggle"
    }
  }, function (e, r) {
    k.fn[e] = function (e, t, n) {
      return this.animate(r, e, t, n);
    };
  }), k.timers = [], k.fx.tick = function () {
    var e,
        t = 0,
        n = k.timers;

    for (rt = Date.now(); t < n.length; t++) {
      (e = n[t])() || n[t] !== e || n.splice(t--, 1);
    }

    n.length || k.fx.stop(), rt = void 0;
  }, k.fx.timer = function (e) {
    k.timers.push(e), k.fx.start();
  }, k.fx.interval = 13, k.fx.start = function () {
    it || (it = !0, lt());
  }, k.fx.stop = function () {
    it = null;
  }, k.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  }, k.fn.delay = function (r, e) {
    return r = k.fx && k.fx.speeds[r] || r, e = e || "fx", this.queue(e, function (e, t) {
      var n = C.setTimeout(e, r);

      t.stop = function () {
        C.clearTimeout(n);
      };
    });
  }, ot = E.createElement("input"), at = E.createElement("select").appendChild(E.createElement("option")), ot.type = "checkbox", y.checkOn = "" !== ot.value, y.optSelected = at.selected, (ot = E.createElement("input")).value = "t", ot.type = "radio", y.radioValue = "t" === ot.value;
  var ht,
      gt = k.expr.attrHandle;
  k.fn.extend({
    attr: function attr(e, t) {
      return _(this, k.attr, e, t, 1 < arguments.length);
    },
    removeAttr: function removeAttr(e) {
      return this.each(function () {
        k.removeAttr(this, e);
      });
    }
  }), k.extend({
    attr: function attr(e, t, n) {
      var r,
          i,
          o = e.nodeType;
      if (3 !== o && 8 !== o && 2 !== o) return "undefined" == typeof e.getAttribute ? k.prop(e, t, n) : (1 === o && k.isXMLDoc(e) || (i = k.attrHooks[t.toLowerCase()] || (k.expr.match.bool.test(t) ? ht : void 0)), void 0 !== n ? null === n ? void k.removeAttr(e, t) : i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), n) : i && "get" in i && null !== (r = i.get(e, t)) ? r : null == (r = k.find.attr(e, t)) ? void 0 : r);
    },
    attrHooks: {
      type: {
        set: function set(e, t) {
          if (!y.radioValue && "radio" === t && A(e, "input")) {
            var n = e.value;
            return e.setAttribute("type", t), n && (e.value = n), t;
          }
        }
      }
    },
    removeAttr: function removeAttr(e, t) {
      var n,
          r = 0,
          i = t && t.match(R);
      if (i && 1 === e.nodeType) while (n = i[r++]) {
        e.removeAttribute(n);
      }
    }
  }), ht = {
    set: function set(e, t, n) {
      return !1 === t ? k.removeAttr(e, n) : e.setAttribute(n, n), n;
    }
  }, k.each(k.expr.match.bool.source.match(/\w+/g), function (e, t) {
    var a = gt[t] || k.find.attr;

    gt[t] = function (e, t, n) {
      var r,
          i,
          o = t.toLowerCase();
      return n || (i = gt[o], gt[o] = r, r = null != a(e, t, n) ? o : null, gt[o] = i), r;
    };
  });
  var vt = /^(?:input|select|textarea|button)$/i,
      yt = /^(?:a|area)$/i;

  function mt(e) {
    return (e.match(R) || []).join(" ");
  }

  function xt(e) {
    return e.getAttribute && e.getAttribute("class") || "";
  }

  function bt(e) {
    return Array.isArray(e) ? e : "string" == typeof e && e.match(R) || [];
  }

  k.fn.extend({
    prop: function prop(e, t) {
      return _(this, k.prop, e, t, 1 < arguments.length);
    },
    removeProp: function removeProp(e) {
      return this.each(function () {
        delete this[k.propFix[e] || e];
      });
    }
  }), k.extend({
    prop: function prop(e, t, n) {
      var r,
          i,
          o = e.nodeType;
      if (3 !== o && 8 !== o && 2 !== o) return 1 === o && k.isXMLDoc(e) || (t = k.propFix[t] || t, i = k.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t];
    },
    propHooks: {
      tabIndex: {
        get: function get(e) {
          var t = k.find.attr(e, "tabindex");
          return t ? parseInt(t, 10) : vt.test(e.nodeName) || yt.test(e.nodeName) && e.href ? 0 : -1;
        }
      }
    },
    propFix: {
      "for": "htmlFor",
      "class": "className"
    }
  }), y.optSelected || (k.propHooks.selected = {
    get: function get(e) {
      var t = e.parentNode;
      return t && t.parentNode && t.parentNode.selectedIndex, null;
    },
    set: function set(e) {
      var t = e.parentNode;
      t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex);
    }
  }), k.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
    k.propFix[this.toLowerCase()] = this;
  }), k.fn.extend({
    addClass: function addClass(t) {
      var e,
          n,
          r,
          i,
          o,
          a,
          s,
          u = 0;
      if (m(t)) return this.each(function (e) {
        k(this).addClass(t.call(this, e, xt(this)));
      });
      if ((e = bt(t)).length) while (n = this[u++]) {
        if (i = xt(n), r = 1 === n.nodeType && " " + mt(i) + " ") {
          a = 0;

          while (o = e[a++]) {
            r.indexOf(" " + o + " ") < 0 && (r += o + " ");
          }

          i !== (s = mt(r)) && n.setAttribute("class", s);
        }
      }
      return this;
    },
    removeClass: function removeClass(t) {
      var e,
          n,
          r,
          i,
          o,
          a,
          s,
          u = 0;
      if (m(t)) return this.each(function (e) {
        k(this).removeClass(t.call(this, e, xt(this)));
      });
      if (!arguments.length) return this.attr("class", "");
      if ((e = bt(t)).length) while (n = this[u++]) {
        if (i = xt(n), r = 1 === n.nodeType && " " + mt(i) + " ") {
          a = 0;

          while (o = e[a++]) {
            while (-1 < r.indexOf(" " + o + " ")) {
              r = r.replace(" " + o + " ", " ");
            }
          }

          i !== (s = mt(r)) && n.setAttribute("class", s);
        }
      }
      return this;
    },
    toggleClass: function toggleClass(i, t) {
      var o = _typeof(i),
          a = "string" === o || Array.isArray(i);

      return "boolean" == typeof t && a ? t ? this.addClass(i) : this.removeClass(i) : m(i) ? this.each(function (e) {
        k(this).toggleClass(i.call(this, e, xt(this), t), t);
      }) : this.each(function () {
        var e, t, n, r;

        if (a) {
          t = 0, n = k(this), r = bt(i);

          while (e = r[t++]) {
            n.hasClass(e) ? n.removeClass(e) : n.addClass(e);
          }
        } else void 0 !== i && "boolean" !== o || ((e = xt(this)) && Q.set(this, "__className__", e), this.setAttribute && this.setAttribute("class", e || !1 === i ? "" : Q.get(this, "__className__") || ""));
      });
    },
    hasClass: function hasClass(e) {
      var t,
          n,
          r = 0;
      t = " " + e + " ";

      while (n = this[r++]) {
        if (1 === n.nodeType && -1 < (" " + mt(xt(n)) + " ").indexOf(t)) return !0;
      }

      return !1;
    }
  });
  var wt = /\r/g;
  k.fn.extend({
    val: function val(n) {
      var r,
          e,
          i,
          t = this[0];
      return arguments.length ? (i = m(n), this.each(function (e) {
        var t;
        1 === this.nodeType && (null == (t = i ? n.call(this, e, k(this).val()) : n) ? t = "" : "number" == typeof t ? t += "" : Array.isArray(t) && (t = k.map(t, function (e) {
          return null == e ? "" : e + "";
        })), (r = k.valHooks[this.type] || k.valHooks[this.nodeName.toLowerCase()]) && "set" in r && void 0 !== r.set(this, t, "value") || (this.value = t));
      })) : t ? (r = k.valHooks[t.type] || k.valHooks[t.nodeName.toLowerCase()]) && "get" in r && void 0 !== (e = r.get(t, "value")) ? e : "string" == typeof (e = t.value) ? e.replace(wt, "") : null == e ? "" : e : void 0;
    }
  }), k.extend({
    valHooks: {
      option: {
        get: function get(e) {
          var t = k.find.attr(e, "value");
          return null != t ? t : mt(k.text(e));
        }
      },
      select: {
        get: function get(e) {
          var t,
              n,
              r,
              i = e.options,
              o = e.selectedIndex,
              a = "select-one" === e.type,
              s = a ? null : [],
              u = a ? o + 1 : i.length;

          for (r = o < 0 ? u : a ? o : 0; r < u; r++) {
            if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !A(n.parentNode, "optgroup"))) {
              if (t = k(n).val(), a) return t;
              s.push(t);
            }
          }

          return s;
        },
        set: function set(e, t) {
          var n,
              r,
              i = e.options,
              o = k.makeArray(t),
              a = i.length;

          while (a--) {
            ((r = i[a]).selected = -1 < k.inArray(k.valHooks.option.get(r), o)) && (n = !0);
          }

          return n || (e.selectedIndex = -1), o;
        }
      }
    }
  }), k.each(["radio", "checkbox"], function () {
    k.valHooks[this] = {
      set: function set(e, t) {
        if (Array.isArray(t)) return e.checked = -1 < k.inArray(k(e).val(), t);
      }
    }, y.checkOn || (k.valHooks[this].get = function (e) {
      return null === e.getAttribute("value") ? "on" : e.value;
    });
  }), y.focusin = "onfocusin" in C;

  var Tt = /^(?:focusinfocus|focusoutblur)$/,
      Ct = function Ct(e) {
    e.stopPropagation();
  };

  k.extend(k.event, {
    trigger: function trigger(e, t, n, r) {
      var i,
          o,
          a,
          s,
          u,
          l,
          c,
          f,
          p = [n || E],
          d = v.call(e, "type") ? e.type : e,
          h = v.call(e, "namespace") ? e.namespace.split(".") : [];

      if (o = f = a = n = n || E, 3 !== n.nodeType && 8 !== n.nodeType && !Tt.test(d + k.event.triggered) && (-1 < d.indexOf(".") && (d = (h = d.split(".")).shift(), h.sort()), u = d.indexOf(":") < 0 && "on" + d, (e = e[k.expando] ? e : new k.Event(d, "object" == _typeof(e) && e)).isTrigger = r ? 2 : 3, e.namespace = h.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = n), t = null == t ? [e] : k.makeArray(t, [e]), c = k.event.special[d] || {}, r || !c.trigger || !1 !== c.trigger.apply(n, t))) {
        if (!r && !c.noBubble && !x(n)) {
          for (s = c.delegateType || d, Tt.test(s + d) || (o = o.parentNode); o; o = o.parentNode) {
            p.push(o), a = o;
          }

          a === (n.ownerDocument || E) && p.push(a.defaultView || a.parentWindow || C);
        }

        i = 0;

        while ((o = p[i++]) && !e.isPropagationStopped()) {
          f = o, e.type = 1 < i ? s : c.bindType || d, (l = (Q.get(o, "events") || {})[e.type] && Q.get(o, "handle")) && l.apply(o, t), (l = u && o[u]) && l.apply && G(o) && (e.result = l.apply(o, t), !1 === e.result && e.preventDefault());
        }

        return e.type = d, r || e.isDefaultPrevented() || c._default && !1 !== c._default.apply(p.pop(), t) || !G(n) || u && m(n[d]) && !x(n) && ((a = n[u]) && (n[u] = null), k.event.triggered = d, e.isPropagationStopped() && f.addEventListener(d, Ct), n[d](), e.isPropagationStopped() && f.removeEventListener(d, Ct), k.event.triggered = void 0, a && (n[u] = a)), e.result;
      }
    },
    simulate: function simulate(e, t, n) {
      var r = k.extend(new k.Event(), n, {
        type: e,
        isSimulated: !0
      });
      k.event.trigger(r, null, t);
    }
  }), k.fn.extend({
    trigger: function trigger(e, t) {
      return this.each(function () {
        k.event.trigger(e, t, this);
      });
    },
    triggerHandler: function triggerHandler(e, t) {
      var n = this[0];
      if (n) return k.event.trigger(e, t, n, !0);
    }
  }), y.focusin || k.each({
    focus: "focusin",
    blur: "focusout"
  }, function (n, r) {
    var i = function i(e) {
      k.event.simulate(r, e.target, k.event.fix(e));
    };

    k.event.special[r] = {
      setup: function setup() {
        var e = this.ownerDocument || this,
            t = Q.access(e, r);
        t || e.addEventListener(n, i, !0), Q.access(e, r, (t || 0) + 1);
      },
      teardown: function teardown() {
        var e = this.ownerDocument || this,
            t = Q.access(e, r) - 1;
        t ? Q.access(e, r, t) : (e.removeEventListener(n, i, !0), Q.remove(e, r));
      }
    };
  });
  var Et = C.location,
      kt = Date.now(),
      St = /\?/;

  k.parseXML = function (e) {
    var t;
    if (!e || "string" != typeof e) return null;

    try {
      t = new C.DOMParser().parseFromString(e, "text/xml");
    } catch (e) {
      t = void 0;
    }

    return t && !t.getElementsByTagName("parsererror").length || k.error("Invalid XML: " + e), t;
  };

  var Nt = /\[\]$/,
      At = /\r?\n/g,
      Dt = /^(?:submit|button|image|reset|file)$/i,
      jt = /^(?:input|select|textarea|keygen)/i;

  function qt(n, e, r, i) {
    var t;
    if (Array.isArray(e)) k.each(e, function (e, t) {
      r || Nt.test(n) ? i(n, t) : qt(n + "[" + ("object" == _typeof(t) && null != t ? e : "") + "]", t, r, i);
    });else if (r || "object" !== w(e)) i(n, e);else for (t in e) {
      qt(n + "[" + t + "]", e[t], r, i);
    }
  }

  k.param = function (e, t) {
    var n,
        r = [],
        i = function i(e, t) {
      var n = m(t) ? t() : t;
      r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n);
    };

    if (null == e) return "";
    if (Array.isArray(e) || e.jquery && !k.isPlainObject(e)) k.each(e, function () {
      i(this.name, this.value);
    });else for (n in e) {
      qt(n, e[n], t, i);
    }
    return r.join("&");
  }, k.fn.extend({
    serialize: function serialize() {
      return k.param(this.serializeArray());
    },
    serializeArray: function serializeArray() {
      return this.map(function () {
        var e = k.prop(this, "elements");
        return e ? k.makeArray(e) : this;
      }).filter(function () {
        var e = this.type;
        return this.name && !k(this).is(":disabled") && jt.test(this.nodeName) && !Dt.test(e) && (this.checked || !pe.test(e));
      }).map(function (e, t) {
        var n = k(this).val();
        return null == n ? null : Array.isArray(n) ? k.map(n, function (e) {
          return {
            name: t.name,
            value: e.replace(At, "\r\n")
          };
        }) : {
          name: t.name,
          value: n.replace(At, "\r\n")
        };
      }).get();
    }
  });
  var Lt = /%20/g,
      Ht = /#.*$/,
      Ot = /([?&])_=[^&]*/,
      Pt = /^(.*?):[ \t]*([^\r\n]*)$/gm,
      Rt = /^(?:GET|HEAD)$/,
      Mt = /^\/\//,
      It = {},
      Wt = {},
      $t = "*/".concat("*"),
      Ft = E.createElement("a");

  function Bt(o) {
    return function (e, t) {
      "string" != typeof e && (t = e, e = "*");
      var n,
          r = 0,
          i = e.toLowerCase().match(R) || [];
      if (m(t)) while (n = i[r++]) {
        "+" === n[0] ? (n = n.slice(1) || "*", (o[n] = o[n] || []).unshift(t)) : (o[n] = o[n] || []).push(t);
      }
    };
  }

  function _t(t, i, o, a) {
    var s = {},
        u = t === Wt;

    function l(e) {
      var r;
      return s[e] = !0, k.each(t[e] || [], function (e, t) {
        var n = t(i, o, a);
        return "string" != typeof n || u || s[n] ? u ? !(r = n) : void 0 : (i.dataTypes.unshift(n), l(n), !1);
      }), r;
    }

    return l(i.dataTypes[0]) || !s["*"] && l("*");
  }

  function zt(e, t) {
    var n,
        r,
        i = k.ajaxSettings.flatOptions || {};

    for (n in t) {
      void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]);
    }

    return r && k.extend(!0, e, r), e;
  }

  Ft.href = Et.href, k.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: Et.href,
      type: "GET",
      isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Et.protocol),
      global: !0,
      processData: !0,
      async: !0,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": $t,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": !0,
        "text json": JSON.parse,
        "text xml": k.parseXML
      },
      flatOptions: {
        url: !0,
        context: !0
      }
    },
    ajaxSetup: function ajaxSetup(e, t) {
      return t ? zt(zt(e, k.ajaxSettings), t) : zt(k.ajaxSettings, e);
    },
    ajaxPrefilter: Bt(It),
    ajaxTransport: Bt(Wt),
    ajax: function ajax(e, t) {
      "object" == _typeof(e) && (t = e, e = void 0), t = t || {};
      var c,
          f,
          p,
          n,
          d,
          r,
          h,
          g,
          i,
          o,
          v = k.ajaxSetup({}, t),
          y = v.context || v,
          m = v.context && (y.nodeType || y.jquery) ? k(y) : k.event,
          x = k.Deferred(),
          b = k.Callbacks("once memory"),
          w = v.statusCode || {},
          a = {},
          s = {},
          u = "canceled",
          T = {
        readyState: 0,
        getResponseHeader: function getResponseHeader(e) {
          var t;

          if (h) {
            if (!n) {
              n = {};

              while (t = Pt.exec(p)) {
                n[t[1].toLowerCase() + " "] = (n[t[1].toLowerCase() + " "] || []).concat(t[2]);
              }
            }

            t = n[e.toLowerCase() + " "];
          }

          return null == t ? null : t.join(", ");
        },
        getAllResponseHeaders: function getAllResponseHeaders() {
          return h ? p : null;
        },
        setRequestHeader: function setRequestHeader(e, t) {
          return null == h && (e = s[e.toLowerCase()] = s[e.toLowerCase()] || e, a[e] = t), this;
        },
        overrideMimeType: function overrideMimeType(e) {
          return null == h && (v.mimeType = e), this;
        },
        statusCode: function statusCode(e) {
          var t;
          if (e) if (h) T.always(e[T.status]);else for (t in e) {
            w[t] = [w[t], e[t]];
          }
          return this;
        },
        abort: function abort(e) {
          var t = e || u;
          return c && c.abort(t), l(0, t), this;
        }
      };

      if (x.promise(T), v.url = ((e || v.url || Et.href) + "").replace(Mt, Et.protocol + "//"), v.type = t.method || t.type || v.method || v.type, v.dataTypes = (v.dataType || "*").toLowerCase().match(R) || [""], null == v.crossDomain) {
        r = E.createElement("a");

        try {
          r.href = v.url, r.href = r.href, v.crossDomain = Ft.protocol + "//" + Ft.host != r.protocol + "//" + r.host;
        } catch (e) {
          v.crossDomain = !0;
        }
      }

      if (v.data && v.processData && "string" != typeof v.data && (v.data = k.param(v.data, v.traditional)), _t(It, v, t, T), h) return T;

      for (i in (g = k.event && v.global) && 0 == k.active++ && k.event.trigger("ajaxStart"), v.type = v.type.toUpperCase(), v.hasContent = !Rt.test(v.type), f = v.url.replace(Ht, ""), v.hasContent ? v.data && v.processData && 0 === (v.contentType || "").indexOf("application/x-www-form-urlencoded") && (v.data = v.data.replace(Lt, "+")) : (o = v.url.slice(f.length), v.data && (v.processData || "string" == typeof v.data) && (f += (St.test(f) ? "&" : "?") + v.data, delete v.data), !1 === v.cache && (f = f.replace(Ot, "$1"), o = (St.test(f) ? "&" : "?") + "_=" + kt++ + o), v.url = f + o), v.ifModified && (k.lastModified[f] && T.setRequestHeader("If-Modified-Since", k.lastModified[f]), k.etag[f] && T.setRequestHeader("If-None-Match", k.etag[f])), (v.data && v.hasContent && !1 !== v.contentType || t.contentType) && T.setRequestHeader("Content-Type", v.contentType), T.setRequestHeader("Accept", v.dataTypes[0] && v.accepts[v.dataTypes[0]] ? v.accepts[v.dataTypes[0]] + ("*" !== v.dataTypes[0] ? ", " + $t + "; q=0.01" : "") : v.accepts["*"]), v.headers) {
        T.setRequestHeader(i, v.headers[i]);
      }

      if (v.beforeSend && (!1 === v.beforeSend.call(y, T, v) || h)) return T.abort();

      if (u = "abort", b.add(v.complete), T.done(v.success), T.fail(v.error), c = _t(Wt, v, t, T)) {
        if (T.readyState = 1, g && m.trigger("ajaxSend", [T, v]), h) return T;
        v.async && 0 < v.timeout && (d = C.setTimeout(function () {
          T.abort("timeout");
        }, v.timeout));

        try {
          h = !1, c.send(a, l);
        } catch (e) {
          if (h) throw e;
          l(-1, e);
        }
      } else l(-1, "No Transport");

      function l(e, t, n, r) {
        var i,
            o,
            a,
            s,
            u,
            l = t;
        h || (h = !0, d && C.clearTimeout(d), c = void 0, p = r || "", T.readyState = 0 < e ? 4 : 0, i = 200 <= e && e < 300 || 304 === e, n && (s = function (e, t, n) {
          var r,
              i,
              o,
              a,
              s = e.contents,
              u = e.dataTypes;

          while ("*" === u[0]) {
            u.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type"));
          }

          if (r) for (i in s) {
            if (s[i] && s[i].test(r)) {
              u.unshift(i);
              break;
            }
          }
          if (u[0] in n) o = u[0];else {
            for (i in n) {
              if (!u[0] || e.converters[i + " " + u[0]]) {
                o = i;
                break;
              }

              a || (a = i);
            }

            o = o || a;
          }
          if (o) return o !== u[0] && u.unshift(o), n[o];
        }(v, T, n)), s = function (e, t, n, r) {
          var i,
              o,
              a,
              s,
              u,
              l = {},
              c = e.dataTypes.slice();
          if (c[1]) for (a in e.converters) {
            l[a.toLowerCase()] = e.converters[a];
          }
          o = c.shift();

          while (o) {
            if (e.responseFields[o] && (n[e.responseFields[o]] = t), !u && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), u = o, o = c.shift()) if ("*" === o) o = u;else if ("*" !== u && u !== o) {
              if (!(a = l[u + " " + o] || l["* " + o])) for (i in l) {
                if ((s = i.split(" "))[1] === o && (a = l[u + " " + s[0]] || l["* " + s[0]])) {
                  !0 === a ? a = l[i] : !0 !== l[i] && (o = s[0], c.unshift(s[1]));
                  break;
                }
              }
              if (!0 !== a) if (a && e["throws"]) t = a(t);else try {
                t = a(t);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: a ? e : "No conversion from " + u + " to " + o
                };
              }
            }
          }

          return {
            state: "success",
            data: t
          };
        }(v, s, T, i), i ? (v.ifModified && ((u = T.getResponseHeader("Last-Modified")) && (k.lastModified[f] = u), (u = T.getResponseHeader("etag")) && (k.etag[f] = u)), 204 === e || "HEAD" === v.type ? l = "nocontent" : 304 === e ? l = "notmodified" : (l = s.state, o = s.data, i = !(a = s.error))) : (a = l, !e && l || (l = "error", e < 0 && (e = 0))), T.status = e, T.statusText = (t || l) + "", i ? x.resolveWith(y, [o, l, T]) : x.rejectWith(y, [T, l, a]), T.statusCode(w), w = void 0, g && m.trigger(i ? "ajaxSuccess" : "ajaxError", [T, v, i ? o : a]), b.fireWith(y, [T, l]), g && (m.trigger("ajaxComplete", [T, v]), --k.active || k.event.trigger("ajaxStop")));
      }

      return T;
    },
    getJSON: function getJSON(e, t, n) {
      return k.get(e, t, n, "json");
    },
    getScript: function getScript(e, t) {
      return k.get(e, void 0, t, "script");
    }
  }), k.each(["get", "post"], function (e, i) {
    k[i] = function (e, t, n, r) {
      return m(t) && (r = r || n, n = t, t = void 0), k.ajax(k.extend({
        url: e,
        type: i,
        dataType: r,
        data: t,
        success: n
      }, k.isPlainObject(e) && e));
    };
  }), k._evalUrl = function (e, t) {
    return k.ajax({
      url: e,
      type: "GET",
      dataType: "script",
      cache: !0,
      async: !1,
      global: !1,
      converters: {
        "text script": function textScript() {}
      },
      dataFilter: function dataFilter(e) {
        k.globalEval(e, t);
      }
    });
  }, k.fn.extend({
    wrapAll: function wrapAll(e) {
      var t;
      return this[0] && (m(e) && (e = e.call(this[0])), t = k(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function () {
        var e = this;

        while (e.firstElementChild) {
          e = e.firstElementChild;
        }

        return e;
      }).append(this)), this;
    },
    wrapInner: function wrapInner(n) {
      return m(n) ? this.each(function (e) {
        k(this).wrapInner(n.call(this, e));
      }) : this.each(function () {
        var e = k(this),
            t = e.contents();
        t.length ? t.wrapAll(n) : e.append(n);
      });
    },
    wrap: function wrap(t) {
      var n = m(t);
      return this.each(function (e) {
        k(this).wrapAll(n ? t.call(this, e) : t);
      });
    },
    unwrap: function unwrap(e) {
      return this.parent(e).not("body").each(function () {
        k(this).replaceWith(this.childNodes);
      }), this;
    }
  }), k.expr.pseudos.hidden = function (e) {
    return !k.expr.pseudos.visible(e);
  }, k.expr.pseudos.visible = function (e) {
    return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length);
  }, k.ajaxSettings.xhr = function () {
    try {
      return new C.XMLHttpRequest();
    } catch (e) {}
  };
  var Ut = {
    0: 200,
    1223: 204
  },
      Xt = k.ajaxSettings.xhr();
  y.cors = !!Xt && "withCredentials" in Xt, y.ajax = Xt = !!Xt, k.ajaxTransport(function (i) {
    var _o, a;

    if (y.cors || Xt && !i.crossDomain) return {
      send: function send(e, t) {
        var n,
            r = i.xhr();
        if (r.open(i.type, i.url, i.async, i.username, i.password), i.xhrFields) for (n in i.xhrFields) {
          r[n] = i.xhrFields[n];
        }

        for (n in i.mimeType && r.overrideMimeType && r.overrideMimeType(i.mimeType), i.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest"), e) {
          r.setRequestHeader(n, e[n]);
        }

        _o = function o(e) {
          return function () {
            _o && (_o = a = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, "abort" === e ? r.abort() : "error" === e ? "number" != typeof r.status ? t(0, "error") : t(r.status, r.statusText) : t(Ut[r.status] || r.status, r.statusText, "text" !== (r.responseType || "text") || "string" != typeof r.responseText ? {
              binary: r.response
            } : {
              text: r.responseText
            }, r.getAllResponseHeaders()));
          };
        }, r.onload = _o(), a = r.onerror = r.ontimeout = _o("error"), void 0 !== r.onabort ? r.onabort = a : r.onreadystatechange = function () {
          4 === r.readyState && C.setTimeout(function () {
            _o && a();
          });
        }, _o = _o("abort");

        try {
          r.send(i.hasContent && i.data || null);
        } catch (e) {
          if (_o) throw e;
        }
      },
      abort: function abort() {
        _o && _o();
      }
    };
  }), k.ajaxPrefilter(function (e) {
    e.crossDomain && (e.contents.script = !1);
  }), k.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /\b(?:java|ecma)script\b/
    },
    converters: {
      "text script": function textScript(e) {
        return k.globalEval(e), e;
      }
    }
  }), k.ajaxPrefilter("script", function (e) {
    void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET");
  }), k.ajaxTransport("script", function (n) {
    var r, _i;

    if (n.crossDomain || n.scriptAttrs) return {
      send: function send(e, t) {
        r = k("<script>").attr(n.scriptAttrs || {}).prop({
          charset: n.scriptCharset,
          src: n.url
        }).on("load error", _i = function i(e) {
          r.remove(), _i = null, e && t("error" === e.type ? 404 : 200, e.type);
        }), E.head.appendChild(r[0]);
      },
      abort: function abort() {
        _i && _i();
      }
    };
  });
  var Vt,
      Gt = [],
      Yt = /(=)\?(?=&|$)|\?\?/;
  k.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function jsonpCallback() {
      var e = Gt.pop() || k.expando + "_" + kt++;
      return this[e] = !0, e;
    }
  }), k.ajaxPrefilter("json jsonp", function (e, t, n) {
    var r,
        i,
        o,
        a = !1 !== e.jsonp && (Yt.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Yt.test(e.data) && "data");
    if (a || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = m(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, a ? e[a] = e[a].replace(Yt, "$1" + r) : !1 !== e.jsonp && (e.url += (St.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function () {
      return o || k.error(r + " was not called"), o[0];
    }, e.dataTypes[0] = "json", i = C[r], C[r] = function () {
      o = arguments;
    }, n.always(function () {
      void 0 === i ? k(C).removeProp(r) : C[r] = i, e[r] && (e.jsonpCallback = t.jsonpCallback, Gt.push(r)), o && m(i) && i(o[0]), o = i = void 0;
    }), "script";
  }), y.createHTMLDocument = ((Vt = E.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === Vt.childNodes.length), k.parseHTML = function (e, t, n) {
    return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (y.createHTMLDocument ? ((r = (t = E.implementation.createHTMLDocument("")).createElement("base")).href = E.location.href, t.head.appendChild(r)) : t = E), o = !n && [], (i = D.exec(e)) ? [t.createElement(i[1])] : (i = we([e], t, o), o && o.length && k(o).remove(), k.merge([], i.childNodes)));
    var r, i, o;
  }, k.fn.load = function (e, t, n) {
    var r,
        i,
        o,
        a = this,
        s = e.indexOf(" ");
    return -1 < s && (r = mt(e.slice(s)), e = e.slice(0, s)), m(t) ? (n = t, t = void 0) : t && "object" == _typeof(t) && (i = "POST"), 0 < a.length && k.ajax({
      url: e,
      type: i || "GET",
      dataType: "html",
      data: t
    }).done(function (e) {
      o = arguments, a.html(r ? k("<div>").append(k.parseHTML(e)).find(r) : e);
    }).always(n && function (e, t) {
      a.each(function () {
        n.apply(this, o || [e.responseText, t, e]);
      });
    }), this;
  }, k.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) {
    k.fn[t] = function (e) {
      return this.on(t, e);
    };
  }), k.expr.pseudos.animated = function (t) {
    return k.grep(k.timers, function (e) {
      return t === e.elem;
    }).length;
  }, k.offset = {
    setOffset: function setOffset(e, t, n) {
      var r,
          i,
          o,
          a,
          s,
          u,
          l = k.css(e, "position"),
          c = k(e),
          f = {};
      "static" === l && (e.style.position = "relative"), s = c.offset(), o = k.css(e, "top"), u = k.css(e, "left"), ("absolute" === l || "fixed" === l) && -1 < (o + u).indexOf("auto") ? (a = (r = c.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(u) || 0), m(t) && (t = t.call(e, n, k.extend({}, s))), null != t.top && (f.top = t.top - s.top + a), null != t.left && (f.left = t.left - s.left + i), "using" in t ? t.using.call(e, f) : c.css(f);
    }
  }, k.fn.extend({
    offset: function offset(t) {
      if (arguments.length) return void 0 === t ? this : this.each(function (e) {
        k.offset.setOffset(this, t, e);
      });
      var e,
          n,
          r = this[0];
      return r ? r.getClientRects().length ? (e = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, {
        top: e.top + n.pageYOffset,
        left: e.left + n.pageXOffset
      }) : {
        top: 0,
        left: 0
      } : void 0;
    },
    position: function position() {
      if (this[0]) {
        var e,
            t,
            n,
            r = this[0],
            i = {
          top: 0,
          left: 0
        };
        if ("fixed" === k.css(r, "position")) t = r.getBoundingClientRect();else {
          t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement;

          while (e && (e === n.body || e === n.documentElement) && "static" === k.css(e, "position")) {
            e = e.parentNode;
          }

          e && e !== r && 1 === e.nodeType && ((i = k(e).offset()).top += k.css(e, "borderTopWidth", !0), i.left += k.css(e, "borderLeftWidth", !0));
        }
        return {
          top: t.top - i.top - k.css(r, "marginTop", !0),
          left: t.left - i.left - k.css(r, "marginLeft", !0)
        };
      }
    },
    offsetParent: function offsetParent() {
      return this.map(function () {
        var e = this.offsetParent;

        while (e && "static" === k.css(e, "position")) {
          e = e.offsetParent;
        }

        return e || ie;
      });
    }
  }), k.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function (t, i) {
    var o = "pageYOffset" === i;

    k.fn[t] = function (e) {
      return _(this, function (e, t, n) {
        var r;
        if (x(e) ? r = e : 9 === e.nodeType && (r = e.defaultView), void 0 === n) return r ? r[i] : e[t];
        r ? r.scrollTo(o ? r.pageXOffset : n, o ? n : r.pageYOffset) : e[t] = n;
      }, t, e, arguments.length);
    };
  }), k.each(["top", "left"], function (e, n) {
    k.cssHooks[n] = ze(y.pixelPosition, function (e, t) {
      if (t) return t = _e(e, n), $e.test(t) ? k(e).position()[n] + "px" : t;
    });
  }), k.each({
    Height: "height",
    Width: "width"
  }, function (a, s) {
    k.each({
      padding: "inner" + a,
      content: s,
      "": "outer" + a
    }, function (r, o) {
      k.fn[o] = function (e, t) {
        var n = arguments.length && (r || "boolean" != typeof e),
            i = r || (!0 === e || !0 === t ? "margin" : "border");
        return _(this, function (e, t, n) {
          var r;
          return x(e) ? 0 === o.indexOf("outer") ? e["inner" + a] : e.document.documentElement["client" + a] : 9 === e.nodeType ? (r = e.documentElement, Math.max(e.body["scroll" + a], r["scroll" + a], e.body["offset" + a], r["offset" + a], r["client" + a])) : void 0 === n ? k.css(e, t, i) : k.style(e, t, n, i);
        }, s, n ? e : void 0, n);
      };
    });
  }), k.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (e, n) {
    k.fn[n] = function (e, t) {
      return 0 < arguments.length ? this.on(n, null, e, t) : this.trigger(n);
    };
  }), k.fn.extend({
    hover: function hover(e, t) {
      return this.mouseenter(e).mouseleave(t || e);
    }
  }), k.fn.extend({
    bind: function bind(e, t, n) {
      return this.on(e, null, t, n);
    },
    unbind: function unbind(e, t) {
      return this.off(e, null, t);
    },
    delegate: function delegate(e, t, n, r) {
      return this.on(t, e, n, r);
    },
    undelegate: function undelegate(e, t, n) {
      return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n);
    }
  }), k.proxy = function (e, t) {
    var n, r, i;
    if ("string" == typeof t && (n = e[t], t = e, e = n), m(e)) return r = s.call(arguments, 2), (i = function i() {
      return e.apply(t || this, r.concat(s.call(arguments)));
    }).guid = e.guid = e.guid || k.guid++, i;
  }, k.holdReady = function (e) {
    e ? k.readyWait++ : k.ready(!0);
  }, k.isArray = Array.isArray, k.parseJSON = JSON.parse, k.nodeName = A, k.isFunction = m, k.isWindow = x, k.camelCase = V, k.type = w, k.now = Date.now, k.isNumeric = function (e) {
    var t = k.type(e);
    return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e));
  },  true && !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_LOCAL_MODULE_0__ = ((function () {
    return k;
  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)));
  var Qt = C.jQuery,
      Jt = C.$;
  return k.noConflict = function (e) {
    return C.$ === k && (C.$ = Jt), e && C.jQuery === k && (C.jQuery = Qt), k;
  }, e || (C.jQuery = C.$ = k), k;
});
/*
 Copyright (C) Federico Zivolo 2019
 Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).
 */

(function (e, t) {
  'object' == ( false ? undefined : _typeof(exports)) && 'undefined' != typeof module ? module.exports = t() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (t),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function () {
  'use strict';

  function e(e) {
    return e && '[object Function]' === {}.toString.call(e);
  }

  function t(e, t) {
    if (1 !== e.nodeType) return [];
    var o = e.ownerDocument.defaultView,
        n = o.getComputedStyle(e, null);
    return t ? n[t] : n;
  }

  function o(e) {
    return 'HTML' === e.nodeName ? e : e.parentNode || e.host;
  }

  function n(e) {
    if (!e) return document.body;

    switch (e.nodeName) {
      case 'HTML':
      case 'BODY':
        return e.ownerDocument.body;

      case '#document':
        return e.body;
    }

    var i = t(e),
        r = i.overflow,
        p = i.overflowX,
        s = i.overflowY;
    return /(auto|scroll|overlay)/.test(r + s + p) ? e : n(o(e));
  }

  function r(e) {
    return 11 === e ? pe : 10 === e ? se : pe || se;
  }

  function p(e) {
    if (!e) return document.documentElement;

    for (var o = r(10) ? document.body : null, n = e.offsetParent || null; n === o && e.nextElementSibling;) {
      n = (e = e.nextElementSibling).offsetParent;
    }

    var i = n && n.nodeName;
    return i && 'BODY' !== i && 'HTML' !== i ? -1 !== ['TH', 'TD', 'TABLE'].indexOf(n.nodeName) && 'static' === t(n, 'position') ? p(n) : n : e ? e.ownerDocument.documentElement : document.documentElement;
  }

  function s(e) {
    var t = e.nodeName;
    return 'BODY' !== t && ('HTML' === t || p(e.firstElementChild) === e);
  }

  function d(e) {
    return null === e.parentNode ? e : d(e.parentNode);
  }

  function a(e, t) {
    if (!e || !e.nodeType || !t || !t.nodeType) return document.documentElement;
    var o = e.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_FOLLOWING,
        n = o ? e : t,
        i = o ? t : e,
        r = document.createRange();
    r.setStart(n, 0), r.setEnd(i, 0);
    var l = r.commonAncestorContainer;
    if (e !== l && t !== l || n.contains(i)) return s(l) ? l : p(l);
    var f = d(e);
    return f.host ? a(f.host, t) : a(e, d(t).host);
  }

  function l(e) {
    var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 'top',
        o = 'top' === t ? 'scrollTop' : 'scrollLeft',
        n = e.nodeName;

    if ('BODY' === n || 'HTML' === n) {
      var i = e.ownerDocument.documentElement,
          r = e.ownerDocument.scrollingElement || i;
      return r[o];
    }

    return e[o];
  }

  function f(e, t) {
    var o = 2 < arguments.length && void 0 !== arguments[2] && arguments[2],
        n = l(t, 'top'),
        i = l(t, 'left'),
        r = o ? -1 : 1;
    return e.top += n * r, e.bottom += n * r, e.left += i * r, e.right += i * r, e;
  }

  function m(e, t) {
    var o = 'x' === t ? 'Left' : 'Top',
        n = 'Left' == o ? 'Right' : 'Bottom';
    return parseFloat(e['border' + o + 'Width'], 10) + parseFloat(e['border' + n + 'Width'], 10);
  }

  function h(e, t, o, n) {
    return ee(t['offset' + e], t['scroll' + e], o['client' + e], o['offset' + e], o['scroll' + e], r(10) ? parseInt(o['offset' + e]) + parseInt(n['margin' + ('Height' === e ? 'Top' : 'Left')]) + parseInt(n['margin' + ('Height' === e ? 'Bottom' : 'Right')]) : 0);
  }

  function c(e) {
    var t = e.body,
        o = e.documentElement,
        n = r(10) && getComputedStyle(o);
    return {
      height: h('Height', t, o, n),
      width: h('Width', t, o, n)
    };
  }

  function g(e) {
    return fe({}, e, {
      right: e.left + e.width,
      bottom: e.top + e.height
    });
  }

  function u(e) {
    var o = {};

    try {
      if (r(10)) {
        o = e.getBoundingClientRect();
        var n = l(e, 'top'),
            i = l(e, 'left');
        o.top += n, o.left += i, o.bottom += n, o.right += i;
      } else o = e.getBoundingClientRect();
    } catch (t) {}

    var p = {
      left: o.left,
      top: o.top,
      width: o.right - o.left,
      height: o.bottom - o.top
    },
        s = 'HTML' === e.nodeName ? c(e.ownerDocument) : {},
        d = s.width || e.clientWidth || p.right - p.left,
        a = s.height || e.clientHeight || p.bottom - p.top,
        f = e.offsetWidth - d,
        h = e.offsetHeight - a;

    if (f || h) {
      var u = t(e);
      f -= m(u, 'x'), h -= m(u, 'y'), p.width -= f, p.height -= h;
    }

    return g(p);
  }

  function b(e, o) {
    var i = 2 < arguments.length && void 0 !== arguments[2] && arguments[2],
        p = r(10),
        s = 'HTML' === o.nodeName,
        d = u(e),
        a = u(o),
        l = n(e),
        m = t(o),
        h = parseFloat(m.borderTopWidth, 10),
        c = parseFloat(m.borderLeftWidth, 10);
    i && s && (a.top = ee(a.top, 0), a.left = ee(a.left, 0));
    var b = g({
      top: d.top - a.top - h,
      left: d.left - a.left - c,
      width: d.width,
      height: d.height
    });

    if (b.marginTop = 0, b.marginLeft = 0, !p && s) {
      var w = parseFloat(m.marginTop, 10),
          y = parseFloat(m.marginLeft, 10);
      b.top -= h - w, b.bottom -= h - w, b.left -= c - y, b.right -= c - y, b.marginTop = w, b.marginLeft = y;
    }

    return (p && !i ? o.contains(l) : o === l && 'BODY' !== l.nodeName) && (b = f(b, o)), b;
  }

  function w(e) {
    var t = 1 < arguments.length && void 0 !== arguments[1] && arguments[1],
        o = e.ownerDocument.documentElement,
        n = b(e, o),
        i = ee(o.clientWidth, window.innerWidth || 0),
        r = ee(o.clientHeight, window.innerHeight || 0),
        p = t ? 0 : l(o),
        s = t ? 0 : l(o, 'left'),
        d = {
      top: p - n.top + n.marginTop,
      left: s - n.left + n.marginLeft,
      width: i,
      height: r
    };
    return g(d);
  }

  function y(e) {
    var n = e.nodeName;
    if ('BODY' === n || 'HTML' === n) return !1;
    if ('fixed' === t(e, 'position')) return !0;
    var i = o(e);
    return !!i && y(i);
  }

  function E(e) {
    if (!e || !e.parentElement || r()) return document.documentElement;

    for (var o = e.parentElement; o && 'none' === t(o, 'transform');) {
      o = o.parentElement;
    }

    return o || document.documentElement;
  }

  function v(e, t, i, r) {
    var p = 4 < arguments.length && void 0 !== arguments[4] && arguments[4],
        s = {
      top: 0,
      left: 0
    },
        d = p ? E(e) : a(e, t);
    if ('viewport' === r) s = w(d, p);else {
      var l;
      'scrollParent' === r ? (l = n(o(t)), 'BODY' === l.nodeName && (l = e.ownerDocument.documentElement)) : 'window' === r ? l = e.ownerDocument.documentElement : l = r;
      var f = b(l, d, p);

      if ('HTML' === l.nodeName && !y(d)) {
        var m = c(e.ownerDocument),
            h = m.height,
            g = m.width;
        s.top += f.top - f.marginTop, s.bottom = h + f.top, s.left += f.left - f.marginLeft, s.right = g + f.left;
      } else s = f;
    }
    i = i || 0;
    var u = 'number' == typeof i;
    return s.left += u ? i : i.left || 0, s.top += u ? i : i.top || 0, s.right -= u ? i : i.right || 0, s.bottom -= u ? i : i.bottom || 0, s;
  }

  function x(e) {
    var t = e.width,
        o = e.height;
    return t * o;
  }

  function O(e, t, o, n, i) {
    var r = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 0;
    if (-1 === e.indexOf('auto')) return e;
    var p = v(o, n, r, i),
        s = {
      top: {
        width: p.width,
        height: t.top - p.top
      },
      right: {
        width: p.right - t.right,
        height: p.height
      },
      bottom: {
        width: p.width,
        height: p.bottom - t.bottom
      },
      left: {
        width: t.left - p.left,
        height: p.height
      }
    },
        d = Object.keys(s).map(function (e) {
      return fe({
        key: e
      }, s[e], {
        area: x(s[e])
      });
    }).sort(function (e, t) {
      return t.area - e.area;
    }),
        a = d.filter(function (e) {
      var t = e.width,
          n = e.height;
      return t >= o.clientWidth && n >= o.clientHeight;
    }),
        l = 0 < a.length ? a[0].key : d[0].key,
        f = e.split('-')[1];
    return l + (f ? '-' + f : '');
  }

  function L(e, t, o) {
    var n = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null,
        i = n ? E(t) : a(t, o);
    return b(o, i, n);
  }

  function S(e) {
    var t = e.ownerDocument.defaultView,
        o = t.getComputedStyle(e),
        n = parseFloat(o.marginTop || 0) + parseFloat(o.marginBottom || 0),
        i = parseFloat(o.marginLeft || 0) + parseFloat(o.marginRight || 0),
        r = {
      width: e.offsetWidth + i,
      height: e.offsetHeight + n
    };
    return r;
  }

  function T(e) {
    var t = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    return e.replace(/left|right|bottom|top/g, function (e) {
      return t[e];
    });
  }

  function C(e, t, o) {
    o = o.split('-')[0];
    var n = S(e),
        i = {
      width: n.width,
      height: n.height
    },
        r = -1 !== ['right', 'left'].indexOf(o),
        p = r ? 'top' : 'left',
        s = r ? 'left' : 'top',
        d = r ? 'height' : 'width',
        a = r ? 'width' : 'height';
    return i[p] = t[p] + t[d] / 2 - n[d] / 2, i[s] = o === s ? t[s] - n[a] : t[T(s)], i;
  }

  function D(e, t) {
    return Array.prototype.find ? e.find(t) : e.filter(t)[0];
  }

  function N(e, t, o) {
    if (Array.prototype.findIndex) return e.findIndex(function (e) {
      return e[t] === o;
    });
    var n = D(e, function (e) {
      return e[t] === o;
    });
    return e.indexOf(n);
  }

  function P(t, o, n) {
    var i = void 0 === n ? t : t.slice(0, N(t, 'name', n));
    return i.forEach(function (t) {
      t['function'] && console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
      var n = t['function'] || t.fn;
      t.enabled && e(n) && (o.offsets.popper = g(o.offsets.popper), o.offsets.reference = g(o.offsets.reference), o = n(o, t));
    }), o;
  }

  function k() {
    if (!this.state.isDestroyed) {
      var e = {
        instance: this,
        styles: {},
        arrowStyles: {},
        attributes: {},
        flipped: !1,
        offsets: {}
      };
      e.offsets.reference = L(this.state, this.popper, this.reference, this.options.positionFixed), e.placement = O(this.options.placement, e.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), e.originalPlacement = e.placement, e.positionFixed = this.options.positionFixed, e.offsets.popper = C(this.popper, e.offsets.reference, e.placement), e.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute', e = P(this.modifiers, e), this.state.isCreated ? this.options.onUpdate(e) : (this.state.isCreated = !0, this.options.onCreate(e));
    }
  }

  function W(e, t) {
    return e.some(function (e) {
      var o = e.name,
          n = e.enabled;
      return n && o === t;
    });
  }

  function B(e) {
    for (var t = [!1, 'ms', 'Webkit', 'Moz', 'O'], o = e.charAt(0).toUpperCase() + e.slice(1), n = 0; n < t.length; n++) {
      var i = t[n],
          r = i ? '' + i + o : e;
      if ('undefined' != typeof document.body.style[r]) return r;
    }

    return null;
  }

  function H() {
    return this.state.isDestroyed = !0, W(this.modifiers, 'applyStyle') && (this.popper.removeAttribute('x-placement'), this.popper.style.position = '', this.popper.style.top = '', this.popper.style.left = '', this.popper.style.right = '', this.popper.style.bottom = '', this.popper.style.willChange = '', this.popper.style[B('transform')] = ''), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this;
  }

  function A(e) {
    var t = e.ownerDocument;
    return t ? t.defaultView : window;
  }

  function M(e, t, o, i) {
    var r = 'BODY' === e.nodeName,
        p = r ? e.ownerDocument.defaultView : e;
    p.addEventListener(t, o, {
      passive: !0
    }), r || M(n(p.parentNode), t, o, i), i.push(p);
  }

  function F(e, t, o, i) {
    o.updateBound = i, A(e).addEventListener('resize', o.updateBound, {
      passive: !0
    });
    var r = n(e);
    return M(r, 'scroll', o.updateBound, o.scrollParents), o.scrollElement = r, o.eventsEnabled = !0, o;
  }

  function I() {
    this.state.eventsEnabled || (this.state = F(this.reference, this.options, this.state, this.scheduleUpdate));
  }

  function R(e, t) {
    return A(e).removeEventListener('resize', t.updateBound), t.scrollParents.forEach(function (e) {
      e.removeEventListener('scroll', t.updateBound);
    }), t.updateBound = null, t.scrollParents = [], t.scrollElement = null, t.eventsEnabled = !1, t;
  }

  function U() {
    this.state.eventsEnabled && (cancelAnimationFrame(this.scheduleUpdate), this.state = R(this.reference, this.state));
  }

  function Y(e) {
    return '' !== e && !isNaN(parseFloat(e)) && isFinite(e);
  }

  function V(e, t) {
    Object.keys(t).forEach(function (o) {
      var n = '';
      -1 !== ['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(o) && Y(t[o]) && (n = 'px'), e.style[o] = t[o] + n;
    });
  }

  function j(e, t) {
    Object.keys(t).forEach(function (o) {
      var n = t[o];
      !1 === n ? e.removeAttribute(o) : e.setAttribute(o, t[o]);
    });
  }

  function q(e, t) {
    var o = e.offsets,
        n = o.popper,
        i = o.reference,
        r = $,
        p = function p(e) {
      return e;
    },
        s = r(i.width),
        d = r(n.width),
        a = -1 !== ['left', 'right'].indexOf(e.placement),
        l = -1 !== e.placement.indexOf('-'),
        f = t ? a || l || s % 2 == d % 2 ? r : Z : p,
        m = t ? r : p;

    return {
      left: f(1 == s % 2 && 1 == d % 2 && !l && t ? n.left - 1 : n.left),
      top: m(n.top),
      bottom: m(n.bottom),
      right: f(n.right)
    };
  }

  function K(e, t, o) {
    var n = D(e, function (e) {
      var o = e.name;
      return o === t;
    }),
        i = !!n && e.some(function (e) {
      return e.name === o && e.enabled && e.order < n.order;
    });

    if (!i) {
      var r = '`' + t + '`';
      console.warn('`' + o + '`' + ' modifier is required by ' + r + ' modifier in order to work, be sure to include it before ' + r + '!');
    }

    return i;
  }

  function z(e) {
    return 'end' === e ? 'start' : 'start' === e ? 'end' : e;
  }

  function G(e) {
    var t = 1 < arguments.length && void 0 !== arguments[1] && arguments[1],
        o = ce.indexOf(e),
        n = ce.slice(o + 1).concat(ce.slice(0, o));
    return t ? n.reverse() : n;
  }

  function _(e, t, o, n) {
    var i = e.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),
        r = +i[1],
        p = i[2];
    if (!r) return e;

    if (0 === p.indexOf('%')) {
      var s;

      switch (p) {
        case '%p':
          s = o;
          break;

        case '%':
        case '%r':
        default:
          s = n;
      }

      var d = g(s);
      return d[t] / 100 * r;
    }

    if ('vh' === p || 'vw' === p) {
      var a;
      return a = 'vh' === p ? ee(document.documentElement.clientHeight, window.innerHeight || 0) : ee(document.documentElement.clientWidth, window.innerWidth || 0), a / 100 * r;
    }

    return r;
  }

  function X(e, t, o, n) {
    var i = [0, 0],
        r = -1 !== ['right', 'left'].indexOf(n),
        p = e.split(/(\+|\-)/).map(function (e) {
      return e.trim();
    }),
        s = p.indexOf(D(p, function (e) {
      return -1 !== e.search(/,|\s/);
    }));
    p[s] && -1 === p[s].indexOf(',') && console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
    var d = /\s*,\s*|\s+/,
        a = -1 === s ? [p] : [p.slice(0, s).concat([p[s].split(d)[0]]), [p[s].split(d)[1]].concat(p.slice(s + 1))];
    return a = a.map(function (e, n) {
      var i = (1 === n ? !r : r) ? 'height' : 'width',
          p = !1;
      return e.reduce(function (e, t) {
        return '' === e[e.length - 1] && -1 !== ['+', '-'].indexOf(t) ? (e[e.length - 1] = t, p = !0, e) : p ? (e[e.length - 1] += t, p = !1, e) : e.concat(t);
      }, []).map(function (e) {
        return _(e, i, t, o);
      });
    }), a.forEach(function (e, t) {
      e.forEach(function (o, n) {
        Y(o) && (i[t] += o * ('-' === e[n - 1] ? -1 : 1));
      });
    }), i;
  }

  function J(e, t) {
    var o,
        n = t.offset,
        i = e.placement,
        r = e.offsets,
        p = r.popper,
        s = r.reference,
        d = i.split('-')[0];
    return o = Y(+n) ? [+n, 0] : X(n, p, s, d), 'left' === d ? (p.top += o[0], p.left -= o[1]) : 'right' === d ? (p.top += o[0], p.left += o[1]) : 'top' === d ? (p.left += o[0], p.top -= o[1]) : 'bottom' === d && (p.left += o[0], p.top += o[1]), e.popper = p, e;
  }

  for (var Q = Math.min, Z = Math.floor, $ = Math.round, ee = Math.max, te = 'undefined' != typeof window && 'undefined' != typeof document, oe = ['Edge', 'Trident', 'Firefox'], ne = 0, ie = 0; ie < oe.length; ie += 1) {
    if (te && 0 <= navigator.userAgent.indexOf(oe[ie])) {
      ne = 1;
      break;
    }
  }

  var i = te && window.Promise,
      re = i ? function (e) {
    var t = !1;
    return function () {
      t || (t = !0, window.Promise.resolve().then(function () {
        t = !1, e();
      }));
    };
  } : function (e) {
    var t = !1;
    return function () {
      t || (t = !0, setTimeout(function () {
        t = !1, e();
      }, ne));
    };
  },
      pe = te && !!(window.MSInputMethodContext && document.documentMode),
      se = te && /MSIE 10/.test(navigator.userAgent),
      de = function de(e, t) {
    if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
  },
      ae = function () {
    function e(e, t) {
      for (var o, n = 0; n < t.length; n++) {
        o = t[n], o.enumerable = o.enumerable || !1, o.configurable = !0, 'value' in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
      }
    }

    return function (t, o, n) {
      return o && e(t.prototype, o), n && e(t, n), t;
    };
  }(),
      le = function le(e, t, o) {
    return t in e ? Object.defineProperty(e, t, {
      value: o,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[t] = o, e;
  },
      fe = Object.assign || function (e) {
    for (var t, o = 1; o < arguments.length; o++) {
      for (var n in t = arguments[o], t) {
        Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
      }
    }

    return e;
  },
      me = te && /Firefox/i.test(navigator.userAgent),
      he = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'],
      ce = he.slice(3),
      ge = {
    FLIP: 'flip',
    CLOCKWISE: 'clockwise',
    COUNTERCLOCKWISE: 'counterclockwise'
  },
      ue = function () {
    function t(o, n) {
      var i = this,
          r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};
      de(this, t), this.scheduleUpdate = function () {
        return requestAnimationFrame(i.update);
      }, this.update = re(this.update.bind(this)), this.options = fe({}, t.Defaults, r), this.state = {
        isDestroyed: !1,
        isCreated: !1,
        scrollParents: []
      }, this.reference = o && o.jquery ? o[0] : o, this.popper = n && n.jquery ? n[0] : n, this.options.modifiers = {}, Object.keys(fe({}, t.Defaults.modifiers, r.modifiers)).forEach(function (e) {
        i.options.modifiers[e] = fe({}, t.Defaults.modifiers[e] || {}, r.modifiers ? r.modifiers[e] : {});
      }), this.modifiers = Object.keys(this.options.modifiers).map(function (e) {
        return fe({
          name: e
        }, i.options.modifiers[e]);
      }).sort(function (e, t) {
        return e.order - t.order;
      }), this.modifiers.forEach(function (t) {
        t.enabled && e(t.onLoad) && t.onLoad(i.reference, i.popper, i.options, t, i.state);
      }), this.update();
      var p = this.options.eventsEnabled;
      p && this.enableEventListeners(), this.state.eventsEnabled = p;
    }

    return ae(t, [{
      key: 'update',
      value: function value() {
        return k.call(this);
      }
    }, {
      key: 'destroy',
      value: function value() {
        return H.call(this);
      }
    }, {
      key: 'enableEventListeners',
      value: function value() {
        return I.call(this);
      }
    }, {
      key: 'disableEventListeners',
      value: function value() {
        return U.call(this);
      }
    }]), t;
  }();

  return ue.Utils = ('undefined' == typeof window ? global : window).PopperUtils, ue.placements = he, ue.Defaults = {
    placement: 'bottom',
    positionFixed: !1,
    eventsEnabled: !0,
    removeOnDestroy: !1,
    onCreate: function onCreate() {},
    onUpdate: function onUpdate() {},
    modifiers: {
      shift: {
        order: 100,
        enabled: !0,
        fn: function fn(e) {
          var t = e.placement,
              o = t.split('-')[0],
              n = t.split('-')[1];

          if (n) {
            var i = e.offsets,
                r = i.reference,
                p = i.popper,
                s = -1 !== ['bottom', 'top'].indexOf(o),
                d = s ? 'left' : 'top',
                a = s ? 'width' : 'height',
                l = {
              start: le({}, d, r[d]),
              end: le({}, d, r[d] + r[a] - p[a])
            };
            e.offsets.popper = fe({}, p, l[n]);
          }

          return e;
        }
      },
      offset: {
        order: 200,
        enabled: !0,
        fn: J,
        offset: 0
      },
      preventOverflow: {
        order: 300,
        enabled: !0,
        fn: function fn(e, t) {
          var o = t.boundariesElement || p(e.instance.popper);
          e.instance.reference === o && (o = p(o));
          var n = B('transform'),
              i = e.instance.popper.style,
              r = i.top,
              s = i.left,
              d = i[n];
          i.top = '', i.left = '', i[n] = '';
          var a = v(e.instance.popper, e.instance.reference, t.padding, o, e.positionFixed);
          i.top = r, i.left = s, i[n] = d, t.boundaries = a;
          var l = t.priority,
              f = e.offsets.popper,
              m = {
            primary: function primary(e) {
              var o = f[e];
              return f[e] < a[e] && !t.escapeWithReference && (o = ee(f[e], a[e])), le({}, e, o);
            },
            secondary: function secondary(e) {
              var o = 'right' === e ? 'left' : 'top',
                  n = f[o];
              return f[e] > a[e] && !t.escapeWithReference && (n = Q(f[o], a[e] - ('right' === e ? f.width : f.height))), le({}, o, n);
            }
          };
          return l.forEach(function (e) {
            var t = -1 === ['left', 'top'].indexOf(e) ? 'secondary' : 'primary';
            f = fe({}, f, m[t](e));
          }), e.offsets.popper = f, e;
        },
        priority: ['left', 'right', 'top', 'bottom'],
        padding: 5,
        boundariesElement: 'scrollParent'
      },
      keepTogether: {
        order: 400,
        enabled: !0,
        fn: function fn(e) {
          var t = e.offsets,
              o = t.popper,
              n = t.reference,
              i = e.placement.split('-')[0],
              r = Z,
              p = -1 !== ['top', 'bottom'].indexOf(i),
              s = p ? 'right' : 'bottom',
              d = p ? 'left' : 'top',
              a = p ? 'width' : 'height';
          return o[s] < r(n[d]) && (e.offsets.popper[d] = r(n[d]) - o[a]), o[d] > r(n[s]) && (e.offsets.popper[d] = r(n[s])), e;
        }
      },
      arrow: {
        order: 500,
        enabled: !0,
        fn: function fn(e, o) {
          var n;
          if (!K(e.instance.modifiers, 'arrow', 'keepTogether')) return e;
          var i = o.element;

          if ('string' == typeof i) {
            if (i = e.instance.popper.querySelector(i), !i) return e;
          } else if (!e.instance.popper.contains(i)) return console.warn('WARNING: `arrow.element` must be child of its popper element!'), e;

          var r = e.placement.split('-')[0],
              p = e.offsets,
              s = p.popper,
              d = p.reference,
              a = -1 !== ['left', 'right'].indexOf(r),
              l = a ? 'height' : 'width',
              f = a ? 'Top' : 'Left',
              m = f.toLowerCase(),
              h = a ? 'left' : 'top',
              c = a ? 'bottom' : 'right',
              u = S(i)[l];
          d[c] - u < s[m] && (e.offsets.popper[m] -= s[m] - (d[c] - u)), d[m] + u > s[c] && (e.offsets.popper[m] += d[m] + u - s[c]), e.offsets.popper = g(e.offsets.popper);
          var b = d[m] + d[l] / 2 - u / 2,
              w = t(e.instance.popper),
              y = parseFloat(w['margin' + f], 10),
              E = parseFloat(w['border' + f + 'Width'], 10),
              v = b - e.offsets.popper[m] - y - E;
          return v = ee(Q(s[l] - u, v), 0), e.arrowElement = i, e.offsets.arrow = (n = {}, le(n, m, $(v)), le(n, h, ''), n), e;
        },
        element: '[x-arrow]'
      },
      flip: {
        order: 600,
        enabled: !0,
        fn: function fn(e, t) {
          if (W(e.instance.modifiers, 'inner')) return e;
          if (e.flipped && e.placement === e.originalPlacement) return e;
          var o = v(e.instance.popper, e.instance.reference, t.padding, t.boundariesElement, e.positionFixed),
              n = e.placement.split('-')[0],
              i = T(n),
              r = e.placement.split('-')[1] || '',
              p = [];

          switch (t.behavior) {
            case ge.FLIP:
              p = [n, i];
              break;

            case ge.CLOCKWISE:
              p = G(n);
              break;

            case ge.COUNTERCLOCKWISE:
              p = G(n, !0);
              break;

            default:
              p = t.behavior;
          }

          return p.forEach(function (s, d) {
            if (n !== s || p.length === d + 1) return e;
            n = e.placement.split('-')[0], i = T(n);
            var a = e.offsets.popper,
                l = e.offsets.reference,
                f = Z,
                m = 'left' === n && f(a.right) > f(l.left) || 'right' === n && f(a.left) < f(l.right) || 'top' === n && f(a.bottom) > f(l.top) || 'bottom' === n && f(a.top) < f(l.bottom),
                h = f(a.left) < f(o.left),
                c = f(a.right) > f(o.right),
                g = f(a.top) < f(o.top),
                u = f(a.bottom) > f(o.bottom),
                b = 'left' === n && h || 'right' === n && c || 'top' === n && g || 'bottom' === n && u,
                w = -1 !== ['top', 'bottom'].indexOf(n),
                y = !!t.flipVariations && (w && 'start' === r && h || w && 'end' === r && c || !w && 'start' === r && g || !w && 'end' === r && u),
                E = !!t.flipVariationsByContent && (w && 'start' === r && c || w && 'end' === r && h || !w && 'start' === r && u || !w && 'end' === r && g),
                v = y || E;
            (m || b || v) && (e.flipped = !0, (m || b) && (n = p[d + 1]), v && (r = z(r)), e.placement = n + (r ? '-' + r : ''), e.offsets.popper = fe({}, e.offsets.popper, C(e.instance.popper, e.offsets.reference, e.placement)), e = P(e.instance.modifiers, e, 'flip'));
          }), e;
        },
        behavior: 'flip',
        padding: 5,
        boundariesElement: 'viewport',
        flipVariations: !1,
        flipVariationsByContent: !1
      },
      inner: {
        order: 700,
        enabled: !1,
        fn: function fn(e) {
          var t = e.placement,
              o = t.split('-')[0],
              n = e.offsets,
              i = n.popper,
              r = n.reference,
              p = -1 !== ['left', 'right'].indexOf(o),
              s = -1 === ['top', 'left'].indexOf(o);
          return i[p ? 'left' : 'top'] = r[o] - (s ? i[p ? 'width' : 'height'] : 0), e.placement = T(t), e.offsets.popper = g(i), e;
        }
      },
      hide: {
        order: 800,
        enabled: !0,
        fn: function fn(e) {
          if (!K(e.instance.modifiers, 'hide', 'preventOverflow')) return e;
          var t = e.offsets.reference,
              o = D(e.instance.modifiers, function (e) {
            return 'preventOverflow' === e.name;
          }).boundaries;

          if (t.bottom < o.top || t.left > o.right || t.top > o.bottom || t.right < o.left) {
            if (!0 === e.hide) return e;
            e.hide = !0, e.attributes['x-out-of-boundaries'] = '';
          } else {
            if (!1 === e.hide) return e;
            e.hide = !1, e.attributes['x-out-of-boundaries'] = !1;
          }

          return e;
        }
      },
      computeStyle: {
        order: 850,
        enabled: !0,
        fn: function fn(e, t) {
          var o = t.x,
              n = t.y,
              i = e.offsets.popper,
              r = D(e.instance.modifiers, function (e) {
            return 'applyStyle' === e.name;
          }).gpuAcceleration;
          void 0 !== r && console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
          var s,
              d,
              a = void 0 === r ? t.gpuAcceleration : r,
              l = p(e.instance.popper),
              f = u(l),
              m = {
            position: i.position
          },
              h = q(e, 2 > window.devicePixelRatio || !me),
              c = 'bottom' === o ? 'top' : 'bottom',
              g = 'right' === n ? 'left' : 'right',
              b = B('transform');
          if (d = 'bottom' == c ? 'HTML' === l.nodeName ? -l.clientHeight + h.bottom : -f.height + h.bottom : h.top, s = 'right' == g ? 'HTML' === l.nodeName ? -l.clientWidth + h.right : -f.width + h.right : h.left, a && b) m[b] = 'translate3d(' + s + 'px, ' + d + 'px, 0)', m[c] = 0, m[g] = 0, m.willChange = 'transform';else {
            var w = 'bottom' == c ? -1 : 1,
                y = 'right' == g ? -1 : 1;
            m[c] = d * w, m[g] = s * y, m.willChange = c + ', ' + g;
          }
          var E = {
            "x-placement": e.placement
          };
          return e.attributes = fe({}, E, e.attributes), e.styles = fe({}, m, e.styles), e.arrowStyles = fe({}, e.offsets.arrow, e.arrowStyles), e;
        },
        gpuAcceleration: !0,
        x: 'bottom',
        y: 'right'
      },
      applyStyle: {
        order: 900,
        enabled: !0,
        fn: function fn(e) {
          return V(e.instance.popper, e.styles), j(e.instance.popper, e.attributes), e.arrowElement && Object.keys(e.arrowStyles).length && V(e.arrowElement, e.arrowStyles), e;
        },
        onLoad: function onLoad(e, t, o, n, i) {
          var r = L(i, t, e, o.positionFixed),
              p = O(o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding);
          return t.setAttribute('x-placement', p), V(t, {
            position: o.positionFixed ? 'fixed' : 'absolute'
          }), o;
        },
        gpuAcceleration: void 0
      }
    }
  }, ue;
});
/*!
  * Bootstrap v4.3.1 (https://getbootstrap.com/)
  * Copyright 2011-2019 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
  */


!function (t, e) {
  "object" == ( false ? undefined : _typeof(exports)) && "undefined" != typeof module ? e(exports, __WEBPACK_LOCAL_MODULE_0__, __webpack_require__(/*! popper.js */ "./node_modules/popper.js/dist/esm/popper.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __WEBPACK_LOCAL_MODULE_0__, __webpack_require__(/*! popper.js */ "./node_modules/popper.js/dist/esm/popper.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (e),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
}(this, function (t, g, u) {
  "use strict";

  function i(t, e) {
    for (var n = 0; n < e.length; n++) {
      var i = e[n];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
    }
  }

  function s(t, e, n) {
    return e && i(t.prototype, e), n && i(t, n), t;
  }

  function l(o) {
    for (var t = 1; t < arguments.length; t++) {
      var r = null != arguments[t] ? arguments[t] : {},
          e = Object.keys(r);
      "function" == typeof Object.getOwnPropertySymbols && (e = e.concat(Object.getOwnPropertySymbols(r).filter(function (t) {
        return Object.getOwnPropertyDescriptor(r, t).enumerable;
      }))), e.forEach(function (t) {
        var e, n, i;
        e = o, i = r[n = t], n in e ? Object.defineProperty(e, n, {
          value: i,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }) : e[n] = i;
      });
    }

    return o;
  }

  g = g && g.hasOwnProperty("default") ? g["default"] : g, u = u && u.hasOwnProperty("default") ? u["default"] : u;
  var e = "transitionend";

  function n(t) {
    var e = this,
        n = !1;
    return g(this).one(_.TRANSITION_END, function () {
      n = !0;
    }), setTimeout(function () {
      n || _.triggerTransitionEnd(e);
    }, t), this;
  }

  var _ = {
    TRANSITION_END: "bsTransitionEnd",
    getUID: function getUID(t) {
      for (; t += ~~(1e6 * Math.random()), document.getElementById(t);) {
        ;
      }

      return t;
    },
    getSelectorFromElement: function getSelectorFromElement(t) {
      var e = t.getAttribute("data-target");

      if (!e || "#" === e) {
        var n = t.getAttribute("href");
        e = n && "#" !== n ? n.trim() : "";
      }

      try {
        return document.querySelector(e) ? e : null;
      } catch (t) {
        return null;
      }
    },
    getTransitionDurationFromElement: function getTransitionDurationFromElement(t) {
      if (!t) return 0;
      var e = g(t).css("transition-duration"),
          n = g(t).css("transition-delay"),
          i = parseFloat(e),
          o = parseFloat(n);
      return i || o ? (e = e.split(",")[0], n = n.split(",")[0], 1e3 * (parseFloat(e) + parseFloat(n))) : 0;
    },
    reflow: function reflow(t) {
      return t.offsetHeight;
    },
    triggerTransitionEnd: function triggerTransitionEnd(t) {
      g(t).trigger(e);
    },
    supportsTransitionEnd: function supportsTransitionEnd() {
      return Boolean(e);
    },
    isElement: function isElement(t) {
      return (t[0] || t).nodeType;
    },
    typeCheckConfig: function typeCheckConfig(t, e, n) {
      for (var i in n) {
        if (Object.prototype.hasOwnProperty.call(n, i)) {
          var o = n[i],
              r = e[i],
              s = r && _.isElement(r) ? "element" : (a = r, {}.toString.call(a).match(/\s([a-z]+)/i)[1].toLowerCase());
          if (!new RegExp(o).test(s)) throw new Error(t.toUpperCase() + ': Option "' + i + '" provided type "' + s + '" but expected type "' + o + '".');
        }
      }

      var a;
    },
    findShadowRoot: function findShadowRoot(t) {
      if (!document.documentElement.attachShadow) return null;
      if ("function" != typeof t.getRootNode) return t instanceof ShadowRoot ? t : t.parentNode ? _.findShadowRoot(t.parentNode) : null;
      var e = t.getRootNode();
      return e instanceof ShadowRoot ? e : null;
    }
  };
  g.fn.emulateTransitionEnd = n, g.event.special[_.TRANSITION_END] = {
    bindType: e,
    delegateType: e,
    handle: function handle(t) {
      if (g(t.target).is(this)) return t.handleObj.handler.apply(this, arguments);
    }
  };

  var o = "alert",
      r = "bs.alert",
      a = "." + r,
      c = g.fn[o],
      h = {
    CLOSE: "close" + a,
    CLOSED: "closed" + a,
    CLICK_DATA_API: "click" + a + ".data-api"
  },
      f = "alert",
      d = "fade",
      m = "show",
      p = function () {
    function i(t) {
      this._element = t;
    }

    var t = i.prototype;
    return t.close = function (t) {
      var e = this._element;
      t && (e = this._getRootElement(t)), this._triggerCloseEvent(e).isDefaultPrevented() || this._removeElement(e);
    }, t.dispose = function () {
      g.removeData(this._element, r), this._element = null;
    }, t._getRootElement = function (t) {
      var e = _.getSelectorFromElement(t),
          n = !1;

      return e && (n = document.querySelector(e)), n || (n = g(t).closest("." + f)[0]), n;
    }, t._triggerCloseEvent = function (t) {
      var e = g.Event(h.CLOSE);
      return g(t).trigger(e), e;
    }, t._removeElement = function (e) {
      var n = this;

      if (g(e).removeClass(m), g(e).hasClass(d)) {
        var t = _.getTransitionDurationFromElement(e);

        g(e).one(_.TRANSITION_END, function (t) {
          return n._destroyElement(e, t);
        }).emulateTransitionEnd(t);
      } else this._destroyElement(e);
    }, t._destroyElement = function (t) {
      g(t).detach().trigger(h.CLOSED).remove();
    }, i._jQueryInterface = function (n) {
      return this.each(function () {
        var t = g(this),
            e = t.data(r);
        e || (e = new i(this), t.data(r, e)), "close" === n && e[n](this);
      });
    }, i._handleDismiss = function (e) {
      return function (t) {
        t && t.preventDefault(), e.close(this);
      };
    }, s(i, null, [{
      key: "VERSION",
      get: function get() {
        return "4.3.1";
      }
    }]), i;
  }();

  g(document).on(h.CLICK_DATA_API, '[data-dismiss="alert"]', p._handleDismiss(new p())), g.fn[o] = p._jQueryInterface, g.fn[o].Constructor = p, g.fn[o].noConflict = function () {
    return g.fn[o] = c, p._jQueryInterface;
  };

  var v = "button",
      y = "bs.button",
      E = "." + y,
      C = ".data-api",
      T = g.fn[v],
      S = "active",
      b = "btn",
      I = "focus",
      D = '[data-toggle^="button"]',
      w = '[data-toggle="buttons"]',
      A = 'input:not([type="hidden"])',
      N = ".active",
      O = ".btn",
      k = {
    CLICK_DATA_API: "click" + E + C,
    FOCUS_BLUR_DATA_API: "focus" + E + C + " blur" + E + C
  },
      P = function () {
    function n(t) {
      this._element = t;
    }

    var t = n.prototype;
    return t.toggle = function () {
      var t = !0,
          e = !0,
          n = g(this._element).closest(w)[0];

      if (n) {
        var i = this._element.querySelector(A);

        if (i) {
          if ("radio" === i.type) if (i.checked && this._element.classList.contains(S)) t = !1;else {
            var o = n.querySelector(N);
            o && g(o).removeClass(S);
          }

          if (t) {
            if (i.hasAttribute("disabled") || n.hasAttribute("disabled") || i.classList.contains("disabled") || n.classList.contains("disabled")) return;
            i.checked = !this._element.classList.contains(S), g(i).trigger("change");
          }

          i.focus(), e = !1;
        }
      }

      e && this._element.setAttribute("aria-pressed", !this._element.classList.contains(S)), t && g(this._element).toggleClass(S);
    }, t.dispose = function () {
      g.removeData(this._element, y), this._element = null;
    }, n._jQueryInterface = function (e) {
      return this.each(function () {
        var t = g(this).data(y);
        t || (t = new n(this), g(this).data(y, t)), "toggle" === e && t[e]();
      });
    }, s(n, null, [{
      key: "VERSION",
      get: function get() {
        return "4.3.1";
      }
    }]), n;
  }();

  g(document).on(k.CLICK_DATA_API, D, function (t) {
    t.preventDefault();
    var e = t.target;
    g(e).hasClass(b) || (e = g(e).closest(O)), P._jQueryInterface.call(g(e), "toggle");
  }).on(k.FOCUS_BLUR_DATA_API, D, function (t) {
    var e = g(t.target).closest(O)[0];
    g(e).toggleClass(I, /^focus(in)?$/.test(t.type));
  }), g.fn[v] = P._jQueryInterface, g.fn[v].Constructor = P, g.fn[v].noConflict = function () {
    return g.fn[v] = T, P._jQueryInterface;
  };

  var L = "carousel",
      j = "bs.carousel",
      H = "." + j,
      R = ".data-api",
      x = g.fn[L],
      F = {
    interval: 5e3,
    keyboard: !0,
    slide: !1,
    pause: "hover",
    wrap: !0,
    touch: !0
  },
      U = {
    interval: "(number|boolean)",
    keyboard: "boolean",
    slide: "(boolean|string)",
    pause: "(string|boolean)",
    wrap: "boolean",
    touch: "boolean"
  },
      W = "next",
      q = "prev",
      M = "left",
      K = "right",
      Q = {
    SLIDE: "slide" + H,
    SLID: "slid" + H,
    KEYDOWN: "keydown" + H,
    MOUSEENTER: "mouseenter" + H,
    MOUSELEAVE: "mouseleave" + H,
    TOUCHSTART: "touchstart" + H,
    TOUCHMOVE: "touchmove" + H,
    TOUCHEND: "touchend" + H,
    POINTERDOWN: "pointerdown" + H,
    POINTERUP: "pointerup" + H,
    DRAG_START: "dragstart" + H,
    LOAD_DATA_API: "load" + H + R,
    CLICK_DATA_API: "click" + H + R
  },
      B = "carousel",
      V = "active",
      Y = "slide",
      z = "carousel-item-right",
      X = "carousel-item-left",
      $ = "carousel-item-next",
      G = "carousel-item-prev",
      J = "pointer-event",
      Z = ".active",
      tt = ".active.carousel-item",
      et = ".carousel-item",
      nt = ".carousel-item img",
      it = ".carousel-item-next, .carousel-item-prev",
      ot = ".carousel-indicators",
      rt = "[data-slide], [data-slide-to]",
      st = '[data-ride="carousel"]',
      at = {
    TOUCH: "touch",
    PEN: "pen"
  },
      lt = function () {
    function r(t, e) {
      this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._element = t, this._indicatorsElement = this._element.querySelector(ot), this._touchSupported = "ontouchstart" in document.documentElement || 0 < navigator.maxTouchPoints, this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent), this._addEventListeners();
    }

    var t = r.prototype;
    return t.next = function () {
      this._isSliding || this._slide(W);
    }, t.nextWhenVisible = function () {
      !document.hidden && g(this._element).is(":visible") && "hidden" !== g(this._element).css("visibility") && this.next();
    }, t.prev = function () {
      this._isSliding || this._slide(q);
    }, t.pause = function (t) {
      t || (this._isPaused = !0), this._element.querySelector(it) && (_.triggerTransitionEnd(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null;
    }, t.cycle = function (t) {
      t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config.interval && !this._isPaused && (this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval));
    }, t.to = function (t) {
      var e = this;
      this._activeElement = this._element.querySelector(tt);

      var n = this._getItemIndex(this._activeElement);

      if (!(t > this._items.length - 1 || t < 0)) if (this._isSliding) g(this._element).one(Q.SLID, function () {
        return e.to(t);
      });else {
        if (n === t) return this.pause(), void this.cycle();
        var i = n < t ? W : q;

        this._slide(i, this._items[t]);
      }
    }, t.dispose = function () {
      g(this._element).off(H), g.removeData(this._element, j), this._items = null, this._config = null, this._element = null, this._interval = null, this._isPaused = null, this._isSliding = null, this._activeElement = null, this._indicatorsElement = null;
    }, t._getConfig = function (t) {
      return t = l({}, F, t), _.typeCheckConfig(L, t, U), t;
    }, t._handleSwipe = function () {
      var t = Math.abs(this.touchDeltaX);

      if (!(t <= 40)) {
        var e = t / this.touchDeltaX;
        0 < e && this.prev(), e < 0 && this.next();
      }
    }, t._addEventListeners = function () {
      var e = this;
      this._config.keyboard && g(this._element).on(Q.KEYDOWN, function (t) {
        return e._keydown(t);
      }), "hover" === this._config.pause && g(this._element).on(Q.MOUSEENTER, function (t) {
        return e.pause(t);
      }).on(Q.MOUSELEAVE, function (t) {
        return e.cycle(t);
      }), this._config.touch && this._addTouchEventListeners();
    }, t._addTouchEventListeners = function () {
      var n = this;

      if (this._touchSupported) {
        var e = function e(t) {
          n._pointerEvent && at[t.originalEvent.pointerType.toUpperCase()] ? n.touchStartX = t.originalEvent.clientX : n._pointerEvent || (n.touchStartX = t.originalEvent.touches[0].clientX);
        },
            i = function i(t) {
          n._pointerEvent && at[t.originalEvent.pointerType.toUpperCase()] && (n.touchDeltaX = t.originalEvent.clientX - n.touchStartX), n._handleSwipe(), "hover" === n._config.pause && (n.pause(), n.touchTimeout && clearTimeout(n.touchTimeout), n.touchTimeout = setTimeout(function (t) {
            return n.cycle(t);
          }, 500 + n._config.interval));
        };

        g(this._element.querySelectorAll(nt)).on(Q.DRAG_START, function (t) {
          return t.preventDefault();
        }), this._pointerEvent ? (g(this._element).on(Q.POINTERDOWN, function (t) {
          return e(t);
        }), g(this._element).on(Q.POINTERUP, function (t) {
          return i(t);
        }), this._element.classList.add(J)) : (g(this._element).on(Q.TOUCHSTART, function (t) {
          return e(t);
        }), g(this._element).on(Q.TOUCHMOVE, function (t) {
          var e;
          (e = t).originalEvent.touches && 1 < e.originalEvent.touches.length ? n.touchDeltaX = 0 : n.touchDeltaX = e.originalEvent.touches[0].clientX - n.touchStartX;
        }), g(this._element).on(Q.TOUCHEND, function (t) {
          return i(t);
        }));
      }
    }, t._keydown = function (t) {
      if (!/input|textarea/i.test(t.target.tagName)) switch (t.which) {
        case 37:
          t.preventDefault(), this.prev();
          break;

        case 39:
          t.preventDefault(), this.next();
      }
    }, t._getItemIndex = function (t) {
      return this._items = t && t.parentNode ? [].slice.call(t.parentNode.querySelectorAll(et)) : [], this._items.indexOf(t);
    }, t._getItemByDirection = function (t, e) {
      var n = t === W,
          i = t === q,
          o = this._getItemIndex(e),
          r = this._items.length - 1;

      if ((i && 0 === o || n && o === r) && !this._config.wrap) return e;
      var s = (o + (t === q ? -1 : 1)) % this._items.length;
      return -1 === s ? this._items[this._items.length - 1] : this._items[s];
    }, t._triggerSlideEvent = function (t, e) {
      var n = this._getItemIndex(t),
          i = this._getItemIndex(this._element.querySelector(tt)),
          o = g.Event(Q.SLIDE, {
        relatedTarget: t,
        direction: e,
        from: i,
        to: n
      });

      return g(this._element).trigger(o), o;
    }, t._setActiveIndicatorElement = function (t) {
      if (this._indicatorsElement) {
        var e = [].slice.call(this._indicatorsElement.querySelectorAll(Z));
        g(e).removeClass(V);

        var n = this._indicatorsElement.children[this._getItemIndex(t)];

        n && g(n).addClass(V);
      }
    }, t._slide = function (t, e) {
      var n,
          i,
          o,
          r = this,
          s = this._element.querySelector(tt),
          a = this._getItemIndex(s),
          l = e || s && this._getItemByDirection(t, s),
          c = this._getItemIndex(l),
          h = Boolean(this._interval);

      if (o = t === W ? (n = X, i = $, M) : (n = z, i = G, K), l && g(l).hasClass(V)) this._isSliding = !1;else if (!this._triggerSlideEvent(l, o).isDefaultPrevented() && s && l) {
        this._isSliding = !0, h && this.pause(), this._setActiveIndicatorElement(l);
        var u = g.Event(Q.SLID, {
          relatedTarget: l,
          direction: o,
          from: a,
          to: c
        });

        if (g(this._element).hasClass(Y)) {
          g(l).addClass(i), _.reflow(l), g(s).addClass(n), g(l).addClass(n);
          var f = parseInt(l.getAttribute("data-interval"), 10);
          this._config.interval = f ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, f) : this._config.defaultInterval || this._config.interval;

          var d = _.getTransitionDurationFromElement(s);

          g(s).one(_.TRANSITION_END, function () {
            g(l).removeClass(n + " " + i).addClass(V), g(s).removeClass(V + " " + i + " " + n), r._isSliding = !1, setTimeout(function () {
              return g(r._element).trigger(u);
            }, 0);
          }).emulateTransitionEnd(d);
        } else g(s).removeClass(V), g(l).addClass(V), this._isSliding = !1, g(this._element).trigger(u);

        h && this.cycle();
      }
    }, r._jQueryInterface = function (i) {
      return this.each(function () {
        var t = g(this).data(j),
            e = l({}, F, g(this).data());
        "object" == _typeof(i) && (e = l({}, e, i));
        var n = "string" == typeof i ? i : e.slide;
        if (t || (t = new r(this, e), g(this).data(j, t)), "number" == typeof i) t.to(i);else if ("string" == typeof n) {
          if ("undefined" == typeof t[n]) throw new TypeError('No method named "' + n + '"');
          t[n]();
        } else e.interval && e.ride && (t.pause(), t.cycle());
      });
    }, r._dataApiClickHandler = function (t) {
      var e = _.getSelectorFromElement(this);

      if (e) {
        var n = g(e)[0];

        if (n && g(n).hasClass(B)) {
          var i = l({}, g(n).data(), g(this).data()),
              o = this.getAttribute("data-slide-to");
          o && (i.interval = !1), r._jQueryInterface.call(g(n), i), o && g(n).data(j).to(o), t.preventDefault();
        }
      }
    }, s(r, null, [{
      key: "VERSION",
      get: function get() {
        return "4.3.1";
      }
    }, {
      key: "Default",
      get: function get() {
        return F;
      }
    }]), r;
  }();

  g(document).on(Q.CLICK_DATA_API, rt, lt._dataApiClickHandler), g(window).on(Q.LOAD_DATA_API, function () {
    for (var t = [].slice.call(document.querySelectorAll(st)), e = 0, n = t.length; e < n; e++) {
      var i = g(t[e]);

      lt._jQueryInterface.call(i, i.data());
    }
  }), g.fn[L] = lt._jQueryInterface, g.fn[L].Constructor = lt, g.fn[L].noConflict = function () {
    return g.fn[L] = x, lt._jQueryInterface;
  };

  var ct = "collapse",
      ht = "bs.collapse",
      ut = "." + ht,
      ft = g.fn[ct],
      dt = {
    toggle: !0,
    parent: ""
  },
      gt = {
    toggle: "boolean",
    parent: "(string|element)"
  },
      _t = {
    SHOW: "show" + ut,
    SHOWN: "shown" + ut,
    HIDE: "hide" + ut,
    HIDDEN: "hidden" + ut,
    CLICK_DATA_API: "click" + ut + ".data-api"
  },
      mt = "show",
      pt = "collapse",
      vt = "collapsing",
      yt = "collapsed",
      Et = "width",
      Ct = "height",
      Tt = ".show, .collapsing",
      St = '[data-toggle="collapse"]',
      bt = function () {
    function a(e, t) {
      this._isTransitioning = !1, this._element = e, this._config = this._getConfig(t), this._triggerArray = [].slice.call(document.querySelectorAll('[data-toggle="collapse"][href="#' + e.id + '"],[data-toggle="collapse"][data-target="#' + e.id + '"]'));

      for (var n = [].slice.call(document.querySelectorAll(St)), i = 0, o = n.length; i < o; i++) {
        var r = n[i],
            s = _.getSelectorFromElement(r),
            a = [].slice.call(document.querySelectorAll(s)).filter(function (t) {
          return t === e;
        });

        null !== s && 0 < a.length && (this._selector = s, this._triggerArray.push(r));
      }

      this._parent = this._config.parent ? this._getParent() : null, this._config.parent || this._addAriaAndCollapsedClass(this._element, this._triggerArray), this._config.toggle && this.toggle();
    }

    var t = a.prototype;
    return t.toggle = function () {
      g(this._element).hasClass(mt) ? this.hide() : this.show();
    }, t.show = function () {
      var t,
          e,
          n = this;

      if (!this._isTransitioning && !g(this._element).hasClass(mt) && (this._parent && 0 === (t = [].slice.call(this._parent.querySelectorAll(Tt)).filter(function (t) {
        return "string" == typeof n._config.parent ? t.getAttribute("data-parent") === n._config.parent : t.classList.contains(pt);
      })).length && (t = null), !(t && (e = g(t).not(this._selector).data(ht)) && e._isTransitioning))) {
        var i = g.Event(_t.SHOW);

        if (g(this._element).trigger(i), !i.isDefaultPrevented()) {
          t && (a._jQueryInterface.call(g(t).not(this._selector), "hide"), e || g(t).data(ht, null));

          var o = this._getDimension();

          g(this._element).removeClass(pt).addClass(vt), this._element.style[o] = 0, this._triggerArray.length && g(this._triggerArray).removeClass(yt).attr("aria-expanded", !0), this.setTransitioning(!0);

          var r = "scroll" + (o[0].toUpperCase() + o.slice(1)),
              s = _.getTransitionDurationFromElement(this._element);

          g(this._element).one(_.TRANSITION_END, function () {
            g(n._element).removeClass(vt).addClass(pt).addClass(mt), n._element.style[o] = "", n.setTransitioning(!1), g(n._element).trigger(_t.SHOWN);
          }).emulateTransitionEnd(s), this._element.style[o] = this._element[r] + "px";
        }
      }
    }, t.hide = function () {
      var t = this;

      if (!this._isTransitioning && g(this._element).hasClass(mt)) {
        var e = g.Event(_t.HIDE);

        if (g(this._element).trigger(e), !e.isDefaultPrevented()) {
          var n = this._getDimension();

          this._element.style[n] = this._element.getBoundingClientRect()[n] + "px", _.reflow(this._element), g(this._element).addClass(vt).removeClass(pt).removeClass(mt);
          var i = this._triggerArray.length;
          if (0 < i) for (var o = 0; o < i; o++) {
            var r = this._triggerArray[o],
                s = _.getSelectorFromElement(r);

            if (null !== s) g([].slice.call(document.querySelectorAll(s))).hasClass(mt) || g(r).addClass(yt).attr("aria-expanded", !1);
          }
          this.setTransitioning(!0);
          this._element.style[n] = "";

          var a = _.getTransitionDurationFromElement(this._element);

          g(this._element).one(_.TRANSITION_END, function () {
            t.setTransitioning(!1), g(t._element).removeClass(vt).addClass(pt).trigger(_t.HIDDEN);
          }).emulateTransitionEnd(a);
        }
      }
    }, t.setTransitioning = function (t) {
      this._isTransitioning = t;
    }, t.dispose = function () {
      g.removeData(this._element, ht), this._config = null, this._parent = null, this._element = null, this._triggerArray = null, this._isTransitioning = null;
    }, t._getConfig = function (t) {
      return (t = l({}, dt, t)).toggle = Boolean(t.toggle), _.typeCheckConfig(ct, t, gt), t;
    }, t._getDimension = function () {
      return g(this._element).hasClass(Et) ? Et : Ct;
    }, t._getParent = function () {
      var t,
          n = this;
      _.isElement(this._config.parent) ? (t = this._config.parent, "undefined" != typeof this._config.parent.jquery && (t = this._config.parent[0])) : t = document.querySelector(this._config.parent);
      var e = '[data-toggle="collapse"][data-parent="' + this._config.parent + '"]',
          i = [].slice.call(t.querySelectorAll(e));
      return g(i).each(function (t, e) {
        n._addAriaAndCollapsedClass(a._getTargetFromElement(e), [e]);
      }), t;
    }, t._addAriaAndCollapsedClass = function (t, e) {
      var n = g(t).hasClass(mt);
      e.length && g(e).toggleClass(yt, !n).attr("aria-expanded", n);
    }, a._getTargetFromElement = function (t) {
      var e = _.getSelectorFromElement(t);

      return e ? document.querySelector(e) : null;
    }, a._jQueryInterface = function (i) {
      return this.each(function () {
        var t = g(this),
            e = t.data(ht),
            n = l({}, dt, t.data(), "object" == _typeof(i) && i ? i : {});

        if (!e && n.toggle && /show|hide/.test(i) && (n.toggle = !1), e || (e = new a(this, n), t.data(ht, e)), "string" == typeof i) {
          if ("undefined" == typeof e[i]) throw new TypeError('No method named "' + i + '"');
          e[i]();
        }
      });
    }, s(a, null, [{
      key: "VERSION",
      get: function get() {
        return "4.3.1";
      }
    }, {
      key: "Default",
      get: function get() {
        return dt;
      }
    }]), a;
  }();

  g(document).on(_t.CLICK_DATA_API, St, function (t) {
    "A" === t.currentTarget.tagName && t.preventDefault();

    var n = g(this),
        e = _.getSelectorFromElement(this),
        i = [].slice.call(document.querySelectorAll(e));

    g(i).each(function () {
      var t = g(this),
          e = t.data(ht) ? "toggle" : n.data();

      bt._jQueryInterface.call(t, e);
    });
  }), g.fn[ct] = bt._jQueryInterface, g.fn[ct].Constructor = bt, g.fn[ct].noConflict = function () {
    return g.fn[ct] = ft, bt._jQueryInterface;
  };

  var It = "dropdown",
      Dt = "bs.dropdown",
      wt = "." + Dt,
      At = ".data-api",
      Nt = g.fn[It],
      Ot = new RegExp("38|40|27"),
      kt = {
    HIDE: "hide" + wt,
    HIDDEN: "hidden" + wt,
    SHOW: "show" + wt,
    SHOWN: "shown" + wt,
    CLICK: "click" + wt,
    CLICK_DATA_API: "click" + wt + At,
    KEYDOWN_DATA_API: "keydown" + wt + At,
    KEYUP_DATA_API: "keyup" + wt + At
  },
      Pt = "disabled",
      Lt = "show",
      jt = "dropup",
      Ht = "dropright",
      Rt = "dropleft",
      xt = "dropdown-menu-right",
      Ft = "position-static",
      Ut = '[data-toggle="dropdown"]',
      Wt = ".dropdown form",
      qt = ".dropdown-menu",
      Mt = ".navbar-nav",
      Kt = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)",
      Qt = "top-start",
      Bt = "top-end",
      Vt = "bottom-start",
      Yt = "bottom-end",
      zt = "right-start",
      Xt = "left-start",
      $t = {
    offset: 0,
    flip: !0,
    boundary: "scrollParent",
    reference: "toggle",
    display: "dynamic"
  },
      Gt = {
    offset: "(number|string|function)",
    flip: "boolean",
    boundary: "(string|element)",
    reference: "(string|element)",
    display: "string"
  },
      Jt = function () {
    function c(t, e) {
      this._element = t, this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._addEventListeners();
    }

    var t = c.prototype;
    return t.toggle = function () {
      if (!this._element.disabled && !g(this._element).hasClass(Pt)) {
        var t = c._getParentFromElement(this._element),
            e = g(this._menu).hasClass(Lt);

        if (c._clearMenus(), !e) {
          var n = {
            relatedTarget: this._element
          },
              i = g.Event(kt.SHOW, n);

          if (g(t).trigger(i), !i.isDefaultPrevented()) {
            if (!this._inNavbar) {
              if ("undefined" == typeof u) throw new TypeError("Bootstrap's dropdowns require Popper.js (https://popper.js.org/)");
              var o = this._element;
              "parent" === this._config.reference ? o = t : _.isElement(this._config.reference) && (o = this._config.reference, "undefined" != typeof this._config.reference.jquery && (o = this._config.reference[0])), "scrollParent" !== this._config.boundary && g(t).addClass(Ft), this._popper = new u(o, this._menu, this._getPopperConfig());
            }

            "ontouchstart" in document.documentElement && 0 === g(t).closest(Mt).length && g(document.body).children().on("mouseover", null, g.noop), this._element.focus(), this._element.setAttribute("aria-expanded", !0), g(this._menu).toggleClass(Lt), g(t).toggleClass(Lt).trigger(g.Event(kt.SHOWN, n));
          }
        }
      }
    }, t.show = function () {
      if (!(this._element.disabled || g(this._element).hasClass(Pt) || g(this._menu).hasClass(Lt))) {
        var t = {
          relatedTarget: this._element
        },
            e = g.Event(kt.SHOW, t),
            n = c._getParentFromElement(this._element);

        g(n).trigger(e), e.isDefaultPrevented() || (g(this._menu).toggleClass(Lt), g(n).toggleClass(Lt).trigger(g.Event(kt.SHOWN, t)));
      }
    }, t.hide = function () {
      if (!this._element.disabled && !g(this._element).hasClass(Pt) && g(this._menu).hasClass(Lt)) {
        var t = {
          relatedTarget: this._element
        },
            e = g.Event(kt.HIDE, t),
            n = c._getParentFromElement(this._element);

        g(n).trigger(e), e.isDefaultPrevented() || (g(this._menu).toggleClass(Lt), g(n).toggleClass(Lt).trigger(g.Event(kt.HIDDEN, t)));
      }
    }, t.dispose = function () {
      g.removeData(this._element, Dt), g(this._element).off(wt), this._element = null, (this._menu = null) !== this._popper && (this._popper.destroy(), this._popper = null);
    }, t.update = function () {
      this._inNavbar = this._detectNavbar(), null !== this._popper && this._popper.scheduleUpdate();
    }, t._addEventListeners = function () {
      var e = this;
      g(this._element).on(kt.CLICK, function (t) {
        t.preventDefault(), t.stopPropagation(), e.toggle();
      });
    }, t._getConfig = function (t) {
      return t = l({}, this.constructor.Default, g(this._element).data(), t), _.typeCheckConfig(It, t, this.constructor.DefaultType), t;
    }, t._getMenuElement = function () {
      if (!this._menu) {
        var t = c._getParentFromElement(this._element);

        t && (this._menu = t.querySelector(qt));
      }

      return this._menu;
    }, t._getPlacement = function () {
      var t = g(this._element.parentNode),
          e = Vt;
      return t.hasClass(jt) ? (e = Qt, g(this._menu).hasClass(xt) && (e = Bt)) : t.hasClass(Ht) ? e = zt : t.hasClass(Rt) ? e = Xt : g(this._menu).hasClass(xt) && (e = Yt), e;
    }, t._detectNavbar = function () {
      return 0 < g(this._element).closest(".navbar").length;
    }, t._getOffset = function () {
      var e = this,
          t = {};
      return "function" == typeof this._config.offset ? t.fn = function (t) {
        return t.offsets = l({}, t.offsets, e._config.offset(t.offsets, e._element) || {}), t;
      } : t.offset = this._config.offset, t;
    }, t._getPopperConfig = function () {
      var t = {
        placement: this._getPlacement(),
        modifiers: {
          offset: this._getOffset(),
          flip: {
            enabled: this._config.flip
          },
          preventOverflow: {
            boundariesElement: this._config.boundary
          }
        }
      };
      return "static" === this._config.display && (t.modifiers.applyStyle = {
        enabled: !1
      }), t;
    }, c._jQueryInterface = function (e) {
      return this.each(function () {
        var t = g(this).data(Dt);

        if (t || (t = new c(this, "object" == _typeof(e) ? e : null), g(this).data(Dt, t)), "string" == typeof e) {
          if ("undefined" == typeof t[e]) throw new TypeError('No method named "' + e + '"');
          t[e]();
        }
      });
    }, c._clearMenus = function (t) {
      if (!t || 3 !== t.which && ("keyup" !== t.type || 9 === t.which)) for (var e = [].slice.call(document.querySelectorAll(Ut)), n = 0, i = e.length; n < i; n++) {
        var o = c._getParentFromElement(e[n]),
            r = g(e[n]).data(Dt),
            s = {
          relatedTarget: e[n]
        };

        if (t && "click" === t.type && (s.clickEvent = t), r) {
          var a = r._menu;

          if (g(o).hasClass(Lt) && !(t && ("click" === t.type && /input|textarea/i.test(t.target.tagName) || "keyup" === t.type && 9 === t.which) && g.contains(o, t.target))) {
            var l = g.Event(kt.HIDE, s);
            g(o).trigger(l), l.isDefaultPrevented() || ("ontouchstart" in document.documentElement && g(document.body).children().off("mouseover", null, g.noop), e[n].setAttribute("aria-expanded", "false"), g(a).removeClass(Lt), g(o).removeClass(Lt).trigger(g.Event(kt.HIDDEN, s)));
          }
        }
      }
    }, c._getParentFromElement = function (t) {
      var e,
          n = _.getSelectorFromElement(t);

      return n && (e = document.querySelector(n)), e || t.parentNode;
    }, c._dataApiKeydownHandler = function (t) {
      if ((/input|textarea/i.test(t.target.tagName) ? !(32 === t.which || 27 !== t.which && (40 !== t.which && 38 !== t.which || g(t.target).closest(qt).length)) : Ot.test(t.which)) && (t.preventDefault(), t.stopPropagation(), !this.disabled && !g(this).hasClass(Pt))) {
        var e = c._getParentFromElement(this),
            n = g(e).hasClass(Lt);

        if (n && (!n || 27 !== t.which && 32 !== t.which)) {
          var i = [].slice.call(e.querySelectorAll(Kt));

          if (0 !== i.length) {
            var o = i.indexOf(t.target);
            38 === t.which && 0 < o && o--, 40 === t.which && o < i.length - 1 && o++, o < 0 && (o = 0), i[o].focus();
          }
        } else {
          if (27 === t.which) {
            var r = e.querySelector(Ut);
            g(r).trigger("focus");
          }

          g(this).trigger("click");
        }
      }
    }, s(c, null, [{
      key: "VERSION",
      get: function get() {
        return "4.3.1";
      }
    }, {
      key: "Default",
      get: function get() {
        return $t;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return Gt;
      }
    }]), c;
  }();

  g(document).on(kt.KEYDOWN_DATA_API, Ut, Jt._dataApiKeydownHandler).on(kt.KEYDOWN_DATA_API, qt, Jt._dataApiKeydownHandler).on(kt.CLICK_DATA_API + " " + kt.KEYUP_DATA_API, Jt._clearMenus).on(kt.CLICK_DATA_API, Ut, function (t) {
    t.preventDefault(), t.stopPropagation(), Jt._jQueryInterface.call(g(this), "toggle");
  }).on(kt.CLICK_DATA_API, Wt, function (t) {
    t.stopPropagation();
  }), g.fn[It] = Jt._jQueryInterface, g.fn[It].Constructor = Jt, g.fn[It].noConflict = function () {
    return g.fn[It] = Nt, Jt._jQueryInterface;
  };

  var Zt = "modal",
      te = "bs.modal",
      ee = "." + te,
      ne = g.fn[Zt],
      ie = {
    backdrop: !0,
    keyboard: !0,
    focus: !0,
    show: !0
  },
      oe = {
    backdrop: "(boolean|string)",
    keyboard: "boolean",
    focus: "boolean",
    show: "boolean"
  },
      re = {
    HIDE: "hide" + ee,
    HIDDEN: "hidden" + ee,
    SHOW: "show" + ee,
    SHOWN: "shown" + ee,
    FOCUSIN: "focusin" + ee,
    RESIZE: "resize" + ee,
    CLICK_DISMISS: "click.dismiss" + ee,
    KEYDOWN_DISMISS: "keydown.dismiss" + ee,
    MOUSEUP_DISMISS: "mouseup.dismiss" + ee,
    MOUSEDOWN_DISMISS: "mousedown.dismiss" + ee,
    CLICK_DATA_API: "click" + ee + ".data-api"
  },
      se = "modal-dialog-scrollable",
      ae = "modal-scrollbar-measure",
      le = "modal-backdrop",
      ce = "modal-open",
      he = "fade",
      ue = "show",
      fe = ".modal-dialog",
      de = ".modal-body",
      ge = '[data-toggle="modal"]',
      _e = '[data-dismiss="modal"]',
      me = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
      pe = ".sticky-top",
      ve = function () {
    function o(t, e) {
      this._config = this._getConfig(e), this._element = t, this._dialog = t.querySelector(fe), this._backdrop = null, this._isShown = !1, this._isBodyOverflowing = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollbarWidth = 0;
    }

    var t = o.prototype;
    return t.toggle = function (t) {
      return this._isShown ? this.hide() : this.show(t);
    }, t.show = function (t) {
      var e = this;

      if (!this._isShown && !this._isTransitioning) {
        g(this._element).hasClass(he) && (this._isTransitioning = !0);
        var n = g.Event(re.SHOW, {
          relatedTarget: t
        });
        g(this._element).trigger(n), this._isShown || n.isDefaultPrevented() || (this._isShown = !0, this._checkScrollbar(), this._setScrollbar(), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), g(this._element).on(re.CLICK_DISMISS, _e, function (t) {
          return e.hide(t);
        }), g(this._dialog).on(re.MOUSEDOWN_DISMISS, function () {
          g(e._element).one(re.MOUSEUP_DISMISS, function (t) {
            g(t.target).is(e._element) && (e._ignoreBackdropClick = !0);
          });
        }), this._showBackdrop(function () {
          return e._showElement(t);
        }));
      }
    }, t.hide = function (t) {
      var e = this;

      if (t && t.preventDefault(), this._isShown && !this._isTransitioning) {
        var n = g.Event(re.HIDE);

        if (g(this._element).trigger(n), this._isShown && !n.isDefaultPrevented()) {
          this._isShown = !1;
          var i = g(this._element).hasClass(he);

          if (i && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), g(document).off(re.FOCUSIN), g(this._element).removeClass(ue), g(this._element).off(re.CLICK_DISMISS), g(this._dialog).off(re.MOUSEDOWN_DISMISS), i) {
            var o = _.getTransitionDurationFromElement(this._element);

            g(this._element).one(_.TRANSITION_END, function (t) {
              return e._hideModal(t);
            }).emulateTransitionEnd(o);
          } else this._hideModal();
        }
      }
    }, t.dispose = function () {
      [window, this._element, this._dialog].forEach(function (t) {
        return g(t).off(ee);
      }), g(document).off(re.FOCUSIN), g.removeData(this._element, te), this._config = null, this._element = null, this._dialog = null, this._backdrop = null, this._isShown = null, this._isBodyOverflowing = null, this._ignoreBackdropClick = null, this._isTransitioning = null, this._scrollbarWidth = null;
    }, t.handleUpdate = function () {
      this._adjustDialog();
    }, t._getConfig = function (t) {
      return t = l({}, ie, t), _.typeCheckConfig(Zt, t, oe), t;
    }, t._showElement = function (t) {
      var e = this,
          n = g(this._element).hasClass(he);
      this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), g(this._dialog).hasClass(se) ? this._dialog.querySelector(de).scrollTop = 0 : this._element.scrollTop = 0, n && _.reflow(this._element), g(this._element).addClass(ue), this._config.focus && this._enforceFocus();

      var i = g.Event(re.SHOWN, {
        relatedTarget: t
      }),
          o = function o() {
        e._config.focus && e._element.focus(), e._isTransitioning = !1, g(e._element).trigger(i);
      };

      if (n) {
        var r = _.getTransitionDurationFromElement(this._dialog);

        g(this._dialog).one(_.TRANSITION_END, o).emulateTransitionEnd(r);
      } else o();
    }, t._enforceFocus = function () {
      var e = this;
      g(document).off(re.FOCUSIN).on(re.FOCUSIN, function (t) {
        document !== t.target && e._element !== t.target && 0 === g(e._element).has(t.target).length && e._element.focus();
      });
    }, t._setEscapeEvent = function () {
      var e = this;
      this._isShown && this._config.keyboard ? g(this._element).on(re.KEYDOWN_DISMISS, function (t) {
        27 === t.which && (t.preventDefault(), e.hide());
      }) : this._isShown || g(this._element).off(re.KEYDOWN_DISMISS);
    }, t._setResizeEvent = function () {
      var e = this;
      this._isShown ? g(window).on(re.RESIZE, function (t) {
        return e.handleUpdate(t);
      }) : g(window).off(re.RESIZE);
    }, t._hideModal = function () {
      var t = this;
      this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._isTransitioning = !1, this._showBackdrop(function () {
        g(document.body).removeClass(ce), t._resetAdjustments(), t._resetScrollbar(), g(t._element).trigger(re.HIDDEN);
      });
    }, t._removeBackdrop = function () {
      this._backdrop && (g(this._backdrop).remove(), this._backdrop = null);
    }, t._showBackdrop = function (t) {
      var e = this,
          n = g(this._element).hasClass(he) ? he : "";

      if (this._isShown && this._config.backdrop) {
        if (this._backdrop = document.createElement("div"), this._backdrop.className = le, n && this._backdrop.classList.add(n), g(this._backdrop).appendTo(document.body), g(this._element).on(re.CLICK_DISMISS, function (t) {
          e._ignoreBackdropClick ? e._ignoreBackdropClick = !1 : t.target === t.currentTarget && ("static" === e._config.backdrop ? e._element.focus() : e.hide());
        }), n && _.reflow(this._backdrop), g(this._backdrop).addClass(ue), !t) return;
        if (!n) return void t();

        var i = _.getTransitionDurationFromElement(this._backdrop);

        g(this._backdrop).one(_.TRANSITION_END, t).emulateTransitionEnd(i);
      } else if (!this._isShown && this._backdrop) {
        g(this._backdrop).removeClass(ue);

        var o = function o() {
          e._removeBackdrop(), t && t();
        };

        if (g(this._element).hasClass(he)) {
          var r = _.getTransitionDurationFromElement(this._backdrop);

          g(this._backdrop).one(_.TRANSITION_END, o).emulateTransitionEnd(r);
        } else o();
      } else t && t();
    }, t._adjustDialog = function () {
      var t = this._element.scrollHeight > document.documentElement.clientHeight;
      !this._isBodyOverflowing && t && (this._element.style.paddingLeft = this._scrollbarWidth + "px"), this._isBodyOverflowing && !t && (this._element.style.paddingRight = this._scrollbarWidth + "px");
    }, t._resetAdjustments = function () {
      this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
    }, t._checkScrollbar = function () {
      var t = document.body.getBoundingClientRect();
      this._isBodyOverflowing = t.left + t.right < window.innerWidth, this._scrollbarWidth = this._getScrollbarWidth();
    }, t._setScrollbar = function () {
      var o = this;

      if (this._isBodyOverflowing) {
        var t = [].slice.call(document.querySelectorAll(me)),
            e = [].slice.call(document.querySelectorAll(pe));
        g(t).each(function (t, e) {
          var n = e.style.paddingRight,
              i = g(e).css("padding-right");
          g(e).data("padding-right", n).css("padding-right", parseFloat(i) + o._scrollbarWidth + "px");
        }), g(e).each(function (t, e) {
          var n = e.style.marginRight,
              i = g(e).css("margin-right");
          g(e).data("margin-right", n).css("margin-right", parseFloat(i) - o._scrollbarWidth + "px");
        });
        var n = document.body.style.paddingRight,
            i = g(document.body).css("padding-right");
        g(document.body).data("padding-right", n).css("padding-right", parseFloat(i) + this._scrollbarWidth + "px");
      }

      g(document.body).addClass(ce);
    }, t._resetScrollbar = function () {
      var t = [].slice.call(document.querySelectorAll(me));
      g(t).each(function (t, e) {
        var n = g(e).data("padding-right");
        g(e).removeData("padding-right"), e.style.paddingRight = n || "";
      });
      var e = [].slice.call(document.querySelectorAll("" + pe));
      g(e).each(function (t, e) {
        var n = g(e).data("margin-right");
        "undefined" != typeof n && g(e).css("margin-right", n).removeData("margin-right");
      });
      var n = g(document.body).data("padding-right");
      g(document.body).removeData("padding-right"), document.body.style.paddingRight = n || "";
    }, t._getScrollbarWidth = function () {
      var t = document.createElement("div");
      t.className = ae, document.body.appendChild(t);
      var e = t.getBoundingClientRect().width - t.clientWidth;
      return document.body.removeChild(t), e;
    }, o._jQueryInterface = function (n, i) {
      return this.each(function () {
        var t = g(this).data(te),
            e = l({}, ie, g(this).data(), "object" == _typeof(n) && n ? n : {});

        if (t || (t = new o(this, e), g(this).data(te, t)), "string" == typeof n) {
          if ("undefined" == typeof t[n]) throw new TypeError('No method named "' + n + '"');
          t[n](i);
        } else e.show && t.show(i);
      });
    }, s(o, null, [{
      key: "VERSION",
      get: function get() {
        return "4.3.1";
      }
    }, {
      key: "Default",
      get: function get() {
        return ie;
      }
    }]), o;
  }();

  g(document).on(re.CLICK_DATA_API, ge, function (t) {
    var e,
        n = this,
        i = _.getSelectorFromElement(this);

    i && (e = document.querySelector(i));
    var o = g(e).data(te) ? "toggle" : l({}, g(e).data(), g(this).data());
    "A" !== this.tagName && "AREA" !== this.tagName || t.preventDefault();
    var r = g(e).one(re.SHOW, function (t) {
      t.isDefaultPrevented() || r.one(re.HIDDEN, function () {
        g(n).is(":visible") && n.focus();
      });
    });

    ve._jQueryInterface.call(g(e), o, this);
  }), g.fn[Zt] = ve._jQueryInterface, g.fn[Zt].Constructor = ve, g.fn[Zt].noConflict = function () {
    return g.fn[Zt] = ne, ve._jQueryInterface;
  };
  var ye = ["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"],
      Ee = {
    "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
    a: ["target", "href", "title", "rel"],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    div: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: ["src", "alt", "title", "width", "height"],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
  },
      Ce = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi,
      Te = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;

  function Se(t, s, e) {
    if (0 === t.length) return t;
    if (e && "function" == typeof e) return e(t);

    for (var n = new window.DOMParser().parseFromString(t, "text/html"), a = Object.keys(s), l = [].slice.call(n.body.querySelectorAll("*")), i = function i(t, e) {
      var n = l[t],
          i = n.nodeName.toLowerCase();
      if (-1 === a.indexOf(n.nodeName.toLowerCase())) return n.parentNode.removeChild(n), "continue";
      var o = [].slice.call(n.attributes),
          r = [].concat(s["*"] || [], s[i] || []);
      o.forEach(function (t) {
        (function (t, e) {
          var n = t.nodeName.toLowerCase();
          if (-1 !== e.indexOf(n)) return -1 === ye.indexOf(n) || Boolean(t.nodeValue.match(Ce) || t.nodeValue.match(Te));

          for (var i = e.filter(function (t) {
            return t instanceof RegExp;
          }), o = 0, r = i.length; o < r; o++) {
            if (n.match(i[o])) return !0;
          }

          return !1;
        })(t, r) || n.removeAttribute(t.nodeName);
      });
    }, o = 0, r = l.length; o < r; o++) {
      i(o);
    }

    return n.body.innerHTML;
  }

  var be = "tooltip",
      Ie = "bs.tooltip",
      De = "." + Ie,
      we = g.fn[be],
      Ae = "bs-tooltip",
      Ne = new RegExp("(^|\\s)" + Ae + "\\S+", "g"),
      Oe = ["sanitize", "whiteList", "sanitizeFn"],
      ke = {
    animation: "boolean",
    template: "string",
    title: "(string|element|function)",
    trigger: "string",
    delay: "(number|object)",
    html: "boolean",
    selector: "(string|boolean)",
    placement: "(string|function)",
    offset: "(number|string|function)",
    container: "(string|element|boolean)",
    fallbackPlacement: "(string|array)",
    boundary: "(string|element)",
    sanitize: "boolean",
    sanitizeFn: "(null|function)",
    whiteList: "object"
  },
      Pe = {
    AUTO: "auto",
    TOP: "top",
    RIGHT: "right",
    BOTTOM: "bottom",
    LEFT: "left"
  },
      Le = {
    animation: !0,
    template: '<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: "hover focus",
    title: "",
    delay: 0,
    html: !1,
    selector: !1,
    placement: "top",
    offset: 0,
    container: !1,
    fallbackPlacement: "flip",
    boundary: "scrollParent",
    sanitize: !0,
    sanitizeFn: null,
    whiteList: Ee
  },
      je = "show",
      He = "out",
      Re = {
    HIDE: "hide" + De,
    HIDDEN: "hidden" + De,
    SHOW: "show" + De,
    SHOWN: "shown" + De,
    INSERTED: "inserted" + De,
    CLICK: "click" + De,
    FOCUSIN: "focusin" + De,
    FOCUSOUT: "focusout" + De,
    MOUSEENTER: "mouseenter" + De,
    MOUSELEAVE: "mouseleave" + De
  },
      xe = "fade",
      Fe = "show",
      Ue = ".tooltip-inner",
      We = ".arrow",
      qe = "hover",
      Me = "focus",
      Ke = "click",
      Qe = "manual",
      Be = function () {
    function i(t, e) {
      if ("undefined" == typeof u) throw new TypeError("Bootstrap's tooltips require Popper.js (https://popper.js.org/)");
      this._isEnabled = !0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this.element = t, this.config = this._getConfig(e), this.tip = null, this._setListeners();
    }

    var t = i.prototype;
    return t.enable = function () {
      this._isEnabled = !0;
    }, t.disable = function () {
      this._isEnabled = !1;
    }, t.toggleEnabled = function () {
      this._isEnabled = !this._isEnabled;
    }, t.toggle = function (t) {
      if (this._isEnabled) if (t) {
        var e = this.constructor.DATA_KEY,
            n = g(t.currentTarget).data(e);
        n || (n = new this.constructor(t.currentTarget, this._getDelegateConfig()), g(t.currentTarget).data(e, n)), n._activeTrigger.click = !n._activeTrigger.click, n._isWithActiveTrigger() ? n._enter(null, n) : n._leave(null, n);
      } else {
        if (g(this.getTipElement()).hasClass(Fe)) return void this._leave(null, this);

        this._enter(null, this);
      }
    }, t.dispose = function () {
      clearTimeout(this._timeout), g.removeData(this.element, this.constructor.DATA_KEY), g(this.element).off(this.constructor.EVENT_KEY), g(this.element).closest(".modal").off("hide.bs.modal"), this.tip && g(this.tip).remove(), this._isEnabled = null, this._timeout = null, this._hoverState = null, (this._activeTrigger = null) !== this._popper && this._popper.destroy(), this._popper = null, this.element = null, this.config = null, this.tip = null;
    }, t.show = function () {
      var e = this;
      if ("none" === g(this.element).css("display")) throw new Error("Please use show on visible elements");
      var t = g.Event(this.constructor.Event.SHOW);

      if (this.isWithContent() && this._isEnabled) {
        g(this.element).trigger(t);

        var n = _.findShadowRoot(this.element),
            i = g.contains(null !== n ? n : this.element.ownerDocument.documentElement, this.element);

        if (t.isDefaultPrevented() || !i) return;

        var o = this.getTipElement(),
            r = _.getUID(this.constructor.NAME);

        o.setAttribute("id", r), this.element.setAttribute("aria-describedby", r), this.setContent(), this.config.animation && g(o).addClass(xe);

        var s = "function" == typeof this.config.placement ? this.config.placement.call(this, o, this.element) : this.config.placement,
            a = this._getAttachment(s);

        this.addAttachmentClass(a);

        var l = this._getContainer();

        g(o).data(this.constructor.DATA_KEY, this), g.contains(this.element.ownerDocument.documentElement, this.tip) || g(o).appendTo(l), g(this.element).trigger(this.constructor.Event.INSERTED), this._popper = new u(this.element, o, {
          placement: a,
          modifiers: {
            offset: this._getOffset(),
            flip: {
              behavior: this.config.fallbackPlacement
            },
            arrow: {
              element: We
            },
            preventOverflow: {
              boundariesElement: this.config.boundary
            }
          },
          onCreate: function onCreate(t) {
            t.originalPlacement !== t.placement && e._handlePopperPlacementChange(t);
          },
          onUpdate: function onUpdate(t) {
            return e._handlePopperPlacementChange(t);
          }
        }), g(o).addClass(Fe), "ontouchstart" in document.documentElement && g(document.body).children().on("mouseover", null, g.noop);

        var c = function c() {
          e.config.animation && e._fixTransition();
          var t = e._hoverState;
          e._hoverState = null, g(e.element).trigger(e.constructor.Event.SHOWN), t === He && e._leave(null, e);
        };

        if (g(this.tip).hasClass(xe)) {
          var h = _.getTransitionDurationFromElement(this.tip);

          g(this.tip).one(_.TRANSITION_END, c).emulateTransitionEnd(h);
        } else c();
      }
    }, t.hide = function (t) {
      var e = this,
          n = this.getTipElement(),
          i = g.Event(this.constructor.Event.HIDE),
          o = function o() {
        e._hoverState !== je && n.parentNode && n.parentNode.removeChild(n), e._cleanTipClass(), e.element.removeAttribute("aria-describedby"), g(e.element).trigger(e.constructor.Event.HIDDEN), null !== e._popper && e._popper.destroy(), t && t();
      };

      if (g(this.element).trigger(i), !i.isDefaultPrevented()) {
        if (g(n).removeClass(Fe), "ontouchstart" in document.documentElement && g(document.body).children().off("mouseover", null, g.noop), this._activeTrigger[Ke] = !1, this._activeTrigger[Me] = !1, this._activeTrigger[qe] = !1, g(this.tip).hasClass(xe)) {
          var r = _.getTransitionDurationFromElement(n);

          g(n).one(_.TRANSITION_END, o).emulateTransitionEnd(r);
        } else o();

        this._hoverState = "";
      }
    }, t.update = function () {
      null !== this._popper && this._popper.scheduleUpdate();
    }, t.isWithContent = function () {
      return Boolean(this.getTitle());
    }, t.addAttachmentClass = function (t) {
      g(this.getTipElement()).addClass(Ae + "-" + t);
    }, t.getTipElement = function () {
      return this.tip = this.tip || g(this.config.template)[0], this.tip;
    }, t.setContent = function () {
      var t = this.getTipElement();
      this.setElementContent(g(t.querySelectorAll(Ue)), this.getTitle()), g(t).removeClass(xe + " " + Fe);
    }, t.setElementContent = function (t, e) {
      "object" != _typeof(e) || !e.nodeType && !e.jquery ? this.config.html ? (this.config.sanitize && (e = Se(e, this.config.whiteList, this.config.sanitizeFn)), t.html(e)) : t.text(e) : this.config.html ? g(e).parent().is(t) || t.empty().append(e) : t.text(g(e).text());
    }, t.getTitle = function () {
      var t = this.element.getAttribute("data-original-title");
      return t || (t = "function" == typeof this.config.title ? this.config.title.call(this.element) : this.config.title), t;
    }, t._getOffset = function () {
      var e = this,
          t = {};
      return "function" == typeof this.config.offset ? t.fn = function (t) {
        return t.offsets = l({}, t.offsets, e.config.offset(t.offsets, e.element) || {}), t;
      } : t.offset = this.config.offset, t;
    }, t._getContainer = function () {
      return !1 === this.config.container ? document.body : _.isElement(this.config.container) ? g(this.config.container) : g(document).find(this.config.container);
    }, t._getAttachment = function (t) {
      return Pe[t.toUpperCase()];
    }, t._setListeners = function () {
      var i = this;
      this.config.trigger.split(" ").forEach(function (t) {
        if ("click" === t) g(i.element).on(i.constructor.Event.CLICK, i.config.selector, function (t) {
          return i.toggle(t);
        });else if (t !== Qe) {
          var e = t === qe ? i.constructor.Event.MOUSEENTER : i.constructor.Event.FOCUSIN,
              n = t === qe ? i.constructor.Event.MOUSELEAVE : i.constructor.Event.FOCUSOUT;
          g(i.element).on(e, i.config.selector, function (t) {
            return i._enter(t);
          }).on(n, i.config.selector, function (t) {
            return i._leave(t);
          });
        }
      }), g(this.element).closest(".modal").on("hide.bs.modal", function () {
        i.element && i.hide();
      }), this.config.selector ? this.config = l({}, this.config, {
        trigger: "manual",
        selector: ""
      }) : this._fixTitle();
    }, t._fixTitle = function () {
      var t = _typeof(this.element.getAttribute("data-original-title"));

      (this.element.getAttribute("title") || "string" !== t) && (this.element.setAttribute("data-original-title", this.element.getAttribute("title") || ""), this.element.setAttribute("title", ""));
    }, t._enter = function (t, e) {
      var n = this.constructor.DATA_KEY;
      (e = e || g(t.currentTarget).data(n)) || (e = new this.constructor(t.currentTarget, this._getDelegateConfig()), g(t.currentTarget).data(n, e)), t && (e._activeTrigger["focusin" === t.type ? Me : qe] = !0), g(e.getTipElement()).hasClass(Fe) || e._hoverState === je ? e._hoverState = je : (clearTimeout(e._timeout), e._hoverState = je, e.config.delay && e.config.delay.show ? e._timeout = setTimeout(function () {
        e._hoverState === je && e.show();
      }, e.config.delay.show) : e.show());
    }, t._leave = function (t, e) {
      var n = this.constructor.DATA_KEY;
      (e = e || g(t.currentTarget).data(n)) || (e = new this.constructor(t.currentTarget, this._getDelegateConfig()), g(t.currentTarget).data(n, e)), t && (e._activeTrigger["focusout" === t.type ? Me : qe] = !1), e._isWithActiveTrigger() || (clearTimeout(e._timeout), e._hoverState = He, e.config.delay && e.config.delay.hide ? e._timeout = setTimeout(function () {
        e._hoverState === He && e.hide();
      }, e.config.delay.hide) : e.hide());
    }, t._isWithActiveTrigger = function () {
      for (var t in this._activeTrigger) {
        if (this._activeTrigger[t]) return !0;
      }

      return !1;
    }, t._getConfig = function (t) {
      var e = g(this.element).data();
      return Object.keys(e).forEach(function (t) {
        -1 !== Oe.indexOf(t) && delete e[t];
      }), "number" == typeof (t = l({}, this.constructor.Default, e, "object" == _typeof(t) && t ? t : {})).delay && (t.delay = {
        show: t.delay,
        hide: t.delay
      }), "number" == typeof t.title && (t.title = t.title.toString()), "number" == typeof t.content && (t.content = t.content.toString()), _.typeCheckConfig(be, t, this.constructor.DefaultType), t.sanitize && (t.template = Se(t.template, t.whiteList, t.sanitizeFn)), t;
    }, t._getDelegateConfig = function () {
      var t = {};
      if (this.config) for (var e in this.config) {
        this.constructor.Default[e] !== this.config[e] && (t[e] = this.config[e]);
      }
      return t;
    }, t._cleanTipClass = function () {
      var t = g(this.getTipElement()),
          e = t.attr("class").match(Ne);
      null !== e && e.length && t.removeClass(e.join(""));
    }, t._handlePopperPlacementChange = function (t) {
      var e = t.instance;
      this.tip = e.popper, this._cleanTipClass(), this.addAttachmentClass(this._getAttachment(t.placement));
    }, t._fixTransition = function () {
      var t = this.getTipElement(),
          e = this.config.animation;
      null === t.getAttribute("x-placement") && (g(t).removeClass(xe), this.config.animation = !1, this.hide(), this.show(), this.config.animation = e);
    }, i._jQueryInterface = function (n) {
      return this.each(function () {
        var t = g(this).data(Ie),
            e = "object" == _typeof(n) && n;

        if ((t || !/dispose|hide/.test(n)) && (t || (t = new i(this, e), g(this).data(Ie, t)), "string" == typeof n)) {
          if ("undefined" == typeof t[n]) throw new TypeError('No method named "' + n + '"');
          t[n]();
        }
      });
    }, s(i, null, [{
      key: "VERSION",
      get: function get() {
        return "4.3.1";
      }
    }, {
      key: "Default",
      get: function get() {
        return Le;
      }
    }, {
      key: "NAME",
      get: function get() {
        return be;
      }
    }, {
      key: "DATA_KEY",
      get: function get() {
        return Ie;
      }
    }, {
      key: "Event",
      get: function get() {
        return Re;
      }
    }, {
      key: "EVENT_KEY",
      get: function get() {
        return De;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return ke;
      }
    }]), i;
  }();

  g.fn[be] = Be._jQueryInterface, g.fn[be].Constructor = Be, g.fn[be].noConflict = function () {
    return g.fn[be] = we, Be._jQueryInterface;
  };

  var Ve = "popover",
      Ye = "bs.popover",
      ze = "." + Ye,
      Xe = g.fn[Ve],
      $e = "bs-popover",
      Ge = new RegExp("(^|\\s)" + $e + "\\S+", "g"),
      Je = l({}, Be.Default, {
    placement: "right",
    trigger: "click",
    content: "",
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
  }),
      Ze = l({}, Be.DefaultType, {
    content: "(string|element|function)"
  }),
      tn = "fade",
      en = "show",
      nn = ".popover-header",
      on = ".popover-body",
      rn = {
    HIDE: "hide" + ze,
    HIDDEN: "hidden" + ze,
    SHOW: "show" + ze,
    SHOWN: "shown" + ze,
    INSERTED: "inserted" + ze,
    CLICK: "click" + ze,
    FOCUSIN: "focusin" + ze,
    FOCUSOUT: "focusout" + ze,
    MOUSEENTER: "mouseenter" + ze,
    MOUSELEAVE: "mouseleave" + ze
  },
      sn = function (t) {
    var e, n;

    function i() {
      return t.apply(this, arguments) || this;
    }

    n = t, (e = i).prototype = Object.create(n.prototype), (e.prototype.constructor = e).__proto__ = n;
    var o = i.prototype;
    return o.isWithContent = function () {
      return this.getTitle() || this._getContent();
    }, o.addAttachmentClass = function (t) {
      g(this.getTipElement()).addClass($e + "-" + t);
    }, o.getTipElement = function () {
      return this.tip = this.tip || g(this.config.template)[0], this.tip;
    }, o.setContent = function () {
      var t = g(this.getTipElement());
      this.setElementContent(t.find(nn), this.getTitle());

      var e = this._getContent();

      "function" == typeof e && (e = e.call(this.element)), this.setElementContent(t.find(on), e), t.removeClass(tn + " " + en);
    }, o._getContent = function () {
      return this.element.getAttribute("data-content") || this.config.content;
    }, o._cleanTipClass = function () {
      var t = g(this.getTipElement()),
          e = t.attr("class").match(Ge);
      null !== e && 0 < e.length && t.removeClass(e.join(""));
    }, i._jQueryInterface = function (n) {
      return this.each(function () {
        var t = g(this).data(Ye),
            e = "object" == _typeof(n) ? n : null;

        if ((t || !/dispose|hide/.test(n)) && (t || (t = new i(this, e), g(this).data(Ye, t)), "string" == typeof n)) {
          if ("undefined" == typeof t[n]) throw new TypeError('No method named "' + n + '"');
          t[n]();
        }
      });
    }, s(i, null, [{
      key: "VERSION",
      get: function get() {
        return "4.3.1";
      }
    }, {
      key: "Default",
      get: function get() {
        return Je;
      }
    }, {
      key: "NAME",
      get: function get() {
        return Ve;
      }
    }, {
      key: "DATA_KEY",
      get: function get() {
        return Ye;
      }
    }, {
      key: "Event",
      get: function get() {
        return rn;
      }
    }, {
      key: "EVENT_KEY",
      get: function get() {
        return ze;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return Ze;
      }
    }]), i;
  }(Be);

  g.fn[Ve] = sn._jQueryInterface, g.fn[Ve].Constructor = sn, g.fn[Ve].noConflict = function () {
    return g.fn[Ve] = Xe, sn._jQueryInterface;
  };

  var an = "scrollspy",
      ln = "bs.scrollspy",
      cn = "." + ln,
      hn = g.fn[an],
      un = {
    offset: 10,
    method: "auto",
    target: ""
  },
      fn = {
    offset: "number",
    method: "string",
    target: "(string|element)"
  },
      dn = {
    ACTIVATE: "activate" + cn,
    SCROLL: "scroll" + cn,
    LOAD_DATA_API: "load" + cn + ".data-api"
  },
      gn = "dropdown-item",
      _n = "active",
      mn = '[data-spy="scroll"]',
      pn = ".nav, .list-group",
      vn = ".nav-link",
      yn = ".nav-item",
      En = ".list-group-item",
      Cn = ".dropdown",
      Tn = ".dropdown-item",
      Sn = ".dropdown-toggle",
      bn = "offset",
      In = "position",
      Dn = function () {
    function n(t, e) {
      var n = this;
      this._element = t, this._scrollElement = "BODY" === t.tagName ? window : t, this._config = this._getConfig(e), this._selector = this._config.target + " " + vn + "," + this._config.target + " " + En + "," + this._config.target + " " + Tn, this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, g(this._scrollElement).on(dn.SCROLL, function (t) {
        return n._process(t);
      }), this.refresh(), this._process();
    }

    var t = n.prototype;
    return t.refresh = function () {
      var e = this,
          t = this._scrollElement === this._scrollElement.window ? bn : In,
          o = "auto" === this._config.method ? t : this._config.method,
          r = o === In ? this._getScrollTop() : 0;
      this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), [].slice.call(document.querySelectorAll(this._selector)).map(function (t) {
        var e,
            n = _.getSelectorFromElement(t);

        if (n && (e = document.querySelector(n)), e) {
          var i = e.getBoundingClientRect();
          if (i.width || i.height) return [g(e)[o]().top + r, n];
        }

        return null;
      }).filter(function (t) {
        return t;
      }).sort(function (t, e) {
        return t[0] - e[0];
      }).forEach(function (t) {
        e._offsets.push(t[0]), e._targets.push(t[1]);
      });
    }, t.dispose = function () {
      g.removeData(this._element, ln), g(this._scrollElement).off(cn), this._element = null, this._scrollElement = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null;
    }, t._getConfig = function (t) {
      if ("string" != typeof (t = l({}, un, "object" == _typeof(t) && t ? t : {})).target) {
        var e = g(t.target).attr("id");
        e || (e = _.getUID(an), g(t.target).attr("id", e)), t.target = "#" + e;
      }

      return _.typeCheckConfig(an, t, fn), t;
    }, t._getScrollTop = function () {
      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
    }, t._getScrollHeight = function () {
      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
    }, t._getOffsetHeight = function () {
      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
    }, t._process = function () {
      var t = this._getScrollTop() + this._config.offset,
          e = this._getScrollHeight(),
          n = this._config.offset + e - this._getOffsetHeight();

      if (this._scrollHeight !== e && this.refresh(), n <= t) {
        var i = this._targets[this._targets.length - 1];
        this._activeTarget !== i && this._activate(i);
      } else {
        if (this._activeTarget && t < this._offsets[0] && 0 < this._offsets[0]) return this._activeTarget = null, void this._clear();

        for (var o = this._offsets.length; o--;) {
          this._activeTarget !== this._targets[o] && t >= this._offsets[o] && ("undefined" == typeof this._offsets[o + 1] || t < this._offsets[o + 1]) && this._activate(this._targets[o]);
        }
      }
    }, t._activate = function (e) {
      this._activeTarget = e, this._clear();

      var t = this._selector.split(",").map(function (t) {
        return t + '[data-target="' + e + '"],' + t + '[href="' + e + '"]';
      }),
          n = g([].slice.call(document.querySelectorAll(t.join(","))));

      n.hasClass(gn) ? (n.closest(Cn).find(Sn).addClass(_n), n.addClass(_n)) : (n.addClass(_n), n.parents(pn).prev(vn + ", " + En).addClass(_n), n.parents(pn).prev(yn).children(vn).addClass(_n)), g(this._scrollElement).trigger(dn.ACTIVATE, {
        relatedTarget: e
      });
    }, t._clear = function () {
      [].slice.call(document.querySelectorAll(this._selector)).filter(function (t) {
        return t.classList.contains(_n);
      }).forEach(function (t) {
        return t.classList.remove(_n);
      });
    }, n._jQueryInterface = function (e) {
      return this.each(function () {
        var t = g(this).data(ln);

        if (t || (t = new n(this, "object" == _typeof(e) && e), g(this).data(ln, t)), "string" == typeof e) {
          if ("undefined" == typeof t[e]) throw new TypeError('No method named "' + e + '"');
          t[e]();
        }
      });
    }, s(n, null, [{
      key: "VERSION",
      get: function get() {
        return "4.3.1";
      }
    }, {
      key: "Default",
      get: function get() {
        return un;
      }
    }]), n;
  }();

  g(window).on(dn.LOAD_DATA_API, function () {
    for (var t = [].slice.call(document.querySelectorAll(mn)), e = t.length; e--;) {
      var n = g(t[e]);

      Dn._jQueryInterface.call(n, n.data());
    }
  }), g.fn[an] = Dn._jQueryInterface, g.fn[an].Constructor = Dn, g.fn[an].noConflict = function () {
    return g.fn[an] = hn, Dn._jQueryInterface;
  };

  var wn = "bs.tab",
      An = "." + wn,
      Nn = g.fn.tab,
      On = {
    HIDE: "hide" + An,
    HIDDEN: "hidden" + An,
    SHOW: "show" + An,
    SHOWN: "shown" + An,
    CLICK_DATA_API: "click" + An + ".data-api"
  },
      kn = "dropdown-menu",
      Pn = "active",
      Ln = "disabled",
      jn = "fade",
      Hn = "show",
      Rn = ".dropdown",
      xn = ".nav, .list-group",
      Fn = ".active",
      Un = "> li > .active",
      Wn = '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',
      qn = ".dropdown-toggle",
      Mn = "> .dropdown-menu .active",
      Kn = function () {
    function i(t) {
      this._element = t;
    }

    var t = i.prototype;
    return t.show = function () {
      var n = this;

      if (!(this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && g(this._element).hasClass(Pn) || g(this._element).hasClass(Ln))) {
        var t,
            i,
            e = g(this._element).closest(xn)[0],
            o = _.getSelectorFromElement(this._element);

        if (e) {
          var r = "UL" === e.nodeName || "OL" === e.nodeName ? Un : Fn;
          i = (i = g.makeArray(g(e).find(r)))[i.length - 1];
        }

        var s = g.Event(On.HIDE, {
          relatedTarget: this._element
        }),
            a = g.Event(On.SHOW, {
          relatedTarget: i
        });

        if (i && g(i).trigger(s), g(this._element).trigger(a), !a.isDefaultPrevented() && !s.isDefaultPrevented()) {
          o && (t = document.querySelector(o)), this._activate(this._element, e);

          var l = function l() {
            var t = g.Event(On.HIDDEN, {
              relatedTarget: n._element
            }),
                e = g.Event(On.SHOWN, {
              relatedTarget: i
            });
            g(i).trigger(t), g(n._element).trigger(e);
          };

          t ? this._activate(t, t.parentNode, l) : l();
        }
      }
    }, t.dispose = function () {
      g.removeData(this._element, wn), this._element = null;
    }, t._activate = function (t, e, n) {
      var i = this,
          o = (!e || "UL" !== e.nodeName && "OL" !== e.nodeName ? g(e).children(Fn) : g(e).find(Un))[0],
          r = n && o && g(o).hasClass(jn),
          s = function s() {
        return i._transitionComplete(t, o, n);
      };

      if (o && r) {
        var a = _.getTransitionDurationFromElement(o);

        g(o).removeClass(Hn).one(_.TRANSITION_END, s).emulateTransitionEnd(a);
      } else s();
    }, t._transitionComplete = function (t, e, n) {
      if (e) {
        g(e).removeClass(Pn);
        var i = g(e.parentNode).find(Mn)[0];
        i && g(i).removeClass(Pn), "tab" === e.getAttribute("role") && e.setAttribute("aria-selected", !1);
      }

      if (g(t).addClass(Pn), "tab" === t.getAttribute("role") && t.setAttribute("aria-selected", !0), _.reflow(t), t.classList.contains(jn) && t.classList.add(Hn), t.parentNode && g(t.parentNode).hasClass(kn)) {
        var o = g(t).closest(Rn)[0];

        if (o) {
          var r = [].slice.call(o.querySelectorAll(qn));
          g(r).addClass(Pn);
        }

        t.setAttribute("aria-expanded", !0);
      }

      n && n();
    }, i._jQueryInterface = function (n) {
      return this.each(function () {
        var t = g(this),
            e = t.data(wn);

        if (e || (e = new i(this), t.data(wn, e)), "string" == typeof n) {
          if ("undefined" == typeof e[n]) throw new TypeError('No method named "' + n + '"');
          e[n]();
        }
      });
    }, s(i, null, [{
      key: "VERSION",
      get: function get() {
        return "4.3.1";
      }
    }]), i;
  }();

  g(document).on(On.CLICK_DATA_API, Wn, function (t) {
    t.preventDefault(), Kn._jQueryInterface.call(g(this), "show");
  }), g.fn.tab = Kn._jQueryInterface, g.fn.tab.Constructor = Kn, g.fn.tab.noConflict = function () {
    return g.fn.tab = Nn, Kn._jQueryInterface;
  };

  var Qn = "toast",
      Bn = "bs.toast",
      Vn = "." + Bn,
      Yn = g.fn[Qn],
      zn = {
    CLICK_DISMISS: "click.dismiss" + Vn,
    HIDE: "hide" + Vn,
    HIDDEN: "hidden" + Vn,
    SHOW: "show" + Vn,
    SHOWN: "shown" + Vn
  },
      Xn = "fade",
      $n = "hide",
      Gn = "show",
      Jn = "showing",
      Zn = {
    animation: "boolean",
    autohide: "boolean",
    delay: "number"
  },
      ti = {
    animation: !0,
    autohide: !0,
    delay: 500
  },
      ei = '[data-dismiss="toast"]',
      ni = function () {
    function i(t, e) {
      this._element = t, this._config = this._getConfig(e), this._timeout = null, this._setListeners();
    }

    var t = i.prototype;
    return t.show = function () {
      var t = this;
      g(this._element).trigger(zn.SHOW), this._config.animation && this._element.classList.add(Xn);

      var e = function e() {
        t._element.classList.remove(Jn), t._element.classList.add(Gn), g(t._element).trigger(zn.SHOWN), t._config.autohide && t.hide();
      };

      if (this._element.classList.remove($n), this._element.classList.add(Jn), this._config.animation) {
        var n = _.getTransitionDurationFromElement(this._element);

        g(this._element).one(_.TRANSITION_END, e).emulateTransitionEnd(n);
      } else e();
    }, t.hide = function (t) {
      var e = this;
      this._element.classList.contains(Gn) && (g(this._element).trigger(zn.HIDE), t ? this._close() : this._timeout = setTimeout(function () {
        e._close();
      }, this._config.delay));
    }, t.dispose = function () {
      clearTimeout(this._timeout), this._timeout = null, this._element.classList.contains(Gn) && this._element.classList.remove(Gn), g(this._element).off(zn.CLICK_DISMISS), g.removeData(this._element, Bn), this._element = null, this._config = null;
    }, t._getConfig = function (t) {
      return t = l({}, ti, g(this._element).data(), "object" == _typeof(t) && t ? t : {}), _.typeCheckConfig(Qn, t, this.constructor.DefaultType), t;
    }, t._setListeners = function () {
      var t = this;
      g(this._element).on(zn.CLICK_DISMISS, ei, function () {
        return t.hide(!0);
      });
    }, t._close = function () {
      var t = this,
          e = function e() {
        t._element.classList.add($n), g(t._element).trigger(zn.HIDDEN);
      };

      if (this._element.classList.remove(Gn), this._config.animation) {
        var n = _.getTransitionDurationFromElement(this._element);

        g(this._element).one(_.TRANSITION_END, e).emulateTransitionEnd(n);
      } else e();
    }, i._jQueryInterface = function (n) {
      return this.each(function () {
        var t = g(this),
            e = t.data(Bn);

        if (e || (e = new i(this, "object" == _typeof(n) && n), t.data(Bn, e)), "string" == typeof n) {
          if ("undefined" == typeof e[n]) throw new TypeError('No method named "' + n + '"');
          e[n](this);
        }
      });
    }, s(i, null, [{
      key: "VERSION",
      get: function get() {
        return "4.3.1";
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return Zn;
      }
    }, {
      key: "Default",
      get: function get() {
        return ti;
      }
    }]), i;
  }();

  g.fn[Qn] = ni._jQueryInterface, g.fn[Qn].Constructor = ni, g.fn[Qn].noConflict = function () {
    return g.fn[Qn] = Yn, ni._jQueryInterface;
  }, function () {
    if ("undefined" == typeof g) throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript.");
    var t = g.fn.jquery.split(" ")[0].split(".");
    if (t[0] < 2 && t[1] < 9 || 1 === t[0] && 9 === t[1] && t[2] < 1 || 4 <= t[0]) throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0");
  }(), t.Util = _, t.Alert = p, t.Button = P, t.Carousel = lt, t.Collapse = bt, t.Dropdown = Jt, t.Modal = ve, t.Popover = sn, t.Scrollspy = Dn, t.Tab = Kn, t.Toast = ni, t.Tooltip = Be, Object.defineProperty(t, "__esModule", {
    value: !0
  });
});
/*!
 * perfect-scrollbar v1.4.0
 * (c) 2018 Hyunje Jun
 * @license MIT
 */

!function (t, e) {
  "object" == ( false ? undefined : _typeof(exports)) && "undefined" != typeof module ? module.exports = e() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (e),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
}(this, function () {
  "use strict";

  function t(t) {
    return getComputedStyle(t);
  }

  function e(t, e) {
    for (var i in e) {
      var r = e[i];
      "number" == typeof r && (r += "px"), t.style[i] = r;
    }

    return t;
  }

  function i(t) {
    var e = document.createElement("div");
    return e.className = t, e;
  }

  function r(t, e) {
    if (!v) throw new Error("No element matching method supported");
    return v.call(t, e);
  }

  function l(t) {
    t.remove ? t.remove() : t.parentNode && t.parentNode.removeChild(t);
  }

  function n(t, e) {
    return Array.prototype.filter.call(t.children, function (t) {
      return r(t, e);
    });
  }

  function o(t, e) {
    var i = t.element.classList,
        r = m.state.scrolling(e);
    i.contains(r) ? clearTimeout(Y[e]) : i.add(r);
  }

  function s(t, e) {
    Y[e] = setTimeout(function () {
      return t.isAlive && t.element.classList.remove(m.state.scrolling(e));
    }, t.settings.scrollingThreshold);
  }

  function a(t, e) {
    o(t, e), s(t, e);
  }

  function c(t) {
    if ("function" == typeof window.CustomEvent) return new CustomEvent(t);
    var e = document.createEvent("CustomEvent");
    return e.initCustomEvent(t, !1, !1, void 0), e;
  }

  function h(t, e, i, r, l) {
    var n = i[0],
        o = i[1],
        s = i[2],
        h = i[3],
        u = i[4],
        d = i[5];
    void 0 === r && (r = !0), void 0 === l && (l = !1);
    var f = t.element;
    t.reach[h] = null, f[s] < 1 && (t.reach[h] = "start"), f[s] > t[n] - t[o] - 1 && (t.reach[h] = "end"), e && (f.dispatchEvent(c("ps-scroll-" + h)), e < 0 ? f.dispatchEvent(c("ps-scroll-" + u)) : e > 0 && f.dispatchEvent(c("ps-scroll-" + d)), r && a(t, h)), t.reach[h] && (e || l) && f.dispatchEvent(c("ps-" + h + "-reach-" + t.reach[h]));
  }

  function u(t) {
    return parseInt(t, 10) || 0;
  }

  function d(t) {
    return r(t, "input,[contenteditable]") || r(t, "select,[contenteditable]") || r(t, "textarea,[contenteditable]") || r(t, "button,[contenteditable]");
  }

  function f(e) {
    var i = t(e);
    return u(i.width) + u(i.paddingLeft) + u(i.paddingRight) + u(i.borderLeftWidth) + u(i.borderRightWidth);
  }

  function p(t, e) {
    return t.settings.minScrollbarLength && (e = Math.max(e, t.settings.minScrollbarLength)), t.settings.maxScrollbarLength && (e = Math.min(e, t.settings.maxScrollbarLength)), e;
  }

  function b(t, i) {
    var r = {
      width: i.railXWidth
    },
        l = Math.floor(t.scrollTop);
    i.isRtl ? r.left = i.negativeScrollAdjustment + t.scrollLeft + i.containerWidth - i.contentWidth : r.left = t.scrollLeft, i.isScrollbarXUsingBottom ? r.bottom = i.scrollbarXBottom - l : r.top = i.scrollbarXTop + l, e(i.scrollbarXRail, r);
    var n = {
      top: l,
      height: i.railYHeight
    };
    i.isScrollbarYUsingRight ? i.isRtl ? n.right = i.contentWidth - (i.negativeScrollAdjustment + t.scrollLeft) - i.scrollbarYRight - i.scrollbarYOuterWidth : n.right = i.scrollbarYRight - t.scrollLeft : i.isRtl ? n.left = i.negativeScrollAdjustment + t.scrollLeft + 2 * i.containerWidth - i.contentWidth - i.scrollbarYLeft - i.scrollbarYOuterWidth : n.left = i.scrollbarYLeft + t.scrollLeft, e(i.scrollbarYRail, n), e(i.scrollbarX, {
      left: i.scrollbarXLeft,
      width: i.scrollbarXWidth - i.railBorderXWidth
    }), e(i.scrollbarY, {
      top: i.scrollbarYTop,
      height: i.scrollbarYHeight - i.railBorderYWidth
    });
  }

  function g(t, e) {
    function i(e) {
      b[d] = g + Y * (e[a] - v), o(t, f), R(t), e.stopPropagation(), e.preventDefault();
    }

    function r() {
      s(t, f), t[p].classList.remove(m.state.clicking), t.event.unbind(t.ownerDocument, "mousemove", i);
    }

    var l = e[0],
        n = e[1],
        a = e[2],
        c = e[3],
        h = e[4],
        u = e[5],
        d = e[6],
        f = e[7],
        p = e[8],
        b = t.element,
        g = null,
        v = null,
        Y = null;
    t.event.bind(t[h], "mousedown", function (e) {
      g = b[d], v = e[a], Y = (t[n] - t[l]) / (t[c] - t[u]), t.event.bind(t.ownerDocument, "mousemove", i), t.event.once(t.ownerDocument, "mouseup", r), t[p].classList.add(m.state.clicking), e.stopPropagation(), e.preventDefault();
    });
  }

  var v = "undefined" != typeof Element && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector),
      m = {
    main: "ps",
    element: {
      thumb: function thumb(t) {
        return "ps__thumb-" + t;
      },
      rail: function rail(t) {
        return "ps__rail-" + t;
      },
      consuming: "ps__child--consume"
    },
    state: {
      focus: "ps--focus",
      clicking: "ps--clicking",
      active: function active(t) {
        return "ps--active-" + t;
      },
      scrolling: function scrolling(t) {
        return "ps--scrolling-" + t;
      }
    }
  },
      Y = {
    x: null,
    y: null
  },
      X = function X(t) {
    this.element = t, this.handlers = {};
  },
      w = {
    isEmpty: {
      configurable: !0
    }
  };

  X.prototype.bind = function (t, e) {
    void 0 === this.handlers[t] && (this.handlers[t] = []), this.handlers[t].push(e), this.element.addEventListener(t, e, !1);
  }, X.prototype.unbind = function (t, e) {
    var i = this;
    this.handlers[t] = this.handlers[t].filter(function (r) {
      return !(!e || r === e) || (i.element.removeEventListener(t, r, !1), !1);
    });
  }, X.prototype.unbindAll = function () {
    var t = this;

    for (var e in t.handlers) {
      t.unbind(e);
    }
  }, w.isEmpty.get = function () {
    var t = this;
    return Object.keys(this.handlers).every(function (e) {
      return 0 === t.handlers[e].length;
    });
  }, Object.defineProperties(X.prototype, w);

  var y = function y() {
    this.eventElements = [];
  };

  y.prototype.eventElement = function (t) {
    var e = this.eventElements.filter(function (e) {
      return e.element === t;
    })[0];
    return e || (e = new X(t), this.eventElements.push(e)), e;
  }, y.prototype.bind = function (t, e, i) {
    this.eventElement(t).bind(e, i);
  }, y.prototype.unbind = function (t, e, i) {
    var r = this.eventElement(t);
    r.unbind(e, i), r.isEmpty && this.eventElements.splice(this.eventElements.indexOf(r), 1);
  }, y.prototype.unbindAll = function () {
    this.eventElements.forEach(function (t) {
      return t.unbindAll();
    }), this.eventElements = [];
  }, y.prototype.once = function (t, e, i) {
    var r = this.eventElement(t),
        l = function l(t) {
      r.unbind(e, l), i(t);
    };

    r.bind(e, l);
  };

  var W = function W(t, e, i, r, l) {
    void 0 === r && (r = !0), void 0 === l && (l = !1);
    var n;
    if ("top" === e) n = ["contentHeight", "containerHeight", "scrollTop", "y", "up", "down"];else {
      if ("left" !== e) throw new Error("A proper axis should be provided");
      n = ["contentWidth", "containerWidth", "scrollLeft", "x", "left", "right"];
    }
    h(t, i, n, r, l);
  },
      L = {
    isWebKit: "undefined" != typeof document && "WebkitAppearance" in document.documentElement.style,
    supportsTouch: "undefined" != typeof window && ("ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch),
    supportsIePointer: "undefined" != typeof navigator && navigator.msMaxTouchPoints,
    isChrome: "undefined" != typeof navigator && /Chrome/i.test(navigator && navigator.userAgent)
  },
      R = function R(t) {
    var e = t.element,
        i = Math.floor(e.scrollTop);
    t.containerWidth = e.clientWidth, t.containerHeight = e.clientHeight, t.contentWidth = e.scrollWidth, t.contentHeight = e.scrollHeight, e.contains(t.scrollbarXRail) || (n(e, m.element.rail("x")).forEach(function (t) {
      return l(t);
    }), e.appendChild(t.scrollbarXRail)), e.contains(t.scrollbarYRail) || (n(e, m.element.rail("y")).forEach(function (t) {
      return l(t);
    }), e.appendChild(t.scrollbarYRail)), !t.settings.suppressScrollX && t.containerWidth + t.settings.scrollXMarginOffset < t.contentWidth ? (t.scrollbarXActive = !0, t.railXWidth = t.containerWidth - t.railXMarginWidth, t.railXRatio = t.containerWidth / t.railXWidth, t.scrollbarXWidth = p(t, u(t.railXWidth * t.containerWidth / t.contentWidth)), t.scrollbarXLeft = u((t.negativeScrollAdjustment + e.scrollLeft) * (t.railXWidth - t.scrollbarXWidth) / (t.contentWidth - t.containerWidth))) : t.scrollbarXActive = !1, !t.settings.suppressScrollY && t.containerHeight + t.settings.scrollYMarginOffset < t.contentHeight ? (t.scrollbarYActive = !0, t.railYHeight = t.containerHeight - t.railYMarginHeight, t.railYRatio = t.containerHeight / t.railYHeight, t.scrollbarYHeight = p(t, u(t.railYHeight * t.containerHeight / t.contentHeight)), t.scrollbarYTop = u(i * (t.railYHeight - t.scrollbarYHeight) / (t.contentHeight - t.containerHeight))) : t.scrollbarYActive = !1, t.scrollbarXLeft >= t.railXWidth - t.scrollbarXWidth && (t.scrollbarXLeft = t.railXWidth - t.scrollbarXWidth), t.scrollbarYTop >= t.railYHeight - t.scrollbarYHeight && (t.scrollbarYTop = t.railYHeight - t.scrollbarYHeight), b(e, t), t.scrollbarXActive ? e.classList.add(m.state.active("x")) : (e.classList.remove(m.state.active("x")), t.scrollbarXWidth = 0, t.scrollbarXLeft = 0, e.scrollLeft = 0), t.scrollbarYActive ? e.classList.add(m.state.active("y")) : (e.classList.remove(m.state.active("y")), t.scrollbarYHeight = 0, t.scrollbarYTop = 0, e.scrollTop = 0);
  },
      T = {
    "click-rail": function clickRail(t) {
      t.event.bind(t.scrollbarY, "mousedown", function (t) {
        return t.stopPropagation();
      }), t.event.bind(t.scrollbarYRail, "mousedown", function (e) {
        var i = e.pageY - window.pageYOffset - t.scrollbarYRail.getBoundingClientRect().top > t.scrollbarYTop ? 1 : -1;
        t.element.scrollTop += i * t.containerHeight, R(t), e.stopPropagation();
      }), t.event.bind(t.scrollbarX, "mousedown", function (t) {
        return t.stopPropagation();
      }), t.event.bind(t.scrollbarXRail, "mousedown", function (e) {
        var i = e.pageX - window.pageXOffset - t.scrollbarXRail.getBoundingClientRect().left > t.scrollbarXLeft ? 1 : -1;
        t.element.scrollLeft += i * t.containerWidth, R(t), e.stopPropagation();
      });
    },
    "drag-thumb": function dragThumb(t) {
      g(t, ["containerWidth", "contentWidth", "pageX", "railXWidth", "scrollbarX", "scrollbarXWidth", "scrollLeft", "x", "scrollbarXRail"]), g(t, ["containerHeight", "contentHeight", "pageY", "railYHeight", "scrollbarY", "scrollbarYHeight", "scrollTop", "y", "scrollbarYRail"]);
    },
    keyboard: function keyboard(t) {
      function e(e, r) {
        var l = Math.floor(i.scrollTop);

        if (0 === e) {
          if (!t.scrollbarYActive) return !1;
          if (0 === l && r > 0 || l >= t.contentHeight - t.containerHeight && r < 0) return !t.settings.wheelPropagation;
        }

        var n = i.scrollLeft;

        if (0 === r) {
          if (!t.scrollbarXActive) return !1;
          if (0 === n && e < 0 || n >= t.contentWidth - t.containerWidth && e > 0) return !t.settings.wheelPropagation;
        }

        return !0;
      }

      var i = t.element,
          l = function l() {
        return r(i, ":hover");
      },
          n = function n() {
        return r(t.scrollbarX, ":focus") || r(t.scrollbarY, ":focus");
      };

      t.event.bind(t.ownerDocument, "keydown", function (r) {
        if (!(r.isDefaultPrevented && r.isDefaultPrevented() || r.defaultPrevented) && (l() || n())) {
          var o = document.activeElement ? document.activeElement : t.ownerDocument.activeElement;

          if (o) {
            if ("IFRAME" === o.tagName) o = o.contentDocument.activeElement;else for (; o.shadowRoot;) {
              o = o.shadowRoot.activeElement;
            }
            if (d(o)) return;
          }

          var s = 0,
              a = 0;

          switch (r.which) {
            case 37:
              s = r.metaKey ? -t.contentWidth : r.altKey ? -t.containerWidth : -30;
              break;

            case 38:
              a = r.metaKey ? t.contentHeight : r.altKey ? t.containerHeight : 30;
              break;

            case 39:
              s = r.metaKey ? t.contentWidth : r.altKey ? t.containerWidth : 30;
              break;

            case 40:
              a = r.metaKey ? -t.contentHeight : r.altKey ? -t.containerHeight : -30;
              break;

            case 32:
              a = r.shiftKey ? t.containerHeight : -t.containerHeight;
              break;

            case 33:
              a = t.containerHeight;
              break;

            case 34:
              a = -t.containerHeight;
              break;

            case 36:
              a = t.contentHeight;
              break;

            case 35:
              a = -t.contentHeight;
              break;

            default:
              return;
          }

          t.settings.suppressScrollX && 0 !== s || t.settings.suppressScrollY && 0 !== a || (i.scrollTop -= a, i.scrollLeft += s, R(t), e(s, a) && r.preventDefault());
        }
      });
    },
    wheel: function wheel(e) {
      function i(t, i) {
        var r = Math.floor(o.scrollTop),
            l = 0 === o.scrollTop,
            n = r + o.offsetHeight === o.scrollHeight,
            s = 0 === o.scrollLeft,
            a = o.scrollLeft + o.offsetWidth === o.scrollWidth;
        return !(Math.abs(i) > Math.abs(t) ? l || n : s || a) || !e.settings.wheelPropagation;
      }

      function r(t) {
        var e = t.deltaX,
            i = -1 * t.deltaY;
        return void 0 !== e && void 0 !== i || (e = -1 * t.wheelDeltaX / 6, i = t.wheelDeltaY / 6), t.deltaMode && 1 === t.deltaMode && (e *= 10, i *= 10), e !== e && i !== i && (e = 0, i = t.wheelDelta), t.shiftKey ? [-i, -e] : [e, i];
      }

      function l(e, i, r) {
        if (!L.isWebKit && o.querySelector("select:focus")) return !0;
        if (!o.contains(e)) return !1;

        for (var l = e; l && l !== o;) {
          if (l.classList.contains(m.element.consuming)) return !0;
          var n = t(l);

          if ([n.overflow, n.overflowX, n.overflowY].join("").match(/(scroll|auto)/)) {
            var s = l.scrollHeight - l.clientHeight;
            if (s > 0 && !(0 === l.scrollTop && r > 0 || l.scrollTop === s && r < 0)) return !0;
            var a = l.scrollWidth - l.clientWidth;
            if (a > 0 && !(0 === l.scrollLeft && i < 0 || l.scrollLeft === a && i > 0)) return !0;
          }

          l = l.parentNode;
        }

        return !1;
      }

      function n(t) {
        var n = r(t),
            s = n[0],
            a = n[1];

        if (!l(t.target, s, a)) {
          var c = !1;
          e.settings.useBothWheelAxes ? e.scrollbarYActive && !e.scrollbarXActive ? (a ? o.scrollTop -= a * e.settings.wheelSpeed : o.scrollTop += s * e.settings.wheelSpeed, c = !0) : e.scrollbarXActive && !e.scrollbarYActive && (s ? o.scrollLeft += s * e.settings.wheelSpeed : o.scrollLeft -= a * e.settings.wheelSpeed, c = !0) : (o.scrollTop -= a * e.settings.wheelSpeed, o.scrollLeft += s * e.settings.wheelSpeed), R(e), (c = c || i(s, a)) && !t.ctrlKey && (t.stopPropagation(), t.preventDefault());
        }
      }

      var o = e.element;
      void 0 !== window.onwheel ? e.event.bind(o, "wheel", n) : void 0 !== window.onmousewheel && e.event.bind(o, "mousewheel", n);
    },
    touch: function touch(e) {
      function i(t, i) {
        var r = Math.floor(h.scrollTop),
            l = h.scrollLeft,
            n = Math.abs(t),
            o = Math.abs(i);

        if (o > n) {
          if (i < 0 && r === e.contentHeight - e.containerHeight || i > 0 && 0 === r) return 0 === window.scrollY && i > 0 && L.isChrome;
        } else if (n > o && (t < 0 && l === e.contentWidth - e.containerWidth || t > 0 && 0 === l)) return !0;

        return !0;
      }

      function r(t, i) {
        h.scrollTop -= i, h.scrollLeft -= t, R(e);
      }

      function l(t) {
        return t.targetTouches ? t.targetTouches[0] : t;
      }

      function n(t) {
        return !(t.pointerType && "pen" === t.pointerType && 0 === t.buttons || (!t.targetTouches || 1 !== t.targetTouches.length) && (!t.pointerType || "mouse" === t.pointerType || t.pointerType === t.MSPOINTER_TYPE_MOUSE));
      }

      function o(t) {
        if (n(t)) {
          var e = l(t);
          u.pageX = e.pageX, u.pageY = e.pageY, d = new Date().getTime(), null !== p && clearInterval(p);
        }
      }

      function s(e, i, r) {
        if (!h.contains(e)) return !1;

        for (var l = e; l && l !== h;) {
          if (l.classList.contains(m.element.consuming)) return !0;
          var n = t(l);

          if ([n.overflow, n.overflowX, n.overflowY].join("").match(/(scroll|auto)/)) {
            var o = l.scrollHeight - l.clientHeight;
            if (o > 0 && !(0 === l.scrollTop && r > 0 || l.scrollTop === o && r < 0)) return !0;
            var s = l.scrollLeft - l.clientWidth;
            if (s > 0 && !(0 === l.scrollLeft && i < 0 || l.scrollLeft === s && i > 0)) return !0;
          }

          l = l.parentNode;
        }

        return !1;
      }

      function a(t) {
        if (n(t)) {
          var e = l(t),
              o = {
            pageX: e.pageX,
            pageY: e.pageY
          },
              a = o.pageX - u.pageX,
              c = o.pageY - u.pageY;
          if (s(t.target, a, c)) return;
          r(a, c), u = o;
          var h = new Date().getTime(),
              p = h - d;
          p > 0 && (f.x = a / p, f.y = c / p, d = h), i(a, c) && t.preventDefault();
        }
      }

      function c() {
        e.settings.swipeEasing && (clearInterval(p), p = setInterval(function () {
          e.isInitialized ? clearInterval(p) : f.x || f.y ? Math.abs(f.x) < .01 && Math.abs(f.y) < .01 ? clearInterval(p) : (r(30 * f.x, 30 * f.y), f.x *= .8, f.y *= .8) : clearInterval(p);
        }, 10));
      }

      if (L.supportsTouch || L.supportsIePointer) {
        var h = e.element,
            u = {},
            d = 0,
            f = {},
            p = null;
        L.supportsTouch ? (e.event.bind(h, "touchstart", o), e.event.bind(h, "touchmove", a), e.event.bind(h, "touchend", c)) : L.supportsIePointer && (window.PointerEvent ? (e.event.bind(h, "pointerdown", o), e.event.bind(h, "pointermove", a), e.event.bind(h, "pointerup", c)) : window.MSPointerEvent && (e.event.bind(h, "MSPointerDown", o), e.event.bind(h, "MSPointerMove", a), e.event.bind(h, "MSPointerUp", c)));
      }
    }
  },
      H = function H(r, l) {
    var n = this;
    if (void 0 === l && (l = {}), "string" == typeof r && (r = document.querySelector(r)), !r || !r.nodeName) throw new Error("no element is specified to initialize PerfectScrollbar");
    this.element = r, r.classList.add(m.main), this.settings = {
      handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
      maxScrollbarLength: null,
      minScrollbarLength: null,
      scrollingThreshold: 1e3,
      scrollXMarginOffset: 0,
      scrollYMarginOffset: 0,
      suppressScrollX: !1,
      suppressScrollY: !1,
      swipeEasing: !0,
      useBothWheelAxes: !1,
      wheelPropagation: !0,
      wheelSpeed: 1
    };

    for (var o in l) {
      n.settings[o] = l[o];
    }

    this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null;

    var s = function s() {
      return r.classList.add(m.state.focus);
    },
        a = function a() {
      return r.classList.remove(m.state.focus);
    };

    this.isRtl = "rtl" === t(r).direction, this.isNegativeScroll = function () {
      var t = r.scrollLeft,
          e = null;
      return r.scrollLeft = -1, e = r.scrollLeft < 0, r.scrollLeft = t, e;
    }(), this.negativeScrollAdjustment = this.isNegativeScroll ? r.scrollWidth - r.clientWidth : 0, this.event = new y(), this.ownerDocument = r.ownerDocument || document, this.scrollbarXRail = i(m.element.rail("x")), r.appendChild(this.scrollbarXRail), this.scrollbarX = i(m.element.thumb("x")), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute("tabindex", 0), this.event.bind(this.scrollbarX, "focus", s), this.event.bind(this.scrollbarX, "blur", a), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null;
    var c = t(this.scrollbarXRail);
    this.scrollbarXBottom = parseInt(c.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1, this.scrollbarXTop = u(c.top)) : this.isScrollbarXUsingBottom = !0, this.railBorderXWidth = u(c.borderLeftWidth) + u(c.borderRightWidth), e(this.scrollbarXRail, {
      display: "block"
    }), this.railXMarginWidth = u(c.marginLeft) + u(c.marginRight), e(this.scrollbarXRail, {
      display: ""
    }), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = i(m.element.rail("y")), r.appendChild(this.scrollbarYRail), this.scrollbarY = i(m.element.thumb("y")), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute("tabindex", 0), this.event.bind(this.scrollbarY, "focus", s), this.event.bind(this.scrollbarY, "blur", a), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null;
    var h = t(this.scrollbarYRail);
    this.scrollbarYRight = parseInt(h.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1, this.scrollbarYLeft = u(h.left)) : this.isScrollbarYUsingRight = !0, this.scrollbarYOuterWidth = this.isRtl ? f(this.scrollbarY) : null, this.railBorderYWidth = u(h.borderTopWidth) + u(h.borderBottomWidth), e(this.scrollbarYRail, {
      display: "block"
    }), this.railYMarginHeight = u(h.marginTop) + u(h.marginBottom), e(this.scrollbarYRail, {
      display: ""
    }), this.railYHeight = null, this.railYRatio = null, this.reach = {
      x: r.scrollLeft <= 0 ? "start" : r.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
      y: r.scrollTop <= 0 ? "start" : r.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
    }, this.isAlive = !0, this.settings.handlers.forEach(function (t) {
      return T[t](n);
    }), this.lastScrollTop = Math.floor(r.scrollTop), this.lastScrollLeft = r.scrollLeft, this.event.bind(this.element, "scroll", function (t) {
      return n.onScroll(t);
    }), R(this);
  };

  return H.prototype.update = function () {
    this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, e(this.scrollbarXRail, {
      display: "block"
    }), e(this.scrollbarYRail, {
      display: "block"
    }), this.railXMarginWidth = u(t(this.scrollbarXRail).marginLeft) + u(t(this.scrollbarXRail).marginRight), this.railYMarginHeight = u(t(this.scrollbarYRail).marginTop) + u(t(this.scrollbarYRail).marginBottom), e(this.scrollbarXRail, {
      display: "none"
    }), e(this.scrollbarYRail, {
      display: "none"
    }), R(this), W(this, "top", 0, !1, !0), W(this, "left", 0, !1, !0), e(this.scrollbarXRail, {
      display: ""
    }), e(this.scrollbarYRail, {
      display: ""
    }));
  }, H.prototype.onScroll = function (t) {
    this.isAlive && (R(this), W(this, "top", this.element.scrollTop - this.lastScrollTop), W(this, "left", this.element.scrollLeft - this.lastScrollLeft), this.lastScrollTop = Math.floor(this.element.scrollTop), this.lastScrollLeft = this.element.scrollLeft);
  }, H.prototype.destroy = function () {
    this.isAlive && (this.event.unbindAll(), l(this.scrollbarX), l(this.scrollbarY), l(this.scrollbarXRail), l(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null, this.isAlive = !1);
  }, H.prototype.removePsClasses = function () {
    this.element.className = this.element.className.split(" ").filter(function (t) {
      return !t.match(/^ps([-_].+|)$/);
    }).join(" ");
  }, H;
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./resources/assets/vendors/summernote/summernote-bs4.js":
/*!***************************************************************!*\
  !*** ./resources/assets/vendors/summernote/summernote-bs4.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery, module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof2(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

/*!
 * 
 * Super simple wysiwyg editor v0.8.18
 * https://summernote.org
 * 
 * 
 * Copyright 2013- Alan Hong. and other contributors
 * summernote may be freely distributed under the MIT license.
 * 
 * Date: 2020-05-20T18:09Z
 * 
 */
(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? undefined : _typeof2(exports)) === 'object' && ( false ? undefined : _typeof2(module)) === 'object') module.exports = factory(__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"));else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else { var i, a; }
})(window, function (__WEBPACK_EXTERNAL_MODULE__0__) {
  return (
    /******/
    function (modules) {
      // webpackBootstrap

      /******/
      // The module cache

      /******/
      var installedModules = {};
      /******/

      /******/
      // The require function

      /******/

      function __webpack_require__(moduleId) {
        /******/

        /******/
        // Check if module is in cache

        /******/
        if (installedModules[moduleId]) {
          /******/
          return installedModules[moduleId].exports;
          /******/
        }
        /******/
        // Create a new module (and put it into the cache)

        /******/


        var module = installedModules[moduleId] = {
          /******/
          i: moduleId,

          /******/
          l: false,

          /******/
          exports: {}
          /******/

        };
        /******/

        /******/
        // Execute the module function

        /******/

        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/

        /******/
        // Flag the module as loaded

        /******/

        module.l = true;
        /******/

        /******/
        // Return the exports of the module

        /******/

        return module.exports;
        /******/
      }
      /******/

      /******/

      /******/
      // expose the modules object (__webpack_modules__)

      /******/


      __webpack_require__.m = modules;
      /******/

      /******/
      // expose the module cache

      /******/

      __webpack_require__.c = installedModules;
      /******/

      /******/
      // define getter function for harmony exports

      /******/

      __webpack_require__.d = function (exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
          /******/
          Object.defineProperty(exports, name, {
            enumerable: true,
            get: getter
          });
          /******/
        }
        /******/

      };
      /******/

      /******/
      // define __esModule on exports

      /******/


      __webpack_require__.r = function (exports) {
        /******/
        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
          /******/
          Object.defineProperty(exports, Symbol.toStringTag, {
            value: 'Module'
          });
          /******/
        }
        /******/


        Object.defineProperty(exports, '__esModule', {
          value: true
        });
        /******/
      };
      /******/

      /******/
      // create a fake namespace object

      /******/
      // mode & 1: value is a module id, require it

      /******/
      // mode & 2: merge all properties of value into the ns

      /******/
      // mode & 4: return value when already ns object

      /******/
      // mode & 8|1: behave like require

      /******/


      __webpack_require__.t = function (value, mode) {
        /******/
        if (mode & 1) value = __webpack_require__(value);
        /******/

        if (mode & 8) return value;
        /******/

        if (mode & 4 && _typeof2(value) === 'object' && value && value.__esModule) return value;
        /******/

        var ns = Object.create(null);
        /******/

        __webpack_require__.r(ns);
        /******/


        Object.defineProperty(ns, 'default', {
          enumerable: true,
          value: value
        });
        /******/

        if (mode & 2 && typeof value != 'string') for (var key in value) {
          __webpack_require__.d(ns, key, function (key) {
            return value[key];
          }.bind(null, key));
        }
        /******/

        return ns;
        /******/
      };
      /******/

      /******/
      // getDefaultExport function for compatibility with non-harmony modules

      /******/


      __webpack_require__.n = function (module) {
        /******/
        var getter = module && module.__esModule ?
        /******/
        function getDefault() {
          return module['default'];
        } :
        /******/
        function getModuleExports() {
          return module;
        };
        /******/

        __webpack_require__.d(getter, 'a', getter);
        /******/


        return getter;
        /******/
      };
      /******/

      /******/
      // Object.prototype.hasOwnProperty.call

      /******/


      __webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/

      /******/
      // __webpack_public_path__

      /******/


      __webpack_require__.p = "";
      /******/

      /******/

      /******/
      // Load entry module and return exports

      /******/

      return __webpack_require__(__webpack_require__.s = 53);
      /******/
    }(
    /************************************************************************/

    /******/
    {
      /***/
      0:
      /***/
      function _(module, exports) {
        module.exports = __WEBPACK_EXTERNAL_MODULE__0__;
        /***/
      },

      /***/
      1:
      /***/
      function _(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        /* harmony import */

        var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
        /* harmony import */


        var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);

        function _typeof(obj) {
          "@babel/helpers - typeof";

          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
          }

          return _typeof(obj);
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps);
          if (staticProps) _defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var Renderer = /*#__PURE__*/function () {
          function Renderer(markup, children, options, callback) {
            _classCallCheck(this, Renderer);

            this.markup = markup;
            this.children = children;
            this.options = options;
            this.callback = callback;
          }

          _createClass(Renderer, [{
            key: "render",
            value: function render($parent) {
              var $node = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this.markup);

              if (this.options && this.options.contents) {
                $node.html(this.options.contents);
              }

              if (this.options && this.options.className) {
                $node.addClass(this.options.className);
              }

              if (this.options && this.options.data) {
                jquery__WEBPACK_IMPORTED_MODULE_0___default.a.each(this.options.data, function (k, v) {
                  $node.attr('data-' + k, v);
                });
              }

              if (this.options && this.options.click) {
                $node.on('click', this.options.click);
              }

              if (this.children) {
                var $container = $node.find('.note-children-container');
                this.children.forEach(function (child) {
                  child.render($container.length ? $container : $node);
                });
              }

              if (this.callback) {
                this.callback($node, this.options);
              }

              if (this.options && this.options.callback) {
                this.options.callback($node);
              }

              if ($parent) {
                $parent.append($node);
              }

              return $node;
            }
          }]);

          return Renderer;
        }();
        /* harmony default export */


        __webpack_exports__["a"] = {
          create: function create(markup, callback) {
            return function () {
              var options = _typeof(arguments[1]) === 'object' ? arguments[1] : arguments[0];
              var children = Array.isArray(arguments[0]) ? arguments[0] : [];

              if (options && options.children) {
                children = options.children;
              }

              return new Renderer(markup, children, options, callback);
            };
          }
        };
        /***/
      },

      /***/
      2:
      /***/
      function _(module, exports) {
        /* WEBPACK VAR INJECTION */
        (function (__webpack_amd_options__) {
          /* globals __webpack_amd_options__ */
          module.exports = __webpack_amd_options__;
          /* WEBPACK VAR INJECTION */
        }).call(this, {});
        /***/
      },

      /***/
      3:
      /***/
      function _(module, __webpack_exports__, __webpack_require__) {
        "use strict"; // EXTERNAL MODULE: external {"root":"jQuery","commonjs2":"jquery","commonjs":"jquery","amd":"jquery"}

        var external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_ = __webpack_require__(0);

        var external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default = /*#__PURE__*/__webpack_require__.n(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_); // CONCATENATED MODULE: ./src/js/base/summernote-en-US.js


        external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote || {
          lang: {}
        };
        external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.extend(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.lang, {
          'en-US': {
            font: {
              bold: 'Bold',
              italic: 'Italic',
              underline: 'Underline',
              clear: 'Remove Font Style',
              height: 'Line Height',
              name: 'Font Family',
              strikethrough: 'Strikethrough',
              subscript: 'Subscript',
              superscript: 'Superscript',
              size: 'Font Size',
              sizeunit: 'Font Size Unit'
            },
            image: {
              image: 'Picture',
              insert: 'Insert Image',
              resizeFull: 'Resize full',
              resizeHalf: 'Resize half',
              resizeQuarter: 'Resize quarter',
              resizeNone: 'Original size',
              floatLeft: 'Float Left',
              floatRight: 'Float Right',
              floatNone: 'Remove float',
              shapeRounded: 'Shape: Rounded',
              shapeCircle: 'Shape: Circle',
              shapeThumbnail: 'Shape: Thumbnail',
              shapeNone: 'Shape: None',
              dragImageHere: 'Drag image or text here',
              dropImage: 'Drop image or Text',
              selectFromFiles: 'Select from files',
              maximumFileSize: 'Maximum file size',
              maximumFileSizeError: 'Maximum file size exceeded.',
              url: 'Image URL',
              remove: 'Remove Image',
              original: 'Original'
            },
            video: {
              video: 'Video',
              videoLink: 'Video Link',
              insert: 'Insert Video',
              url: 'Video URL',
              providers: '(YouTube, Vimeo, Vine, Instagram, DailyMotion or Youku)'
            },
            link: {
              link: 'Link',
              insert: 'Insert Link',
              unlink: 'Unlink',
              edit: 'Edit',
              textToDisplay: 'Text to display',
              url: 'To what URL should this link go?',
              openInNewWindow: 'Open in new window',
              useProtocol: 'Use default protocol'
            },
            table: {
              table: 'Table',
              addRowAbove: 'Add row above',
              addRowBelow: 'Add row below',
              addColLeft: 'Add column left',
              addColRight: 'Add column right',
              delRow: 'Delete row',
              delCol: 'Delete column',
              delTable: 'Delete table'
            },
            hr: {
              insert: 'Insert Horizontal Rule'
            },
            style: {
              style: 'Style',
              p: 'Normal',
              blockquote: 'Quote',
              pre: 'Code',
              h1: 'Header 1',
              h2: 'Header 2',
              h3: 'Header 3',
              h4: 'Header 4',
              h5: 'Header 5',
              h6: 'Header 6'
            },
            lists: {
              unordered: 'Unordered list',
              ordered: 'Ordered list'
            },
            options: {
              help: 'Help',
              fullscreen: 'Full Screen',
              codeview: 'Code View'
            },
            paragraph: {
              paragraph: 'Paragraph',
              outdent: 'Outdent',
              indent: 'Indent',
              left: 'Align left',
              center: 'Align center',
              right: 'Align right',
              justify: 'Justify full'
            },
            color: {
              recent: 'Recent Color',
              more: 'More Color',
              background: 'Background Color',
              foreground: 'Text Color',
              transparent: 'Transparent',
              setTransparent: 'Set transparent',
              reset: 'Reset',
              resetToDefault: 'Reset to default',
              cpSelect: 'Select'
            },
            shortcut: {
              shortcuts: 'Keyboard shortcuts',
              close: 'Close',
              textFormatting: 'Text formatting',
              action: 'Action',
              paragraphFormatting: 'Paragraph formatting',
              documentStyle: 'Document Style',
              extraKeys: 'Extra keys'
            },
            help: {
              'escape': 'Escape',
              'insertParagraph': 'Insert Paragraph',
              'undo': 'Undo the last command',
              'redo': 'Redo the last command',
              'tab': 'Tab',
              'untab': 'Untab',
              'bold': 'Set a bold style',
              'italic': 'Set a italic style',
              'underline': 'Set a underline style',
              'strikethrough': 'Set a strikethrough style',
              'removeFormat': 'Clean a style',
              'justifyLeft': 'Set left align',
              'justifyCenter': 'Set center align',
              'justifyRight': 'Set right align',
              'justifyFull': 'Set full align',
              'insertUnorderedList': 'Toggle unordered list',
              'insertOrderedList': 'Toggle ordered list',
              'outdent': 'Outdent on current paragraph',
              'indent': 'Indent on current paragraph',
              'formatPara': 'Change current block\'s format as a paragraph(P tag)',
              'formatH1': 'Change current block\'s format as H1',
              'formatH2': 'Change current block\'s format as H2',
              'formatH3': 'Change current block\'s format as H3',
              'formatH4': 'Change current block\'s format as H4',
              'formatH5': 'Change current block\'s format as H5',
              'formatH6': 'Change current block\'s format as H6',
              'insertHorizontalRule': 'Insert horizontal rule',
              'linkDialog.show': 'Show Link Dialog'
            },
            history: {
              undo: 'Undo',
              redo: 'Redo'
            },
            specialChar: {
              specialChar: 'SPECIAL CHARACTERS',
              select: 'Select Special characters'
            },
            output: {
              noSelection: 'No Selection Made!'
            }
          }
        }); // CONCATENATED MODULE: ./src/js/base/core/env.js

        var isSupportAmd =  true && __webpack_require__(2); // eslint-disable-line

        /**
         * returns whether font is installed or not.
         *
         * @param {String} fontName
         * @return {Boolean}
         */


        var genericFontFamilies = ['sans-serif', 'serif', 'monospace', 'cursive', 'fantasy'];

        function validFontName(fontName) {
          return external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.inArray(fontName.toLowerCase(), genericFontFamilies) === -1 ? "'".concat(fontName, "'") : fontName;
        }

        function env_isFontInstalled(fontName) {
          var testFontName = fontName === 'Comic Sans MS' ? 'Courier New' : 'Comic Sans MS';
          var testText = 'mmmmmmmmmmwwwww';
          var testSize = '200px';
          var canvas = document.createElement('canvas');
          var context = canvas.getContext('2d');
          context.font = testSize + " '" + testFontName + "'";
          var originalWidth = context.measureText(testText).width;
          context.font = testSize + ' ' + validFontName(fontName) + ', "' + testFontName + '"';
          var width = context.measureText(testText).width;
          return originalWidth !== width;
        }

        var userAgent = navigator.userAgent;
        var isMSIE = /MSIE|Trident/i.test(userAgent);
        var browserVersion;

        if (isMSIE) {
          var matches = /MSIE (\d+[.]\d+)/.exec(userAgent);

          if (matches) {
            browserVersion = parseFloat(matches[1]);
          }

          matches = /Trident\/.*rv:([0-9]{1,}[.0-9]{0,})/.exec(userAgent);

          if (matches) {
            browserVersion = parseFloat(matches[1]);
          }
        }

        var isEdge = /Edge\/\d+/.test(userAgent);
        var isSupportTouch = 'ontouchstart' in window || navigator.MaxTouchPoints > 0 || navigator.msMaxTouchPoints > 0; // [workaround] IE doesn't have input events for contentEditable
        // - see: https://goo.gl/4bfIvA

        var inputEventName = isMSIE ? 'DOMCharacterDataModified DOMSubtreeModified DOMNodeInserted' : 'input';
        /**
         * @class core.env
         *
         * Object which check platform and agent
         *
         * @singleton
         * @alternateClassName env
         */

        /* harmony default export */

        var env = {
          isMac: navigator.appVersion.indexOf('Mac') > -1,
          isMSIE: isMSIE,
          isEdge: isEdge,
          isFF: !isEdge && /firefox/i.test(userAgent),
          isPhantom: /PhantomJS/i.test(userAgent),
          isWebkit: !isEdge && /webkit/i.test(userAgent),
          isChrome: !isEdge && /chrome/i.test(userAgent),
          isSafari: !isEdge && /safari/i.test(userAgent) && !/chrome/i.test(userAgent),
          browserVersion: browserVersion,
          jqueryVersion: parseFloat(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.fn.jquery),
          isSupportAmd: isSupportAmd,
          isSupportTouch: isSupportTouch,
          isFontInstalled: env_isFontInstalled,
          isW3CRangeSupport: !!document.createRange,
          inputEventName: inputEventName,
          genericFontFamilies: genericFontFamilies,
          validFontName: validFontName
        }; // CONCATENATED MODULE: ./src/js/base/core/func.js

        /**
         * @class core.func
         *
         * func utils (for high-order func's arg)
         *
         * @singleton
         * @alternateClassName func
         */

        function eq(itemA) {
          return function (itemB) {
            return itemA === itemB;
          };
        }

        function eq2(itemA, itemB) {
          return itemA === itemB;
        }

        function peq2(propName) {
          return function (itemA, itemB) {
            return itemA[propName] === itemB[propName];
          };
        }

        function ok() {
          return true;
        }

        function fail() {
          return false;
        }

        function not(f) {
          return function () {
            return !f.apply(f, arguments);
          };
        }

        function and(fA, fB) {
          return function (item) {
            return fA(item) && fB(item);
          };
        }

        function func_self(a) {
          return a;
        }

        function func_invoke(obj, method) {
          return function () {
            return obj[method].apply(obj, arguments);
          };
        }

        var idCounter = 0;
        /**
         * reset globally-unique id
         *
         */

        function resetUniqueId() {
          idCounter = 0;
        }
        /**
         * generate a globally-unique id
         *
         * @param {String} [prefix]
         */


        function uniqueId(prefix) {
          var id = ++idCounter + '';
          return prefix ? prefix + id : id;
        }
        /**
         * returns bnd (bounds) from rect
         *
         * - IE Compatibility Issue: http://goo.gl/sRLOAo
         * - Scroll Issue: http://goo.gl/sNjUc
         *
         * @param {Rect} rect
         * @return {Object} bounds
         * @return {Number} bounds.top
         * @return {Number} bounds.left
         * @return {Number} bounds.width
         * @return {Number} bounds.height
         */


        function rect2bnd(rect) {
          var $document = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(document);
          return {
            top: rect.top + $document.scrollTop(),
            left: rect.left + $document.scrollLeft(),
            width: rect.right - rect.left,
            height: rect.bottom - rect.top
          };
        }
        /**
         * returns a copy of the object where the keys have become the values and the values the keys.
         * @param {Object} obj
         * @return {Object}
         */


        function invertObject(obj) {
          var inverted = {};

          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              inverted[obj[key]] = key;
            }
          }

          return inverted;
        }
        /**
         * @param {String} namespace
         * @param {String} [prefix]
         * @return {String}
         */


        function namespaceToCamel(namespace, prefix) {
          prefix = prefix || '';
          return prefix + namespace.split('.').map(function (name) {
            return name.substring(0, 1).toUpperCase() + name.substring(1);
          }).join('');
        }
        /**
         * Returns a function, that, as long as it continues to be invoked, will not
         * be triggered. The function will be called after it stops being called for
         * N milliseconds. If `immediate` is passed, trigger the function on the
         * leading edge, instead of the trailing.
         * @param {Function} func
         * @param {Number} wait
         * @param {Boolean} immediate
         * @return {Function}
         */


        function debounce(func, wait, immediate) {
          var timeout;
          return function () {
            var context = this;
            var args = arguments;

            var later = function later() {
              timeout = null;

              if (!immediate) {
                func.apply(context, args);
              }
            };

            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);

            if (callNow) {
              func.apply(context, args);
            }
          };
        }
        /**
         *
         * @param {String} url
         * @return {Boolean}
         */


        function isValidUrl(url) {
          var expression = /[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/gi;
          return expression.test(url);
        }
        /* harmony default export */


        var func = {
          eq: eq,
          eq2: eq2,
          peq2: peq2,
          ok: ok,
          fail: fail,
          self: func_self,
          not: not,
          and: and,
          invoke: func_invoke,
          resetUniqueId: resetUniqueId,
          uniqueId: uniqueId,
          rect2bnd: rect2bnd,
          invertObject: invertObject,
          namespaceToCamel: namespaceToCamel,
          debounce: debounce,
          isValidUrl: isValidUrl
        }; // CONCATENATED MODULE: ./src/js/base/core/lists.js

        /**
         * returns the first item of an array.
         *
         * @param {Array} array
         */

        function lists_head(array) {
          return array[0];
        }
        /**
         * returns the last item of an array.
         *
         * @param {Array} array
         */


        function lists_last(array) {
          return array[array.length - 1];
        }
        /**
         * returns everything but the last entry of the array.
         *
         * @param {Array} array
         */


        function initial(array) {
          return array.slice(0, array.length - 1);
        }
        /**
         * returns the rest of the items in an array.
         *
         * @param {Array} array
         */


        function tail(array) {
          return array.slice(1);
        }
        /**
         * returns item of array
         */


        function find(array, pred) {
          for (var idx = 0, len = array.length; idx < len; idx++) {
            var item = array[idx];

            if (pred(item)) {
              return item;
            }
          }
        }
        /**
         * returns true if all of the values in the array pass the predicate truth test.
         */


        function lists_all(array, pred) {
          for (var idx = 0, len = array.length; idx < len; idx++) {
            if (!pred(array[idx])) {
              return false;
            }
          }

          return true;
        }
        /**
         * returns true if the value is present in the list.
         */


        function contains(array, item) {
          if (array && array.length && item) {
            if (array.indexOf) {
              return array.indexOf(item) !== -1;
            } else if (array.contains) {
              // `DOMTokenList` doesn't implement `.indexOf`, but it implements `.contains`
              return array.contains(item);
            }
          }

          return false;
        }
        /**
         * get sum from a list
         *
         * @param {Array} array - array
         * @param {Function} fn - iterator
         */


        function sum(array, fn) {
          fn = fn || func.self;
          return array.reduce(function (memo, v) {
            return memo + fn(v);
          }, 0);
        }
        /**
         * returns a copy of the collection with array type.
         * @param {Collection} collection - collection eg) node.childNodes, ...
         */


        function from(collection) {
          var result = [];
          var length = collection.length;
          var idx = -1;

          while (++idx < length) {
            result[idx] = collection[idx];
          }

          return result;
        }
        /**
         * returns whether list is empty or not
         */


        function lists_isEmpty(array) {
          return !array || !array.length;
        }
        /**
         * cluster elements by predicate function.
         *
         * @param {Array} array - array
         * @param {Function} fn - predicate function for cluster rule
         * @param {Array[]}
         */


        function clusterBy(array, fn) {
          if (!array.length) {
            return [];
          }

          var aTail = tail(array);
          return aTail.reduce(function (memo, v) {
            var aLast = lists_last(memo);

            if (fn(lists_last(aLast), v)) {
              aLast[aLast.length] = v;
            } else {
              memo[memo.length] = [v];
            }

            return memo;
          }, [[lists_head(array)]]);
        }
        /**
         * returns a copy of the array with all false values removed
         *
         * @param {Array} array - array
         * @param {Function} fn - predicate function for cluster rule
         */


        function compact(array) {
          var aResult = [];

          for (var idx = 0, len = array.length; idx < len; idx++) {
            if (array[idx]) {
              aResult.push(array[idx]);
            }
          }

          return aResult;
        }
        /**
         * produces a duplicate-free version of the array
         *
         * @param {Array} array
         */


        function unique(array) {
          var results = [];

          for (var idx = 0, len = array.length; idx < len; idx++) {
            if (!contains(results, array[idx])) {
              results.push(array[idx]);
            }
          }

          return results;
        }
        /**
         * returns next item.
         * @param {Array} array
         */


        function lists_next(array, item) {
          if (array && array.length && item) {
            var idx = array.indexOf(item);
            return idx === -1 ? null : array[idx + 1];
          }

          return null;
        }
        /**
         * returns prev item.
         * @param {Array} array
         */


        function prev(array, item) {
          if (array && array.length && item) {
            var idx = array.indexOf(item);
            return idx === -1 ? null : array[idx - 1];
          }

          return null;
        }
        /**
         * @class core.list
         *
         * list utils
         *
         * @singleton
         * @alternateClassName list
         */

        /* harmony default export */


        var lists = {
          head: lists_head,
          last: lists_last,
          initial: initial,
          tail: tail,
          prev: prev,
          next: lists_next,
          find: find,
          contains: contains,
          all: lists_all,
          sum: sum,
          from: from,
          isEmpty: lists_isEmpty,
          clusterBy: clusterBy,
          compact: compact,
          unique: unique
        }; // CONCATENATED MODULE: ./src/js/base/core/dom.js

        var NBSP_CHAR = String.fromCharCode(160);
        var ZERO_WIDTH_NBSP_CHAR = "\uFEFF";
        /**
         * @method isEditable
         *
         * returns whether node is `note-editable` or not.
         *
         * @param {Node} node
         * @return {Boolean}
         */

        function isEditable(node) {
          return node && external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(node).hasClass('note-editable');
        }
        /**
         * @method isControlSizing
         *
         * returns whether node is `note-control-sizing` or not.
         *
         * @param {Node} node
         * @return {Boolean}
         */


        function isControlSizing(node) {
          return node && external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(node).hasClass('note-control-sizing');
        }
        /**
         * @method makePredByNodeName
         *
         * returns predicate which judge whether nodeName is same
         *
         * @param {String} nodeName
         * @return {Function}
         */


        function makePredByNodeName(nodeName) {
          nodeName = nodeName.toUpperCase();
          return function (node) {
            return node && node.nodeName.toUpperCase() === nodeName;
          };
        }
        /**
         * @method isText
         *
         *
         *
         * @param {Node} node
         * @return {Boolean} true if node's type is text(3)
         */


        function isText(node) {
          return node && node.nodeType === 3;
        }
        /**
         * @method isElement
         *
         *
         *
         * @param {Node} node
         * @return {Boolean} true if node's type is element(1)
         */


        function isElement(node) {
          return node && node.nodeType === 1;
        }
        /**
         * ex) br, col, embed, hr, img, input, ...
         * @see http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
         */


        function isVoid(node) {
          return node && /^BR|^IMG|^HR|^IFRAME|^BUTTON|^INPUT|^AUDIO|^VIDEO|^EMBED/.test(node.nodeName.toUpperCase());
        }

        function isPara(node) {
          if (isEditable(node)) {
            return false;
          } // Chrome(v31.0), FF(v25.0.1) use DIV for paragraph


          return node && /^DIV|^P|^LI|^H[1-7]/.test(node.nodeName.toUpperCase());
        }

        function isHeading(node) {
          return node && /^H[1-7]/.test(node.nodeName.toUpperCase());
        }

        var isPre = makePredByNodeName('PRE');
        var isLi = makePredByNodeName('LI');

        function isPurePara(node) {
          return isPara(node) && !isLi(node);
        }

        var isTable = makePredByNodeName('TABLE');
        var isData = makePredByNodeName('DATA');

        function dom_isInline(node) {
          return !isBodyContainer(node) && !isList(node) && !isHr(node) && !isPara(node) && !isTable(node) && !isBlockquote(node) && !isData(node);
        }

        function isList(node) {
          return node && /^UL|^OL/.test(node.nodeName.toUpperCase());
        }

        var isHr = makePredByNodeName('HR');

        function dom_isCell(node) {
          return node && /^TD|^TH/.test(node.nodeName.toUpperCase());
        }

        var isBlockquote = makePredByNodeName('BLOCKQUOTE');

        function isBodyContainer(node) {
          return dom_isCell(node) || isBlockquote(node) || isEditable(node);
        }

        var isAnchor = makePredByNodeName('A');

        function isParaInline(node) {
          return dom_isInline(node) && !!dom_ancestor(node, isPara);
        }

        function isBodyInline(node) {
          return dom_isInline(node) && !dom_ancestor(node, isPara);
        }

        var isBody = makePredByNodeName('BODY');
        /**
         * returns whether nodeB is closest sibling of nodeA
         *
         * @param {Node} nodeA
         * @param {Node} nodeB
         * @return {Boolean}
         */

        function isClosestSibling(nodeA, nodeB) {
          return nodeA.nextSibling === nodeB || nodeA.previousSibling === nodeB;
        }
        /**
         * returns array of closest siblings with node
         *
         * @param {Node} node
         * @param {function} [pred] - predicate function
         * @return {Node[]}
         */


        function withClosestSiblings(node, pred) {
          pred = pred || func.ok;
          var siblings = [];

          if (node.previousSibling && pred(node.previousSibling)) {
            siblings.push(node.previousSibling);
          }

          siblings.push(node);

          if (node.nextSibling && pred(node.nextSibling)) {
            siblings.push(node.nextSibling);
          }

          return siblings;
        }
        /**
         * blank HTML for cursor position
         * - [workaround] old IE only works with &nbsp;
         * - [workaround] IE11 and other browser works with bogus br
         */


        var blankHTML = env.isMSIE && env.browserVersion < 11 ? '&nbsp;' : '<br>';
        /**
         * @method nodeLength
         *
         * returns #text's text size or element's childNodes size
         *
         * @param {Node} node
         */

        function nodeLength(node) {
          if (isText(node)) {
            return node.nodeValue.length;
          }

          if (node) {
            return node.childNodes.length;
          }

          return 0;
        }
        /**
         * returns whether deepest child node is empty or not.
         *
         * @param {Node} node
         * @return {Boolean}
         */


        function deepestChildIsEmpty(node) {
          do {
            if (node.firstElementChild === null || node.firstElementChild.innerHTML === '') break;
          } while (node = node.firstElementChild);

          return dom_isEmpty(node);
        }
        /**
         * returns whether node is empty or not.
         *
         * @param {Node} node
         * @return {Boolean}
         */


        function dom_isEmpty(node) {
          var len = nodeLength(node);

          if (len === 0) {
            return true;
          } else if (!isText(node) && len === 1 && node.innerHTML === blankHTML) {
            // ex) <p><br></p>, <span><br></span>
            return true;
          } else if (lists.all(node.childNodes, isText) && node.innerHTML === '') {
            // ex) <p></p>, <span></span>
            return true;
          }

          return false;
        }
        /**
         * padding blankHTML if node is empty (for cursor position)
         */


        function paddingBlankHTML(node) {
          if (!isVoid(node) && !nodeLength(node)) {
            node.innerHTML = blankHTML;
          }
        }
        /**
         * find nearest ancestor predicate hit
         *
         * @param {Node} node
         * @param {Function} pred - predicate function
         */


        function dom_ancestor(node, pred) {
          while (node) {
            if (pred(node)) {
              return node;
            }

            if (isEditable(node)) {
              break;
            }

            node = node.parentNode;
          }

          return null;
        }
        /**
         * find nearest ancestor only single child blood line and predicate hit
         *
         * @param {Node} node
         * @param {Function} pred - predicate function
         */


        function singleChildAncestor(node, pred) {
          node = node.parentNode;

          while (node) {
            if (nodeLength(node) !== 1) {
              break;
            }

            if (pred(node)) {
              return node;
            }

            if (isEditable(node)) {
              break;
            }

            node = node.parentNode;
          }

          return null;
        }
        /**
         * returns new array of ancestor nodes (until predicate hit).
         *
         * @param {Node} node
         * @param {Function} [optional] pred - predicate function
         */


        function listAncestor(node, pred) {
          pred = pred || func.fail;
          var ancestors = [];
          dom_ancestor(node, function (el) {
            if (!isEditable(el)) {
              ancestors.push(el);
            }

            return pred(el);
          });
          return ancestors;
        }
        /**
         * find farthest ancestor predicate hit
         */


        function lastAncestor(node, pred) {
          var ancestors = listAncestor(node);
          return lists.last(ancestors.filter(pred));
        }
        /**
         * returns common ancestor node between two nodes.
         *
         * @param {Node} nodeA
         * @param {Node} nodeB
         */


        function dom_commonAncestor(nodeA, nodeB) {
          var ancestors = listAncestor(nodeA);

          for (var n = nodeB; n; n = n.parentNode) {
            if (ancestors.indexOf(n) > -1) return n;
          }

          return null; // difference document area
        }
        /**
         * listing all previous siblings (until predicate hit).
         *
         * @param {Node} node
         * @param {Function} [optional] pred - predicate function
         */


        function listPrev(node, pred) {
          pred = pred || func.fail;
          var nodes = [];

          while (node) {
            if (pred(node)) {
              break;
            }

            nodes.push(node);
            node = node.previousSibling;
          }

          return nodes;
        }
        /**
         * listing next siblings (until predicate hit).
         *
         * @param {Node} node
         * @param {Function} [pred] - predicate function
         */


        function listNext(node, pred) {
          pred = pred || func.fail;
          var nodes = [];

          while (node) {
            if (pred(node)) {
              break;
            }

            nodes.push(node);
            node = node.nextSibling;
          }

          return nodes;
        }
        /**
         * listing descendant nodes
         *
         * @param {Node} node
         * @param {Function} [pred] - predicate function
         */


        function listDescendant(node, pred) {
          var descendants = [];
          pred = pred || func.ok; // start DFS(depth first search) with node

          (function fnWalk(current) {
            if (node !== current && pred(current)) {
              descendants.push(current);
            }

            for (var idx = 0, len = current.childNodes.length; idx < len; idx++) {
              fnWalk(current.childNodes[idx]);
            }
          })(node);

          return descendants;
        }
        /**
         * wrap node with new tag.
         *
         * @param {Node} node
         * @param {Node} tagName of wrapper
         * @return {Node} - wrapper
         */


        function wrap(node, wrapperName) {
          var parent = node.parentNode;
          var wrapper = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<' + wrapperName + '>')[0];
          parent.insertBefore(wrapper, node);
          wrapper.appendChild(node);
          return wrapper;
        }
        /**
         * insert node after preceding
         *
         * @param {Node} node
         * @param {Node} preceding - predicate function
         */


        function insertAfter(node, preceding) {
          var next = preceding.nextSibling;
          var parent = preceding.parentNode;

          if (next) {
            parent.insertBefore(node, next);
          } else {
            parent.appendChild(node);
          }

          return node;
        }
        /**
         * append elements.
         *
         * @param {Node} node
         * @param {Collection} aChild
         */


        function appendChildNodes(node, aChild) {
          external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(aChild, function (idx, child) {
            node.appendChild(child);
          });
          return node;
        }
        /**
         * returns whether boundaryPoint is left edge or not.
         *
         * @param {BoundaryPoint} point
         * @return {Boolean}
         */


        function isLeftEdgePoint(point) {
          return point.offset === 0;
        }
        /**
         * returns whether boundaryPoint is right edge or not.
         *
         * @param {BoundaryPoint} point
         * @return {Boolean}
         */


        function isRightEdgePoint(point) {
          return point.offset === nodeLength(point.node);
        }
        /**
         * returns whether boundaryPoint is edge or not.
         *
         * @param {BoundaryPoint} point
         * @return {Boolean}
         */


        function isEdgePoint(point) {
          return isLeftEdgePoint(point) || isRightEdgePoint(point);
        }
        /**
         * returns whether node is left edge of ancestor or not.
         *
         * @param {Node} node
         * @param {Node} ancestor
         * @return {Boolean}
         */


        function dom_isLeftEdgeOf(node, ancestor) {
          while (node && node !== ancestor) {
            if (dom_position(node) !== 0) {
              return false;
            }

            node = node.parentNode;
          }

          return true;
        }
        /**
         * returns whether node is right edge of ancestor or not.
         *
         * @param {Node} node
         * @param {Node} ancestor
         * @return {Boolean}
         */


        function isRightEdgeOf(node, ancestor) {
          if (!ancestor) {
            return false;
          }

          while (node && node !== ancestor) {
            if (dom_position(node) !== nodeLength(node.parentNode) - 1) {
              return false;
            }

            node = node.parentNode;
          }

          return true;
        }
        /**
         * returns whether point is left edge of ancestor or not.
         * @param {BoundaryPoint} point
         * @param {Node} ancestor
         * @return {Boolean}
         */


        function isLeftEdgePointOf(point, ancestor) {
          return isLeftEdgePoint(point) && dom_isLeftEdgeOf(point.node, ancestor);
        }
        /**
         * returns whether point is right edge of ancestor or not.
         * @param {BoundaryPoint} point
         * @param {Node} ancestor
         * @return {Boolean}
         */


        function isRightEdgePointOf(point, ancestor) {
          return isRightEdgePoint(point) && isRightEdgeOf(point.node, ancestor);
        }
        /**
         * returns offset from parent.
         *
         * @param {Node} node
         */


        function dom_position(node) {
          var offset = 0;

          while (node = node.previousSibling) {
            offset += 1;
          }

          return offset;
        }

        function hasChildren(node) {
          return !!(node && node.childNodes && node.childNodes.length);
        }
        /**
         * returns previous boundaryPoint
         *
         * @param {BoundaryPoint} point
         * @param {Boolean} isSkipInnerOffset
         * @return {BoundaryPoint}
         */


        function dom_prevPoint(point, isSkipInnerOffset) {
          var node;
          var offset;

          if (point.offset === 0) {
            if (isEditable(point.node)) {
              return null;
            }

            node = point.node.parentNode;
            offset = dom_position(point.node);
          } else if (hasChildren(point.node)) {
            node = point.node.childNodes[point.offset - 1];
            offset = nodeLength(node);
          } else {
            node = point.node;
            offset = isSkipInnerOffset ? 0 : point.offset - 1;
          }

          return {
            node: node,
            offset: offset
          };
        }
        /**
         * returns next boundaryPoint
         *
         * @param {BoundaryPoint} point
         * @param {Boolean} isSkipInnerOffset
         * @return {BoundaryPoint}
         */


        function dom_nextPoint(point, isSkipInnerOffset) {
          var node, offset;

          if (nodeLength(point.node) === point.offset) {
            if (isEditable(point.node)) {
              return null;
            }

            var nextTextNode = getNextTextNode(point.node);

            if (nextTextNode) {
              node = nextTextNode;
              offset = 0;
            } else {
              node = point.node.parentNode;
              offset = dom_position(point.node) + 1;
            }
          } else if (hasChildren(point.node)) {
            node = point.node.childNodes[point.offset];
            offset = 0;
          } else {
            node = point.node;
            offset = isSkipInnerOffset ? nodeLength(point.node) : point.offset + 1;
          }

          return {
            node: node,
            offset: offset
          };
        }
        /**
         * returns next boundaryPoint with empty node
         *
         * @param {BoundaryPoint} point
         * @param {Boolean} isSkipInnerOffset
         * @return {BoundaryPoint}
         */


        function nextPointWithEmptyNode(point, isSkipInnerOffset) {
          var node, offset; // if node is empty string node, return current node's sibling.

          if (dom_isEmpty(point.node)) {
            node = point.node.nextSibling;
            offset = 0;
            return {
              node: node,
              offset: offset
            };
          }

          if (nodeLength(point.node) === point.offset) {
            if (isEditable(point.node)) {
              return null;
            }

            var nextTextNode = getNextTextNode(point.node);

            if (nextTextNode) {
              node = nextTextNode;
              offset = 0;
            } else {
              node = point.node.parentNode;
              offset = dom_position(point.node) + 1;
            } // if next node is editable, return current node's sibling node.


            if (isEditable(node)) {
              node = point.node.nextSibling;
              offset = 0;
            }
          } else if (hasChildren(point.node)) {
            node = point.node.childNodes[point.offset];
            offset = 0;

            if (dom_isEmpty(node)) {
              return null;
            }
          } else {
            node = point.node;
            offset = isSkipInnerOffset ? nodeLength(point.node) : point.offset + 1;

            if (dom_isEmpty(node)) {
              return null;
            }
          }

          return {
            node: node,
            offset: offset
          };
        }
        /*
        * returns the next Text node index or 0 if not found.
        */


        function getNextTextNode(actual) {
          if (!actual.nextSibling) return undefined;
          if (actual.parent !== actual.nextSibling.parent) return undefined;
          if (isText(actual.nextSibling)) return actual.nextSibling;
          return getNextTextNode(actual.nextSibling);
        }
        /**
         * returns whether pointA and pointB is same or not.
         *
         * @param {BoundaryPoint} pointA
         * @param {BoundaryPoint} pointB
         * @return {Boolean}
         */


        function isSamePoint(pointA, pointB) {
          return pointA.node === pointB.node && pointA.offset === pointB.offset;
        }
        /**
         * returns whether point is visible (can set cursor) or not.
         *
         * @param {BoundaryPoint} point
         * @return {Boolean}
         */


        function isVisiblePoint(point) {
          if (isText(point.node) || !hasChildren(point.node) || dom_isEmpty(point.node)) {
            return true;
          }

          var leftNode = point.node.childNodes[point.offset - 1];
          var rightNode = point.node.childNodes[point.offset];

          if ((!leftNode || isVoid(leftNode)) && (!rightNode || isVoid(rightNode))) {
            return true;
          }

          return false;
        }
        /**
         * @method prevPointUtil
         *
         * @param {BoundaryPoint} point
         * @param {Function} pred
         * @return {BoundaryPoint}
         */


        function prevPointUntil(point, pred) {
          while (point) {
            if (pred(point)) {
              return point;
            }

            point = dom_prevPoint(point);
          }

          return null;
        }
        /**
         * @method nextPointUntil
         *
         * @param {BoundaryPoint} point
         * @param {Function} pred
         * @return {BoundaryPoint}
         */


        function nextPointUntil(point, pred) {
          while (point) {
            if (pred(point)) {
              return point;
            }

            point = dom_nextPoint(point);
          }

          return null;
        }
        /**
         * returns whether point has character or not.
         *
         * @param {Point} point
         * @return {Boolean}
         */


        function isCharPoint(point) {
          if (!isText(point.node)) {
            return false;
          }

          var ch = point.node.nodeValue.charAt(point.offset - 1);
          return ch && ch !== ' ' && ch !== NBSP_CHAR;
        }
        /**
         * returns whether point has space or not.
         *
         * @param {Point} point
         * @return {Boolean}
         */


        function isSpacePoint(point) {
          if (!isText(point.node)) {
            return false;
          }

          var ch = point.node.nodeValue.charAt(point.offset - 1);
          return ch === ' ' || ch === NBSP_CHAR;
        }
        /**
         * @method walkPoint
         *
         * @param {BoundaryPoint} startPoint
         * @param {BoundaryPoint} endPoint
         * @param {Function} handler
         * @param {Boolean} isSkipInnerOffset
         */


        function walkPoint(startPoint, endPoint, handler, isSkipInnerOffset) {
          var point = startPoint;

          while (point) {
            handler(point);

            if (isSamePoint(point, endPoint)) {
              break;
            }

            var isSkipOffset = isSkipInnerOffset && startPoint.node !== point.node && endPoint.node !== point.node;
            point = nextPointWithEmptyNode(point, isSkipOffset);
          }
        }
        /**
         * @method makeOffsetPath
         *
         * return offsetPath(array of offset) from ancestor
         *
         * @param {Node} ancestor - ancestor node
         * @param {Node} node
         */


        function makeOffsetPath(ancestor, node) {
          var ancestors = listAncestor(node, func.eq(ancestor));
          return ancestors.map(dom_position).reverse();
        }
        /**
         * @method fromOffsetPath
         *
         * return element from offsetPath(array of offset)
         *
         * @param {Node} ancestor - ancestor node
         * @param {array} offsets - offsetPath
         */


        function fromOffsetPath(ancestor, offsets) {
          var current = ancestor;

          for (var i = 0, len = offsets.length; i < len; i++) {
            if (current.childNodes.length <= offsets[i]) {
              current = current.childNodes[current.childNodes.length - 1];
            } else {
              current = current.childNodes[offsets[i]];
            }
          }

          return current;
        }
        /**
         * @method splitNode
         *
         * split element or #text
         *
         * @param {BoundaryPoint} point
         * @param {Object} [options]
         * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false
         * @param {Boolean} [options.isNotSplitEdgePoint] - default: false
         * @param {Boolean} [options.isDiscardEmptySplits] - default: false
         * @return {Node} right node of boundaryPoint
         */


        function splitNode(point, options) {
          var isSkipPaddingBlankHTML = options && options.isSkipPaddingBlankHTML;
          var isNotSplitEdgePoint = options && options.isNotSplitEdgePoint;
          var isDiscardEmptySplits = options && options.isDiscardEmptySplits;

          if (isDiscardEmptySplits) {
            isSkipPaddingBlankHTML = true;
          } // edge case


          if (isEdgePoint(point) && (isText(point.node) || isNotSplitEdgePoint)) {
            if (isLeftEdgePoint(point)) {
              return point.node;
            } else if (isRightEdgePoint(point)) {
              return point.node.nextSibling;
            }
          } // split #text


          if (isText(point.node)) {
            return point.node.splitText(point.offset);
          } else {
            var childNode = point.node.childNodes[point.offset];
            var clone = insertAfter(point.node.cloneNode(false), point.node);
            appendChildNodes(clone, listNext(childNode));

            if (!isSkipPaddingBlankHTML) {
              paddingBlankHTML(point.node);
              paddingBlankHTML(clone);
            }

            if (isDiscardEmptySplits) {
              if (dom_isEmpty(point.node)) {
                remove(point.node);
              }

              if (dom_isEmpty(clone)) {
                remove(clone);
                return point.node.nextSibling;
              }
            }

            return clone;
          }
        }
        /**
         * @method splitTree
         *
         * split tree by point
         *
         * @param {Node} root - split root
         * @param {BoundaryPoint} point
         * @param {Object} [options]
         * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false
         * @param {Boolean} [options.isNotSplitEdgePoint] - default: false
         * @return {Node} right node of boundaryPoint
         */


        function splitTree(root, point, options) {
          // ex) [#text, <span>, <p>]
          var ancestors = listAncestor(point.node, func.eq(root));

          if (!ancestors.length) {
            return null;
          } else if (ancestors.length === 1) {
            return splitNode(point, options);
          }

          return ancestors.reduce(function (node, parent) {
            if (node === point.node) {
              node = splitNode(point, options);
            }

            return splitNode({
              node: parent,
              offset: node ? dom_position(node) : nodeLength(parent)
            }, options);
          });
        }
        /**
         * split point
         *
         * @param {Point} point
         * @param {Boolean} isInline
         * @return {Object}
         */


        function splitPoint(point, isInline) {
          // find splitRoot, container
          //  - inline: splitRoot is a child of paragraph
          //  - block: splitRoot is a child of bodyContainer
          var pred = isInline ? isPara : isBodyContainer;
          var ancestors = listAncestor(point.node, pred);
          var topAncestor = lists.last(ancestors) || point.node;
          var splitRoot, container;

          if (pred(topAncestor)) {
            splitRoot = ancestors[ancestors.length - 2];
            container = topAncestor;
          } else {
            splitRoot = topAncestor;
            container = splitRoot.parentNode;
          } // if splitRoot is exists, split with splitTree


          var pivot = splitRoot && splitTree(splitRoot, point, {
            isSkipPaddingBlankHTML: isInline,
            isNotSplitEdgePoint: isInline
          }); // if container is point.node, find pivot with point.offset

          if (!pivot && container === point.node) {
            pivot = point.node.childNodes[point.offset];
          }

          return {
            rightNode: pivot,
            container: container
          };
        }

        function dom_create(nodeName) {
          return document.createElement(nodeName);
        }

        function createText(text) {
          return document.createTextNode(text);
        }
        /**
         * @method remove
         *
         * remove node, (isRemoveChild: remove child or not)
         *
         * @param {Node} node
         * @param {Boolean} isRemoveChild
         */


        function remove(node, isRemoveChild) {
          if (!node || !node.parentNode) {
            return;
          }

          if (node.removeNode) {
            return node.removeNode(isRemoveChild);
          }

          var parent = node.parentNode;

          if (!isRemoveChild) {
            var nodes = [];

            for (var i = 0, len = node.childNodes.length; i < len; i++) {
              nodes.push(node.childNodes[i]);
            }

            for (var _i = 0, _len = nodes.length; _i < _len; _i++) {
              parent.insertBefore(nodes[_i], node);
            }
          }

          parent.removeChild(node);
        }
        /**
         * @method removeWhile
         *
         * @param {Node} node
         * @param {Function} pred
         */


        function removeWhile(node, pred) {
          while (node) {
            if (isEditable(node) || !pred(node)) {
              break;
            }

            var parent = node.parentNode;
            remove(node);
            node = parent;
          }
        }
        /**
         * @method replace
         *
         * replace node with provided nodeName
         *
         * @param {Node} node
         * @param {String} nodeName
         * @return {Node} - new node
         */


        function dom_replace(node, nodeName) {
          if (node.nodeName.toUpperCase() === nodeName.toUpperCase()) {
            return node;
          }

          var newNode = dom_create(nodeName);

          if (node.style.cssText) {
            newNode.style.cssText = node.style.cssText;
          }

          appendChildNodes(newNode, lists.from(node.childNodes));
          insertAfter(newNode, node);
          remove(node);
          return newNode;
        }

        var isTextarea = makePredByNodeName('TEXTAREA');
        /**
         * @param {jQuery} $node
         * @param {Boolean} [stripLinebreaks] - default: false
         */

        function dom_value($node, stripLinebreaks) {
          var val = isTextarea($node[0]) ? $node.val() : $node.html();

          if (stripLinebreaks) {
            return val.replace(/[\n\r]/g, '');
          }

          return val;
        }
        /**
         * @method html
         *
         * get the HTML contents of node
         *
         * @param {jQuery} $node
         * @param {Boolean} [isNewlineOnBlock]
         */


        function dom_html($node, isNewlineOnBlock) {
          var markup = dom_value($node);

          if (isNewlineOnBlock) {
            var regexTag = /<(\/?)(\b(?!!)[^>\s]*)(.*?)(\s*\/?>)/g;
            markup = markup.replace(regexTag, function (match, endSlash, name) {
              name = name.toUpperCase();
              var isEndOfInlineContainer = /^DIV|^TD|^TH|^P|^LI|^H[1-7]/.test(name) && !!endSlash;
              var isBlockNode = /^BLOCKQUOTE|^TABLE|^TBODY|^TR|^HR|^UL|^OL/.test(name);
              return match + (isEndOfInlineContainer || isBlockNode ? '\n' : '');
            });
            markup = markup.trim();
          }

          return markup;
        }

        function posFromPlaceholder(placeholder) {
          var $placeholder = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(placeholder);
          var pos = $placeholder.offset();
          var height = $placeholder.outerHeight(true); // include margin

          return {
            left: pos.left,
            top: pos.top + height
          };
        }

        function attachEvents($node, events) {
          Object.keys(events).forEach(function (key) {
            $node.on(key, events[key]);
          });
        }

        function detachEvents($node, events) {
          Object.keys(events).forEach(function (key) {
            $node.off(key, events[key]);
          });
        }
        /**
         * @method isCustomStyleTag
         *
         * assert if a node contains a "note-styletag" class,
         * which implies that's a custom-made style tag node
         *
         * @param {Node} an HTML DOM node
         */


        function isCustomStyleTag(node) {
          return node && !isText(node) && lists.contains(node.classList, 'note-styletag');
        }
        /* harmony default export */


        var dom = {
          /** @property {String} NBSP_CHAR */
          NBSP_CHAR: NBSP_CHAR,

          /** @property {String} ZERO_WIDTH_NBSP_CHAR */
          ZERO_WIDTH_NBSP_CHAR: ZERO_WIDTH_NBSP_CHAR,

          /** @property {String} blank */
          blank: blankHTML,

          /** @property {String} emptyPara */
          emptyPara: "<p>".concat(blankHTML, "</p>"),
          makePredByNodeName: makePredByNodeName,
          isEditable: isEditable,
          isControlSizing: isControlSizing,
          isText: isText,
          isElement: isElement,
          isVoid: isVoid,
          isPara: isPara,
          isPurePara: isPurePara,
          isHeading: isHeading,
          isInline: dom_isInline,
          isBlock: func.not(dom_isInline),
          isBodyInline: isBodyInline,
          isBody: isBody,
          isParaInline: isParaInline,
          isPre: isPre,
          isList: isList,
          isTable: isTable,
          isData: isData,
          isCell: dom_isCell,
          isBlockquote: isBlockquote,
          isBodyContainer: isBodyContainer,
          isAnchor: isAnchor,
          isDiv: makePredByNodeName('DIV'),
          isLi: isLi,
          isBR: makePredByNodeName('BR'),
          isSpan: makePredByNodeName('SPAN'),
          isB: makePredByNodeName('B'),
          isU: makePredByNodeName('U'),
          isS: makePredByNodeName('S'),
          isI: makePredByNodeName('I'),
          isImg: makePredByNodeName('IMG'),
          isTextarea: isTextarea,
          deepestChildIsEmpty: deepestChildIsEmpty,
          isEmpty: dom_isEmpty,
          isEmptyAnchor: func.and(isAnchor, dom_isEmpty),
          isClosestSibling: isClosestSibling,
          withClosestSiblings: withClosestSiblings,
          nodeLength: nodeLength,
          isLeftEdgePoint: isLeftEdgePoint,
          isRightEdgePoint: isRightEdgePoint,
          isEdgePoint: isEdgePoint,
          isLeftEdgeOf: dom_isLeftEdgeOf,
          isRightEdgeOf: isRightEdgeOf,
          isLeftEdgePointOf: isLeftEdgePointOf,
          isRightEdgePointOf: isRightEdgePointOf,
          prevPoint: dom_prevPoint,
          nextPoint: dom_nextPoint,
          nextPointWithEmptyNode: nextPointWithEmptyNode,
          isSamePoint: isSamePoint,
          isVisiblePoint: isVisiblePoint,
          prevPointUntil: prevPointUntil,
          nextPointUntil: nextPointUntil,
          isCharPoint: isCharPoint,
          isSpacePoint: isSpacePoint,
          walkPoint: walkPoint,
          ancestor: dom_ancestor,
          singleChildAncestor: singleChildAncestor,
          listAncestor: listAncestor,
          lastAncestor: lastAncestor,
          listNext: listNext,
          listPrev: listPrev,
          listDescendant: listDescendant,
          commonAncestor: dom_commonAncestor,
          wrap: wrap,
          insertAfter: insertAfter,
          appendChildNodes: appendChildNodes,
          position: dom_position,
          hasChildren: hasChildren,
          makeOffsetPath: makeOffsetPath,
          fromOffsetPath: fromOffsetPath,
          splitTree: splitTree,
          splitPoint: splitPoint,
          create: dom_create,
          createText: createText,
          remove: remove,
          removeWhile: removeWhile,
          replace: dom_replace,
          html: dom_html,
          value: dom_value,
          posFromPlaceholder: posFromPlaceholder,
          attachEvents: attachEvents,
          detachEvents: detachEvents,
          isCustomStyleTag: isCustomStyleTag
        }; // CONCATENATED MODULE: ./src/js/base/Context.js

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps);
          if (staticProps) _defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var Context_Context = /*#__PURE__*/function () {
          /**
           * @param {jQuery} $note
           * @param {Object} options
           */
          function Context($note, options) {
            _classCallCheck(this, Context);

            this.$note = $note;
            this.memos = {};
            this.modules = {};
            this.layoutInfo = {};
            this.options = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.extend(true, {}, options); // init ui with options

            external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui_template(this.options);
            this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
            this.initialize();
          }
          /**
           * create layout and initialize modules and other resources
           */


          _createClass(Context, [{
            key: "initialize",
            value: function initialize() {
              this.layoutInfo = this.ui.createLayout(this.$note);

              this._initialize();

              this.$note.hide();
              return this;
            }
            /**
             * destroy modules and other resources and remove layout
             */

          }, {
            key: "destroy",
            value: function destroy() {
              this._destroy();

              this.$note.removeData('summernote');
              this.ui.removeLayout(this.$note, this.layoutInfo);
            }
            /**
             * destory modules and other resources and initialize it again
             */

          }, {
            key: "reset",
            value: function reset() {
              var disabled = this.isDisabled();
              this.code(dom.emptyPara);

              this._destroy();

              this._initialize();

              if (disabled) {
                this.disable();
              }
            }
          }, {
            key: "_initialize",
            value: function _initialize() {
              var _this = this; // set own id


              this.options.id = func.uniqueId(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.now()); // set default container for tooltips, popovers, and dialogs

              this.options.container = this.options.container || this.layoutInfo.editor; // add optional buttons

              var buttons = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.extend({}, this.options.buttons);
              Object.keys(buttons).forEach(function (key) {
                _this.memo('button.' + key, buttons[key]);
              });
              var modules = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.extend({}, this.options.modules, external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.plugins || {}); // add and initialize modules

              Object.keys(modules).forEach(function (key) {
                _this.module(key, modules[key], true);
              });
              Object.keys(this.modules).forEach(function (key) {
                _this.initializeModule(key);
              });
            }
          }, {
            key: "_destroy",
            value: function _destroy() {
              var _this2 = this; // destroy modules with reversed order


              Object.keys(this.modules).reverse().forEach(function (key) {
                _this2.removeModule(key);
              });
              Object.keys(this.memos).forEach(function (key) {
                _this2.removeMemo(key);
              }); // trigger custom onDestroy callback

              this.triggerEvent('destroy', this);
            }
          }, {
            key: "code",
            value: function code(html) {
              var isActivated = this.invoke('codeview.isActivated');

              if (html === undefined) {
                this.invoke('codeview.sync');
                return isActivated ? this.layoutInfo.codable.val() : this.layoutInfo.editable.html();
              } else {
                if (isActivated) {
                  this.invoke('codeview.sync', html);
                } else {
                  this.layoutInfo.editable.html(html);
                }

                this.$note.val(html);
                this.triggerEvent('change', html, this.layoutInfo.editable);
              }
            }
          }, {
            key: "isDisabled",
            value: function isDisabled() {
              return this.layoutInfo.editable.attr('contenteditable') === 'false';
            }
          }, {
            key: "enable",
            value: function enable() {
              this.layoutInfo.editable.attr('contenteditable', true);
              this.invoke('toolbar.activate', true);
              this.triggerEvent('disable', false);
              this.options.editing = true;
            }
          }, {
            key: "disable",
            value: function disable() {
              // close codeview if codeview is opend
              if (this.invoke('codeview.isActivated')) {
                this.invoke('codeview.deactivate');
              }

              this.layoutInfo.editable.attr('contenteditable', false);
              this.options.editing = false;
              this.invoke('toolbar.deactivate', true);
              this.triggerEvent('disable', true);
            }
          }, {
            key: "triggerEvent",
            value: function triggerEvent() {
              var namespace = lists.head(arguments);
              var args = lists.tail(lists.from(arguments));
              var callback = this.options.callbacks[func.namespaceToCamel(namespace, 'on')];

              if (callback) {
                callback.apply(this.$note[0], args);
              }

              this.$note.trigger('summernote.' + namespace, args);
            }
          }, {
            key: "initializeModule",
            value: function initializeModule(key) {
              var module = this.modules[key];
              module.shouldInitialize = module.shouldInitialize || func.ok;

              if (!module.shouldInitialize()) {
                return;
              } // initialize module


              if (module.initialize) {
                module.initialize();
              } // attach events


              if (module.events) {
                dom.attachEvents(this.$note, module.events);
              }
            }
          }, {
            key: "module",
            value: function module(key, ModuleClass, withoutIntialize) {
              if (arguments.length === 1) {
                return this.modules[key];
              }

              this.modules[key] = new ModuleClass(this);

              if (!withoutIntialize) {
                this.initializeModule(key);
              }
            }
          }, {
            key: "removeModule",
            value: function removeModule(key) {
              var module = this.modules[key];

              if (module.shouldInitialize()) {
                if (module.events) {
                  dom.detachEvents(this.$note, module.events);
                }

                if (module.destroy) {
                  module.destroy();
                }
              }

              delete this.modules[key];
            }
          }, {
            key: "memo",
            value: function memo(key, obj) {
              if (arguments.length === 1) {
                return this.memos[key];
              }

              this.memos[key] = obj;
            }
          }, {
            key: "removeMemo",
            value: function removeMemo(key) {
              if (this.memos[key] && this.memos[key].destroy) {
                this.memos[key].destroy();
              }

              delete this.memos[key];
            }
            /**
             * Some buttons need to change their visual style immediately once they get pressed
             */

          }, {
            key: "createInvokeHandlerAndUpdateState",
            value: function createInvokeHandlerAndUpdateState(namespace, value) {
              var _this3 = this;

              return function (event) {
                _this3.createInvokeHandler(namespace, value)(event);

                _this3.invoke('buttons.updateCurrentStyle');
              };
            }
          }, {
            key: "createInvokeHandler",
            value: function createInvokeHandler(namespace, value) {
              var _this4 = this;

              return function (event) {
                event.preventDefault();
                var $target = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(event.target);

                _this4.invoke(namespace, value || $target.closest('[data-value]').data('value'), $target);
              };
            }
          }, {
            key: "invoke",
            value: function invoke() {
              var namespace = lists.head(arguments);
              var args = lists.tail(lists.from(arguments));
              var splits = namespace.split('.');
              var hasSeparator = splits.length > 1;
              var moduleName = hasSeparator && lists.head(splits);
              var methodName = hasSeparator ? lists.last(splits) : lists.head(splits);
              var module = this.modules[moduleName || 'editor'];

              if (!moduleName && this[methodName]) {
                return this[methodName].apply(this, args);
              } else if (module && module[methodName] && module.shouldInitialize()) {
                return module[methodName].apply(module, args);
              }
            }
          }]);

          return Context;
        }(); // CONCATENATED MODULE: ./src/js/summernote.js


        external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.fn.extend({
          /**
           * Summernote API
           *
           * @param {Object|String}
           * @return {this}
           */
          summernote: function summernote() {
            var type = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.type(lists.head(arguments));
            var isExternalAPICalled = type === 'string';
            var hasInitOptions = type === 'object';
            var options = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.extend({}, external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.options, hasInitOptions ? lists.head(arguments) : {}); // Update options

            options.langInfo = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.extend(true, {}, external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.lang['en-US'], external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.lang[options.lang]);
            options.icons = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.extend(true, {}, external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.options.icons, options.icons);
            options.tooltip = options.tooltip === 'auto' ? !env.isSupportTouch : options.tooltip;
            this.each(function (idx, note) {
              var $note = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(note);

              if (!$note.data('summernote')) {
                var context = new Context_Context($note, options);
                $note.data('summernote', context);
                $note.data('summernote').triggerEvent('init', context.layoutInfo);
              }
            });
            var $note = this.first();

            if ($note.length) {
              var context = $note.data('summernote');

              if (isExternalAPICalled) {
                return context.invoke.apply(context, lists.from(arguments));
              } else if (options.focus) {
                context.invoke('editor.focus');
              }
            }

            return this;
          }
        }); // CONCATENATED MODULE: ./src/js/base/core/range.js

        function range_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function range_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function range_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) range_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) range_defineProperties(Constructor, staticProps);
          return Constructor;
        }
        /**
         * return boundaryPoint from TextRange, inspired by Andy Na's HuskyRange.js
         *
         * @param {TextRange} textRange
         * @param {Boolean} isStart
         * @return {BoundaryPoint}
         *
         * @see http://msdn.microsoft.com/en-us/library/ie/ms535872(v=vs.85).aspx
         */


        function textRangeToPoint(textRange, isStart) {
          var container = textRange.parentElement();
          var offset;
          var tester = document.body.createTextRange();
          var prevContainer;
          var childNodes = lists.from(container.childNodes);

          for (offset = 0; offset < childNodes.length; offset++) {
            if (dom.isText(childNodes[offset])) {
              continue;
            }

            tester.moveToElementText(childNodes[offset]);

            if (tester.compareEndPoints('StartToStart', textRange) >= 0) {
              break;
            }

            prevContainer = childNodes[offset];
          }

          if (offset !== 0 && dom.isText(childNodes[offset - 1])) {
            var textRangeStart = document.body.createTextRange();
            var curTextNode = null;
            textRangeStart.moveToElementText(prevContainer || container);
            textRangeStart.collapse(!prevContainer);
            curTextNode = prevContainer ? prevContainer.nextSibling : container.firstChild;
            var pointTester = textRange.duplicate();
            pointTester.setEndPoint('StartToStart', textRangeStart);
            var textCount = pointTester.text.replace(/[\r\n]/g, '').length;

            while (textCount > curTextNode.nodeValue.length && curTextNode.nextSibling) {
              textCount -= curTextNode.nodeValue.length;
              curTextNode = curTextNode.nextSibling;
            } // [workaround] enforce IE to re-reference curTextNode, hack


            var dummy = curTextNode.nodeValue; // eslint-disable-line

            if (isStart && curTextNode.nextSibling && dom.isText(curTextNode.nextSibling) && textCount === curTextNode.nodeValue.length) {
              textCount -= curTextNode.nodeValue.length;
              curTextNode = curTextNode.nextSibling;
            }

            container = curTextNode;
            offset = textCount;
          }

          return {
            cont: container,
            offset: offset
          };
        }
        /**
         * return TextRange from boundary point (inspired by google closure-library)
         * @param {BoundaryPoint} point
         * @return {TextRange}
         */


        function pointToTextRange(point) {
          var textRangeInfo = function textRangeInfo(container, offset) {
            var node, isCollapseToStart;

            if (dom.isText(container)) {
              var prevTextNodes = dom.listPrev(container, func.not(dom.isText));
              var prevContainer = lists.last(prevTextNodes).previousSibling;
              node = prevContainer || container.parentNode;
              offset += lists.sum(lists.tail(prevTextNodes), dom.nodeLength);
              isCollapseToStart = !prevContainer;
            } else {
              node = container.childNodes[offset] || container;

              if (dom.isText(node)) {
                return textRangeInfo(node, 0);
              }

              offset = 0;
              isCollapseToStart = false;
            }

            return {
              node: node,
              collapseToStart: isCollapseToStart,
              offset: offset
            };
          };

          var textRange = document.body.createTextRange();
          var info = textRangeInfo(point.node, point.offset);
          textRange.moveToElementText(info.node);
          textRange.collapse(info.collapseToStart);
          textRange.moveStart('character', info.offset);
          return textRange;
        }
        /**
           * Wrapped Range
           *
           * @constructor
           * @param {Node} sc - start container
           * @param {Number} so - start offset
           * @param {Node} ec - end container
           * @param {Number} eo - end offset
           */


        var range_WrappedRange = /*#__PURE__*/function () {
          function WrappedRange(sc, so, ec, eo) {
            range_classCallCheck(this, WrappedRange);
            this.sc = sc;
            this.so = so;
            this.ec = ec;
            this.eo = eo; // isOnEditable: judge whether range is on editable or not

            this.isOnEditable = this.makeIsOn(dom.isEditable); // isOnList: judge whether range is on list node or not

            this.isOnList = this.makeIsOn(dom.isList); // isOnAnchor: judge whether range is on anchor node or not

            this.isOnAnchor = this.makeIsOn(dom.isAnchor); // isOnCell: judge whether range is on cell node or not

            this.isOnCell = this.makeIsOn(dom.isCell); // isOnData: judge whether range is on data node or not

            this.isOnData = this.makeIsOn(dom.isData);
          } // nativeRange: get nativeRange from sc, so, ec, eo


          range_createClass(WrappedRange, [{
            key: "nativeRange",
            value: function nativeRange() {
              if (env.isW3CRangeSupport) {
                var w3cRange = document.createRange();
                w3cRange.setStart(this.sc, this.so);
                w3cRange.setEnd(this.ec, this.eo);
                return w3cRange;
              } else {
                var textRange = pointToTextRange({
                  node: this.sc,
                  offset: this.so
                });
                textRange.setEndPoint('EndToEnd', pointToTextRange({
                  node: this.ec,
                  offset: this.eo
                }));
                return textRange;
              }
            }
          }, {
            key: "getPoints",
            value: function getPoints() {
              return {
                sc: this.sc,
                so: this.so,
                ec: this.ec,
                eo: this.eo
              };
            }
          }, {
            key: "getStartPoint",
            value: function getStartPoint() {
              return {
                node: this.sc,
                offset: this.so
              };
            }
          }, {
            key: "getEndPoint",
            value: function getEndPoint() {
              return {
                node: this.ec,
                offset: this.eo
              };
            }
            /**
             * select update visible range
             */

          }, {
            key: "select",
            value: function select() {
              var nativeRng = this.nativeRange();

              if (env.isW3CRangeSupport) {
                var selection = document.getSelection();

                if (selection.rangeCount > 0) {
                  selection.removeAllRanges();
                }

                selection.addRange(nativeRng);
              } else {
                nativeRng.select();
              }

              return this;
            }
            /**
             * Moves the scrollbar to start container(sc) of current range
             *
             * @return {WrappedRange}
             */

          }, {
            key: "scrollIntoView",
            value: function scrollIntoView(container) {
              var height = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(container).height();

              if (container.scrollTop + height < this.sc.offsetTop) {
                container.scrollTop += Math.abs(container.scrollTop + height - this.sc.offsetTop);
              }

              return this;
            }
            /**
             * @return {WrappedRange}
             */

          }, {
            key: "normalize",
            value: function normalize() {
              /**
               * @param {BoundaryPoint} point
               * @param {Boolean} isLeftToRight - true: prefer to choose right node
               *                                - false: prefer to choose left node
               * @return {BoundaryPoint}
               */
              var getVisiblePoint = function getVisiblePoint(point, isLeftToRight) {
                if (!point) {
                  return point;
                } // Just use the given point [XXX:Adhoc]
                //  - case 01. if the point is on the middle of the node
                //  - case 02. if the point is on the right edge and prefer to choose left node
                //  - case 03. if the point is on the left edge and prefer to choose right node
                //  - case 04. if the point is on the right edge and prefer to choose right node but the node is void
                //  - case 05. if the point is on the left edge and prefer to choose left node but the node is void
                //  - case 06. if the point is on the block node and there is no children


                if (dom.isVisiblePoint(point)) {
                  if (!dom.isEdgePoint(point) || dom.isRightEdgePoint(point) && !isLeftToRight || dom.isLeftEdgePoint(point) && isLeftToRight || dom.isRightEdgePoint(point) && isLeftToRight && dom.isVoid(point.node.nextSibling) || dom.isLeftEdgePoint(point) && !isLeftToRight && dom.isVoid(point.node.previousSibling) || dom.isBlock(point.node) && dom.isEmpty(point.node)) {
                    return point;
                  }
                } // point on block's edge


                var block = dom.ancestor(point.node, dom.isBlock);
                var hasRightNode = false;

                if (!hasRightNode) {
                  var prevPoint = dom.prevPoint(point) || {
                    node: null
                  };
                  hasRightNode = (dom.isLeftEdgePointOf(point, block) || dom.isVoid(prevPoint.node)) && !isLeftToRight;
                }

                var hasLeftNode = false;

                if (!hasLeftNode) {
                  var _nextPoint = dom.nextPoint(point) || {
                    node: null
                  };

                  hasLeftNode = (dom.isRightEdgePointOf(point, block) || dom.isVoid(_nextPoint.node)) && isLeftToRight;
                }

                if (hasRightNode || hasLeftNode) {
                  // returns point already on visible point
                  if (dom.isVisiblePoint(point)) {
                    return point;
                  } // reverse direction


                  isLeftToRight = !isLeftToRight;
                }

                var nextPoint = isLeftToRight ? dom.nextPointUntil(dom.nextPoint(point), dom.isVisiblePoint) : dom.prevPointUntil(dom.prevPoint(point), dom.isVisiblePoint);
                return nextPoint || point;
              };

              var endPoint = getVisiblePoint(this.getEndPoint(), false);
              var startPoint = this.isCollapsed() ? endPoint : getVisiblePoint(this.getStartPoint(), true);
              return new WrappedRange(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset);
            }
            /**
             * returns matched nodes on range
             *
             * @param {Function} [pred] - predicate function
             * @param {Object} [options]
             * @param {Boolean} [options.includeAncestor]
             * @param {Boolean} [options.fullyContains]
             * @return {Node[]}
             */

          }, {
            key: "nodes",
            value: function nodes(pred, options) {
              pred = pred || func.ok;
              var includeAncestor = options && options.includeAncestor;
              var fullyContains = options && options.fullyContains; // TODO compare points and sort

              var startPoint = this.getStartPoint();
              var endPoint = this.getEndPoint();
              var nodes = [];
              var leftEdgeNodes = [];
              dom.walkPoint(startPoint, endPoint, function (point) {
                if (dom.isEditable(point.node)) {
                  return;
                }

                var node;

                if (fullyContains) {
                  if (dom.isLeftEdgePoint(point)) {
                    leftEdgeNodes.push(point.node);
                  }

                  if (dom.isRightEdgePoint(point) && lists.contains(leftEdgeNodes, point.node)) {
                    node = point.node;
                  }
                } else if (includeAncestor) {
                  node = dom.ancestor(point.node, pred);
                } else {
                  node = point.node;
                }

                if (node && pred(node)) {
                  nodes.push(node);
                }
              }, true);
              return lists.unique(nodes);
            }
            /**
             * returns commonAncestor of range
             * @return {Element} - commonAncestor
             */

          }, {
            key: "commonAncestor",
            value: function commonAncestor() {
              return dom.commonAncestor(this.sc, this.ec);
            }
            /**
             * returns expanded range by pred
             *
             * @param {Function} pred - predicate function
             * @return {WrappedRange}
             */

          }, {
            key: "expand",
            value: function expand(pred) {
              var startAncestor = dom.ancestor(this.sc, pred);
              var endAncestor = dom.ancestor(this.ec, pred);

              if (!startAncestor && !endAncestor) {
                return new WrappedRange(this.sc, this.so, this.ec, this.eo);
              }

              var boundaryPoints = this.getPoints();

              if (startAncestor) {
                boundaryPoints.sc = startAncestor;
                boundaryPoints.so = 0;
              }

              if (endAncestor) {
                boundaryPoints.ec = endAncestor;
                boundaryPoints.eo = dom.nodeLength(endAncestor);
              }

              return new WrappedRange(boundaryPoints.sc, boundaryPoints.so, boundaryPoints.ec, boundaryPoints.eo);
            }
            /**
             * @param {Boolean} isCollapseToStart
             * @return {WrappedRange}
             */

          }, {
            key: "collapse",
            value: function collapse(isCollapseToStart) {
              if (isCollapseToStart) {
                return new WrappedRange(this.sc, this.so, this.sc, this.so);
              } else {
                return new WrappedRange(this.ec, this.eo, this.ec, this.eo);
              }
            }
            /**
             * splitText on range
             */

          }, {
            key: "splitText",
            value: function splitText() {
              var isSameContainer = this.sc === this.ec;
              var boundaryPoints = this.getPoints();

              if (dom.isText(this.ec) && !dom.isEdgePoint(this.getEndPoint())) {
                this.ec.splitText(this.eo);
              }

              if (dom.isText(this.sc) && !dom.isEdgePoint(this.getStartPoint())) {
                boundaryPoints.sc = this.sc.splitText(this.so);
                boundaryPoints.so = 0;

                if (isSameContainer) {
                  boundaryPoints.ec = boundaryPoints.sc;
                  boundaryPoints.eo = this.eo - this.so;
                }
              }

              return new WrappedRange(boundaryPoints.sc, boundaryPoints.so, boundaryPoints.ec, boundaryPoints.eo);
            }
            /**
             * delete contents on range
             * @return {WrappedRange}
             */

          }, {
            key: "deleteContents",
            value: function deleteContents() {
              if (this.isCollapsed()) {
                return this;
              }

              var rng = this.splitText();
              var nodes = rng.nodes(null, {
                fullyContains: true
              }); // find new cursor point

              var point = dom.prevPointUntil(rng.getStartPoint(), function (point) {
                return !lists.contains(nodes, point.node);
              });
              var emptyParents = [];
              external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(nodes, function (idx, node) {
                // find empty parents
                var parent = node.parentNode;

                if (point.node !== parent && dom.nodeLength(parent) === 1) {
                  emptyParents.push(parent);
                }

                dom.remove(node, false);
              }); // remove empty parents

              external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(emptyParents, function (idx, node) {
                dom.remove(node, false);
              });
              return new WrappedRange(point.node, point.offset, point.node, point.offset).normalize();
            }
            /**
             * makeIsOn: return isOn(pred) function
             */

          }, {
            key: "makeIsOn",
            value: function makeIsOn(pred) {
              return function () {
                var ancestor = dom.ancestor(this.sc, pred);
                return !!ancestor && ancestor === dom.ancestor(this.ec, pred);
              };
            }
            /**
             * @param {Function} pred
             * @return {Boolean}
             */

          }, {
            key: "isLeftEdgeOf",
            value: function isLeftEdgeOf(pred) {
              if (!dom.isLeftEdgePoint(this.getStartPoint())) {
                return false;
              }

              var node = dom.ancestor(this.sc, pred);
              return node && dom.isLeftEdgeOf(this.sc, node);
            }
            /**
             * returns whether range was collapsed or not
             */

          }, {
            key: "isCollapsed",
            value: function isCollapsed() {
              return this.sc === this.ec && this.so === this.eo;
            }
            /**
             * wrap inline nodes which children of body with paragraph
             *
             * @return {WrappedRange}
             */

          }, {
            key: "wrapBodyInlineWithPara",
            value: function wrapBodyInlineWithPara() {
              if (dom.isBodyContainer(this.sc) && dom.isEmpty(this.sc)) {
                this.sc.innerHTML = dom.emptyPara;
                return new WrappedRange(this.sc.firstChild, 0, this.sc.firstChild, 0);
              }
              /**
               * [workaround] firefox often create range on not visible point. so normalize here.
               *  - firefox: |<p>text</p>|
               *  - chrome: <p>|text|</p>
               */


              var rng = this.normalize();

              if (dom.isParaInline(this.sc) || dom.isPara(this.sc)) {
                return rng;
              } // find inline top ancestor


              var topAncestor;

              if (dom.isInline(rng.sc)) {
                var ancestors = dom.listAncestor(rng.sc, func.not(dom.isInline));
                topAncestor = lists.last(ancestors);

                if (!dom.isInline(topAncestor)) {
                  topAncestor = ancestors[ancestors.length - 2] || rng.sc.childNodes[rng.so];
                }
              } else {
                topAncestor = rng.sc.childNodes[rng.so > 0 ? rng.so - 1 : 0];
              }

              if (topAncestor) {
                // siblings not in paragraph
                var inlineSiblings = dom.listPrev(topAncestor, dom.isParaInline).reverse();
                inlineSiblings = inlineSiblings.concat(dom.listNext(topAncestor.nextSibling, dom.isParaInline)); // wrap with paragraph

                if (inlineSiblings.length) {
                  var para = dom.wrap(lists.head(inlineSiblings), 'p');
                  dom.appendChildNodes(para, lists.tail(inlineSiblings));
                }
              }

              return this.normalize();
            }
            /**
             * insert node at current cursor
             *
             * @param {Node} node
             * @return {Node}
             */

          }, {
            key: "insertNode",
            value: function insertNode(node) {
              var rng = this;

              if (dom.isText(node) || dom.isInline(node)) {
                rng = this.wrapBodyInlineWithPara().deleteContents();
              }

              var info = dom.splitPoint(rng.getStartPoint(), dom.isInline(node));

              if (info.rightNode) {
                info.rightNode.parentNode.insertBefore(node, info.rightNode);

                if (dom.isEmpty(info.rightNode) && dom.isPara(node)) {
                  info.rightNode.parentNode.removeChild(info.rightNode);
                }
              } else {
                info.container.appendChild(node);
              }

              return node;
            }
            /**
             * insert html at current cursor
             */

          }, {
            key: "pasteHTML",
            value: function pasteHTML(markup) {
              markup = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.trim(markup);
              var contentsContainer = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<div></div>').html(markup)[0];
              var childNodes = lists.from(contentsContainer.childNodes); // const rng = this.wrapBodyInlineWithPara().deleteContents();

              var rng = this;
              var reversed = false;

              if (rng.so >= 0) {
                childNodes = childNodes.reverse();
                reversed = true;
              }

              childNodes = childNodes.map(function (childNode) {
                return rng.insertNode(childNode);
              });

              if (reversed) {
                childNodes = childNodes.reverse();
              }

              return childNodes;
            }
            /**
             * returns text in range
             *
             * @return {String}
             */

          }, {
            key: "toString",
            value: function toString() {
              var nativeRng = this.nativeRange();
              return env.isW3CRangeSupport ? nativeRng.toString() : nativeRng.text;
            }
            /**
             * returns range for word before cursor
             *
             * @param {Boolean} [findAfter] - find after cursor, default: false
             * @return {WrappedRange}
             */

          }, {
            key: "getWordRange",
            value: function getWordRange(findAfter) {
              var endPoint = this.getEndPoint();

              if (!dom.isCharPoint(endPoint)) {
                return this;
              }

              var startPoint = dom.prevPointUntil(endPoint, function (point) {
                return !dom.isCharPoint(point);
              });

              if (findAfter) {
                endPoint = dom.nextPointUntil(endPoint, function (point) {
                  return !dom.isCharPoint(point);
                });
              }

              return new WrappedRange(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset);
            }
            /**
             * returns range for words before cursor
             *
             * @param {Boolean} [findAfter] - find after cursor, default: false
             * @return {WrappedRange}
             */

          }, {
            key: "getWordsRange",
            value: function getWordsRange(findAfter) {
              var endPoint = this.getEndPoint();

              var isNotTextPoint = function isNotTextPoint(point) {
                return !dom.isCharPoint(point) && !dom.isSpacePoint(point);
              };

              if (isNotTextPoint(endPoint)) {
                return this;
              }

              var startPoint = dom.prevPointUntil(endPoint, isNotTextPoint);

              if (findAfter) {
                endPoint = dom.nextPointUntil(endPoint, isNotTextPoint);
              }

              return new WrappedRange(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset);
            }
            /**
             * returns range for words before cursor that match with a Regex
             *
             * example:
             *  range: 'hi @Peter Pan'
             *  regex: '/@[a-z ]+/i'
             *  return range: '@Peter Pan'
             *
             * @param {RegExp} [regex]
             * @return {WrappedRange|null}
             */

          }, {
            key: "getWordsMatchRange",
            value: function getWordsMatchRange(regex) {
              var endPoint = this.getEndPoint();
              var startPoint = dom.prevPointUntil(endPoint, function (point) {
                if (!dom.isCharPoint(point) && !dom.isSpacePoint(point)) {
                  return true;
                }

                var rng = new WrappedRange(point.node, point.offset, endPoint.node, endPoint.offset);
                var result = regex.exec(rng.toString());
                return result && result.index === 0;
              });
              var rng = new WrappedRange(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset);
              var text = rng.toString();
              var result = regex.exec(text);

              if (result && result[0].length === text.length) {
                return rng;
              } else {
                return null;
              }
            }
            /**
             * create offsetPath bookmark
             *
             * @param {Node} editable
             */

          }, {
            key: "bookmark",
            value: function bookmark(editable) {
              return {
                s: {
                  path: dom.makeOffsetPath(editable, this.sc),
                  offset: this.so
                },
                e: {
                  path: dom.makeOffsetPath(editable, this.ec),
                  offset: this.eo
                }
              };
            }
            /**
             * create offsetPath bookmark base on paragraph
             *
             * @param {Node[]} paras
             */

          }, {
            key: "paraBookmark",
            value: function paraBookmark(paras) {
              return {
                s: {
                  path: lists.tail(dom.makeOffsetPath(lists.head(paras), this.sc)),
                  offset: this.so
                },
                e: {
                  path: lists.tail(dom.makeOffsetPath(lists.last(paras), this.ec)),
                  offset: this.eo
                }
              };
            }
            /**
             * getClientRects
             * @return {Rect[]}
             */

          }, {
            key: "getClientRects",
            value: function getClientRects() {
              var nativeRng = this.nativeRange();
              return nativeRng.getClientRects();
            }
          }]);
          return WrappedRange;
        }();
        /**
         * Data structure
         *  * BoundaryPoint: a point of dom tree
         *  * BoundaryPoints: two boundaryPoints corresponding to the start and the end of the Range
         *
         * See to http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Position
         */

        /* harmony default export */


        var range = {
          /**
           * create Range Object From arguments or Browser Selection
           *
           * @param {Node} sc - start container
           * @param {Number} so - start offset
           * @param {Node} ec - end container
           * @param {Number} eo - end offset
           * @return {WrappedRange}
           */
          create: function create(sc, so, ec, eo) {
            if (arguments.length === 4) {
              return new range_WrappedRange(sc, so, ec, eo);
            } else if (arguments.length === 2) {
              // collapsed
              ec = sc;
              eo = so;
              return new range_WrappedRange(sc, so, ec, eo);
            } else {
              var wrappedRange = this.createFromSelection();

              if (!wrappedRange && arguments.length === 1) {
                var bodyElement = arguments[0];

                if (dom.isEditable(bodyElement)) {
                  bodyElement = bodyElement.lastChild;
                }

                return this.createFromBodyElement(bodyElement, dom.emptyPara === arguments[0].innerHTML);
              }

              return wrappedRange;
            }
          },
          createFromBodyElement: function createFromBodyElement(bodyElement) {
            var isCollapseToStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var wrappedRange = this.createFromNode(bodyElement);
            return wrappedRange.collapse(isCollapseToStart);
          },
          createFromSelection: function createFromSelection() {
            var sc, so, ec, eo;

            if (env.isW3CRangeSupport) {
              var selection = document.getSelection();

              if (!selection || selection.rangeCount === 0) {
                return null;
              } else if (dom.isBody(selection.anchorNode)) {
                // Firefox: returns entire body as range on initialization.
                // We won't never need it.
                return null;
              }

              var nativeRng = selection.getRangeAt(0);
              sc = nativeRng.startContainer;
              so = nativeRng.startOffset;
              ec = nativeRng.endContainer;
              eo = nativeRng.endOffset;
            } else {
              // IE8: TextRange
              var textRange = document.selection.createRange();
              var textRangeEnd = textRange.duplicate();
              textRangeEnd.collapse(false);
              var textRangeStart = textRange;
              textRangeStart.collapse(true);
              var startPoint = textRangeToPoint(textRangeStart, true);
              var endPoint = textRangeToPoint(textRangeEnd, false); // same visible point case: range was collapsed.

              if (dom.isText(startPoint.node) && dom.isLeftEdgePoint(startPoint) && dom.isTextNode(endPoint.node) && dom.isRightEdgePoint(endPoint) && endPoint.node.nextSibling === startPoint.node) {
                startPoint = endPoint;
              }

              sc = startPoint.cont;
              so = startPoint.offset;
              ec = endPoint.cont;
              eo = endPoint.offset;
            }

            return new range_WrappedRange(sc, so, ec, eo);
          },

          /**
           * @method
           *
           * create WrappedRange from node
           *
           * @param {Node} node
           * @return {WrappedRange}
           */
          createFromNode: function createFromNode(node) {
            var sc = node;
            var so = 0;
            var ec = node;
            var eo = dom.nodeLength(ec); // browsers can't target a picture or void node

            if (dom.isVoid(sc)) {
              so = dom.listPrev(sc).length - 1;
              sc = sc.parentNode;
            }

            if (dom.isBR(ec)) {
              eo = dom.listPrev(ec).length - 1;
              ec = ec.parentNode;
            } else if (dom.isVoid(ec)) {
              eo = dom.listPrev(ec).length;
              ec = ec.parentNode;
            }

            return this.create(sc, so, ec, eo);
          },

          /**
           * create WrappedRange from node after position
           *
           * @param {Node} node
           * @return {WrappedRange}
           */
          createFromNodeBefore: function createFromNodeBefore(node) {
            return this.createFromNode(node).collapse(true);
          },

          /**
           * create WrappedRange from node after position
           *
           * @param {Node} node
           * @return {WrappedRange}
           */
          createFromNodeAfter: function createFromNodeAfter(node) {
            return this.createFromNode(node).collapse();
          },

          /**
           * @method
           *
           * create WrappedRange from bookmark
           *
           * @param {Node} editable
           * @param {Object} bookmark
           * @return {WrappedRange}
           */
          createFromBookmark: function createFromBookmark(editable, bookmark) {
            var sc = dom.fromOffsetPath(editable, bookmark.s.path);
            var so = bookmark.s.offset;
            var ec = dom.fromOffsetPath(editable, bookmark.e.path);
            var eo = bookmark.e.offset;
            return new range_WrappedRange(sc, so, ec, eo);
          },

          /**
           * @method
           *
           * create WrappedRange from paraBookmark
           *
           * @param {Object} bookmark
           * @param {Node[]} paras
           * @return {WrappedRange}
           */
          createFromParaBookmark: function createFromParaBookmark(bookmark, paras) {
            var so = bookmark.s.offset;
            var eo = bookmark.e.offset;
            var sc = dom.fromOffsetPath(lists.head(paras), bookmark.s.path);
            var ec = dom.fromOffsetPath(lists.last(paras), bookmark.e.path);
            return new range_WrappedRange(sc, so, ec, eo);
          }
        }; // CONCATENATED MODULE: ./src/js/base/core/key.js

        var KEY_MAP = {
          'BACKSPACE': 8,
          'TAB': 9,
          'ENTER': 13,
          'ESCAPE': 27,
          'SPACE': 32,
          'DELETE': 46,
          // Arrow
          'LEFT': 37,
          'UP': 38,
          'RIGHT': 39,
          'DOWN': 40,
          // Number: 0-9
          'NUM0': 48,
          'NUM1': 49,
          'NUM2': 50,
          'NUM3': 51,
          'NUM4': 52,
          'NUM5': 53,
          'NUM6': 54,
          'NUM7': 55,
          'NUM8': 56,
          // Alphabet: a-z
          'B': 66,
          'E': 69,
          'I': 73,
          'J': 74,
          'K': 75,
          'L': 76,
          'R': 82,
          'S': 83,
          'U': 85,
          'V': 86,
          'Y': 89,
          'Z': 90,
          'SLASH': 191,
          'LEFTBRACKET': 219,
          'BACKSLASH': 220,
          'RIGHTBRACKET': 221,
          // Navigation
          'HOME': 36,
          'END': 35,
          'PAGEUP': 33,
          'PAGEDOWN': 34
        };
        /**
         * @class core.key
         *
         * Object for keycodes.
         *
         * @singleton
         * @alternateClassName key
         */

        /* harmony default export */

        var core_key = {
          /**
           * @method isEdit
           *
           * @param {Number} keyCode
           * @return {Boolean}
           */
          isEdit: function isEdit(keyCode) {
            return lists.contains([KEY_MAP.BACKSPACE, KEY_MAP.TAB, KEY_MAP.ENTER, KEY_MAP.SPACE, KEY_MAP.DELETE], keyCode);
          },

          /**
           * @method isMove
           *
           * @param {Number} keyCode
           * @return {Boolean}
           */
          isMove: function isMove(keyCode) {
            return lists.contains([KEY_MAP.LEFT, KEY_MAP.UP, KEY_MAP.RIGHT, KEY_MAP.DOWN], keyCode);
          },

          /**
           * @method isNavigation
           *
           * @param {Number} keyCode
           * @return {Boolean}
           */
          isNavigation: function isNavigation(keyCode) {
            return lists.contains([KEY_MAP.HOME, KEY_MAP.END, KEY_MAP.PAGEUP, KEY_MAP.PAGEDOWN], keyCode);
          },

          /**
           * @property {Object} nameFromCode
           * @property {String} nameFromCode.8 "BACKSPACE"
           */
          nameFromCode: func.invertObject(KEY_MAP),
          code: KEY_MAP
        }; // CONCATENATED MODULE: ./src/js/base/core/async.js

        /**
         * @method readFileAsDataURL
         *
         * read contents of file as representing URL
         *
         * @param {File} file
         * @return {Promise} - then: dataUrl
         */

        function readFileAsDataURL(file) {
          return external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.Deferred(function (deferred) {
            external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.extend(new FileReader(), {
              onload: function onload(e) {
                var dataURL = e.target.result;
                deferred.resolve(dataURL);
              },
              onerror: function onerror(err) {
                deferred.reject(err);
              }
            }).readAsDataURL(file);
          }).promise();
        }
        /**
         * @method createImage
         *
         * create `<image>` from url string
         *
         * @param {String} url
         * @return {Promise} - then: $image
         */


        function createImage(url) {
          return external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.Deferred(function (deferred) {
            var $img = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<img>');
            $img.one('load', function () {
              $img.off('error abort');
              deferred.resolve($img);
            }).one('error abort', function () {
              $img.off('load').detach();
              deferred.reject($img);
            }).css({
              display: 'none'
            }).appendTo(document.body).attr('src', url);
          }).promise();
        } // CONCATENATED MODULE: ./src/js/base/editing/History.js


        function History_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function History_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function History_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) History_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) History_defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var History_History = /*#__PURE__*/function () {
          function History(context) {
            History_classCallCheck(this, History);
            this.stack = [];
            this.stackOffset = -1;
            this.context = context;
            this.$editable = context.layoutInfo.editable;
            this.editable = this.$editable[0];
          }

          History_createClass(History, [{
            key: "makeSnapshot",
            value: function makeSnapshot() {
              var rng = range.create(this.editable);
              var emptyBookmark = {
                s: {
                  path: [],
                  offset: 0
                },
                e: {
                  path: [],
                  offset: 0
                }
              };
              return {
                contents: this.$editable.html(),
                bookmark: rng && rng.isOnEditable() ? rng.bookmark(this.editable) : emptyBookmark
              };
            }
          }, {
            key: "applySnapshot",
            value: function applySnapshot(snapshot) {
              if (snapshot.contents !== null) {
                this.$editable.html(snapshot.contents);
              }

              if (snapshot.bookmark !== null) {
                range.createFromBookmark(this.editable, snapshot.bookmark).select();
              }
            }
            /**
            * @method rewind
            * Rewinds the history stack back to the first snapshot taken.
            * Leaves the stack intact, so that "Redo" can still be used.
            */

          }, {
            key: "rewind",
            value: function rewind() {
              // Create snap shot if not yet recorded
              if (this.$editable.html() !== this.stack[this.stackOffset].contents) {
                this.recordUndo();
              } // Return to the first available snapshot.


              this.stackOffset = 0; // Apply that snapshot.

              this.applySnapshot(this.stack[this.stackOffset]);
            }
            /**
            *  @method commit
            *  Resets history stack, but keeps current editor's content.
            */

          }, {
            key: "commit",
            value: function commit() {
              // Clear the stack.
              this.stack = []; // Restore stackOffset to its original value.

              this.stackOffset = -1; // Record our first snapshot (of nothing).

              this.recordUndo();
            }
            /**
            * @method reset
            * Resets the history stack completely; reverting to an empty editor.
            */

          }, {
            key: "reset",
            value: function reset() {
              // Clear the stack.
              this.stack = []; // Restore stackOffset to its original value.

              this.stackOffset = -1; // Clear the editable area.

              this.$editable.html(''); // Record our first snapshot (of nothing).

              this.recordUndo();
            }
            /**
             * undo
             */

          }, {
            key: "undo",
            value: function undo() {
              // Create snap shot if not yet recorded
              if (this.$editable.html() !== this.stack[this.stackOffset].contents) {
                this.recordUndo();
              }

              if (this.stackOffset > 0) {
                this.stackOffset--;
                this.applySnapshot(this.stack[this.stackOffset]);
              }
            }
            /**
             * redo
             */

          }, {
            key: "redo",
            value: function redo() {
              if (this.stack.length - 1 > this.stackOffset) {
                this.stackOffset++;
                this.applySnapshot(this.stack[this.stackOffset]);
              }
            }
            /**
             * recorded undo
             */

          }, {
            key: "recordUndo",
            value: function recordUndo() {
              this.stackOffset++; // Wash out stack after stackOffset

              if (this.stack.length > this.stackOffset) {
                this.stack = this.stack.slice(0, this.stackOffset);
              } // Create new snapshot and push it to the end


              this.stack.push(this.makeSnapshot()); // If the stack size reachs to the limit, then slice it

              if (this.stack.length > this.context.options.historyLimit) {
                this.stack.shift();
                this.stackOffset -= 1;
              }
            }
          }]);
          return History;
        }(); // CONCATENATED MODULE: ./src/js/base/editing/Style.js


        function Style_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function Style_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function Style_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) Style_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) Style_defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var Style_Style = /*#__PURE__*/function () {
          function Style() {
            Style_classCallCheck(this, Style);
          }

          Style_createClass(Style, [{
            key: "jQueryCSS",

            /**
             * @method jQueryCSS
             *
             * [workaround] for old jQuery
             * passing an array of style properties to .css()
             * will result in an object of property-value pairs.
             * (compability with version < 1.9)
             *
             * @private
             * @param  {jQuery} $obj
             * @param  {Array} propertyNames - An array of one or more CSS properties.
             * @return {Object}
             */
            value: function jQueryCSS($obj, propertyNames) {
              if (env.jqueryVersion < 1.9) {
                var result = {};
                external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(propertyNames, function (idx, propertyName) {
                  result[propertyName] = $obj.css(propertyName);
                });
                return result;
              }

              return $obj.css(propertyNames);
            }
            /**
             * returns style object from node
             *
             * @param {jQuery} $node
             * @return {Object}
             */

          }, {
            key: "fromNode",
            value: function fromNode($node) {
              var properties = ['font-family', 'font-size', 'text-align', 'list-style-type', 'line-height'];
              var styleInfo = this.jQueryCSS($node, properties) || {};
              var fontSize = $node[0].style.fontSize || styleInfo['font-size'];
              styleInfo['font-size'] = parseInt(fontSize, 10);
              styleInfo['font-size-unit'] = fontSize.match(/[a-z%]+$/);
              return styleInfo;
            }
            /**
             * paragraph level style
             *
             * @param {WrappedRange} rng
             * @param {Object} styleInfo
             */

          }, {
            key: "stylePara",
            value: function stylePara(rng, styleInfo) {
              external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(rng.nodes(dom.isPara, {
                includeAncestor: true
              }), function (idx, para) {
                external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(para).css(styleInfo);
              });
            }
            /**
             * insert and returns styleNodes on range.
             *
             * @param {WrappedRange} rng
             * @param {Object} [options] - options for styleNodes
             * @param {String} [options.nodeName] - default: `SPAN`
             * @param {Boolean} [options.expandClosestSibling] - default: `false`
             * @param {Boolean} [options.onlyPartialContains] - default: `false`
             * @return {Node[]}
             */

          }, {
            key: "styleNodes",
            value: function styleNodes(rng, options) {
              rng = rng.splitText();
              var nodeName = options && options.nodeName || 'SPAN';
              var expandClosestSibling = !!(options && options.expandClosestSibling);
              var onlyPartialContains = !!(options && options.onlyPartialContains);

              if (rng.isCollapsed()) {
                return [rng.insertNode(dom.create(nodeName))];
              }

              var pred = dom.makePredByNodeName(nodeName);
              var nodes = rng.nodes(dom.isText, {
                fullyContains: true
              }).map(function (text) {
                return dom.singleChildAncestor(text, pred) || dom.wrap(text, nodeName);
              });

              if (expandClosestSibling) {
                if (onlyPartialContains) {
                  var nodesInRange = rng.nodes(); // compose with partial contains predication

                  pred = func.and(pred, function (node) {
                    return lists.contains(nodesInRange, node);
                  });
                }

                return nodes.map(function (node) {
                  var siblings = dom.withClosestSiblings(node, pred);
                  var head = lists.head(siblings);
                  var tails = lists.tail(siblings);
                  external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(tails, function (idx, elem) {
                    dom.appendChildNodes(head, elem.childNodes);
                    dom.remove(elem);
                  });
                  return lists.head(siblings);
                });
              } else {
                return nodes;
              }
            }
            /**
             * get current style on cursor
             *
             * @param {WrappedRange} rng
             * @return {Object} - object contains style properties.
             */

          }, {
            key: "current",
            value: function current(rng) {
              var $cont = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(!dom.isElement(rng.sc) ? rng.sc.parentNode : rng.sc);
              var styleInfo = this.fromNode($cont); // document.queryCommandState for toggle state
              // [workaround] prevent Firefox nsresult: "0x80004005 (NS_ERROR_FAILURE)"

              try {
                styleInfo = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.extend(styleInfo, {
                  'font-bold': document.queryCommandState('bold') ? 'bold' : 'normal',
                  'font-italic': document.queryCommandState('italic') ? 'italic' : 'normal',
                  'font-underline': document.queryCommandState('underline') ? 'underline' : 'normal',
                  'font-subscript': document.queryCommandState('subscript') ? 'subscript' : 'normal',
                  'font-superscript': document.queryCommandState('superscript') ? 'superscript' : 'normal',
                  'font-strikethrough': document.queryCommandState('strikethrough') ? 'strikethrough' : 'normal',
                  'font-family': document.queryCommandValue('fontname') || styleInfo['font-family']
                });
              } catch (e) {} // eslint-disable-next-line
              // list-style-type to list-style(unordered, ordered)


              if (!rng.isOnList()) {
                styleInfo['list-style'] = 'none';
              } else {
                var orderedTypes = ['circle', 'disc', 'disc-leading-zero', 'square'];
                var isUnordered = orderedTypes.indexOf(styleInfo['list-style-type']) > -1;
                styleInfo['list-style'] = isUnordered ? 'unordered' : 'ordered';
              }

              var para = dom.ancestor(rng.sc, dom.isPara);

              if (para && para.style['line-height']) {
                styleInfo['line-height'] = para.style.lineHeight;
              } else {
                var lineHeight = parseInt(styleInfo['line-height'], 10) / parseInt(styleInfo['font-size'], 10);
                styleInfo['line-height'] = lineHeight.toFixed(1);
              }

              styleInfo.anchor = rng.isOnAnchor() && dom.ancestor(rng.sc, dom.isAnchor);
              styleInfo.ancestors = dom.listAncestor(rng.sc, dom.isEditable);
              styleInfo.range = rng;
              return styleInfo;
            }
          }]);
          return Style;
        }(); // CONCATENATED MODULE: ./src/js/base/editing/Bullet.js


        function Bullet_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function Bullet_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function Bullet_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) Bullet_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) Bullet_defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var Bullet_Bullet = /*#__PURE__*/function () {
          function Bullet() {
            Bullet_classCallCheck(this, Bullet);
          }

          Bullet_createClass(Bullet, [{
            key: "insertOrderedList",

            /**
             * toggle ordered list
             */
            value: function insertOrderedList(editable) {
              this.toggleList('OL', editable);
            }
            /**
             * toggle unordered list
             */

          }, {
            key: "insertUnorderedList",
            value: function insertUnorderedList(editable) {
              this.toggleList('UL', editable);
            }
            /**
             * indent
             */

          }, {
            key: "indent",
            value: function indent(editable) {
              var _this = this;

              var rng = range.create(editable).wrapBodyInlineWithPara();
              var paras = rng.nodes(dom.isPara, {
                includeAncestor: true
              });
              var clustereds = lists.clusterBy(paras, func.peq2('parentNode'));
              external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(clustereds, function (idx, paras) {
                var head = lists.head(paras);

                if (dom.isLi(head)) {
                  var previousList = _this.findList(head.previousSibling);

                  if (previousList) {
                    paras.map(function (para) {
                      return previousList.appendChild(para);
                    });
                  } else {
                    _this.wrapList(paras, head.parentNode.nodeName);

                    paras.map(function (para) {
                      return para.parentNode;
                    }).map(function (para) {
                      return _this.appendToPrevious(para);
                    });
                  }
                } else {
                  external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(paras, function (idx, para) {
                    external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(para).css('marginLeft', function (idx, val) {
                      return (parseInt(val, 10) || 0) + 25;
                    });
                  });
                }
              });
              rng.select();
            }
            /**
             * outdent
             */

          }, {
            key: "outdent",
            value: function outdent(editable) {
              var _this2 = this;

              var rng = range.create(editable).wrapBodyInlineWithPara();
              var paras = rng.nodes(dom.isPara, {
                includeAncestor: true
              });
              var clustereds = lists.clusterBy(paras, func.peq2('parentNode'));
              external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(clustereds, function (idx, paras) {
                var head = lists.head(paras);

                if (dom.isLi(head)) {
                  _this2.releaseList([paras]);
                } else {
                  external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(paras, function (idx, para) {
                    external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(para).css('marginLeft', function (idx, val) {
                      val = parseInt(val, 10) || 0;
                      return val > 25 ? val - 25 : '';
                    });
                  });
                }
              });
              rng.select();
            }
            /**
             * toggle list
             *
             * @param {String} listName - OL or UL
             */

          }, {
            key: "toggleList",
            value: function toggleList(listName, editable) {
              var _this3 = this;

              var rng = range.create(editable).wrapBodyInlineWithPara();
              var paras = rng.nodes(dom.isPara, {
                includeAncestor: true
              });
              var bookmark = rng.paraBookmark(paras);
              var clustereds = lists.clusterBy(paras, func.peq2('parentNode')); // paragraph to list

              if (lists.find(paras, dom.isPurePara)) {
                var wrappedParas = [];
                external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(clustereds, function (idx, paras) {
                  wrappedParas = wrappedParas.concat(_this3.wrapList(paras, listName));
                });
                paras = wrappedParas; // list to paragraph or change list style
              } else {
                var diffLists = rng.nodes(dom.isList, {
                  includeAncestor: true
                }).filter(function (listNode) {
                  return !external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.nodeName(listNode, listName);
                });

                if (diffLists.length) {
                  external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(diffLists, function (idx, listNode) {
                    dom.replace(listNode, listName);
                  });
                } else {
                  paras = this.releaseList(clustereds, true);
                }
              }

              range.createFromParaBookmark(bookmark, paras).select();
            }
            /**
             * @param {Node[]} paras
             * @param {String} listName
             * @return {Node[]}
             */

          }, {
            key: "wrapList",
            value: function wrapList(paras, listName) {
              var head = lists.head(paras);
              var last = lists.last(paras);
              var prevList = dom.isList(head.previousSibling) && head.previousSibling;
              var nextList = dom.isList(last.nextSibling) && last.nextSibling;
              var listNode = prevList || dom.insertAfter(dom.create(listName || 'UL'), last); // P to LI

              paras = paras.map(function (para) {
                return dom.isPurePara(para) ? dom.replace(para, 'LI') : para;
              }); // append to list(<ul>, <ol>)

              dom.appendChildNodes(listNode, paras);

              if (nextList) {
                dom.appendChildNodes(listNode, lists.from(nextList.childNodes));
                dom.remove(nextList);
              }

              return paras;
            }
            /**
             * @method releaseList
             *
             * @param {Array[]} clustereds
             * @param {Boolean} isEscapseToBody
             * @return {Node[]}
             */

          }, {
            key: "releaseList",
            value: function releaseList(clustereds, isEscapseToBody) {
              var _this4 = this;

              var releasedParas = [];
              external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(clustereds, function (idx, paras) {
                var head = lists.head(paras);
                var last = lists.last(paras);
                var headList = isEscapseToBody ? dom.lastAncestor(head, dom.isList) : head.parentNode;
                var parentItem = headList.parentNode;

                if (headList.parentNode.nodeName === 'LI') {
                  paras.map(function (para) {
                    var newList = _this4.findNextSiblings(para);

                    if (parentItem.nextSibling) {
                      parentItem.parentNode.insertBefore(para, parentItem.nextSibling);
                    } else {
                      parentItem.parentNode.appendChild(para);
                    }

                    if (newList.length) {
                      _this4.wrapList(newList, headList.nodeName);

                      para.appendChild(newList[0].parentNode);
                    }
                  });

                  if (headList.children.length === 0) {
                    parentItem.removeChild(headList);
                  }

                  if (parentItem.childNodes.length === 0) {
                    parentItem.parentNode.removeChild(parentItem);
                  }
                } else {
                  var lastList = headList.childNodes.length > 1 ? dom.splitTree(headList, {
                    node: last.parentNode,
                    offset: dom.position(last) + 1
                  }, {
                    isSkipPaddingBlankHTML: true
                  }) : null;
                  var middleList = dom.splitTree(headList, {
                    node: head.parentNode,
                    offset: dom.position(head)
                  }, {
                    isSkipPaddingBlankHTML: true
                  });
                  paras = isEscapseToBody ? dom.listDescendant(middleList, dom.isLi) : lists.from(middleList.childNodes).filter(dom.isLi); // LI to P

                  if (isEscapseToBody || !dom.isList(headList.parentNode)) {
                    paras = paras.map(function (para) {
                      return dom.replace(para, 'P');
                    });
                  }

                  external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(lists.from(paras).reverse(), function (idx, para) {
                    dom.insertAfter(para, headList);
                  }); // remove empty lists

                  var rootLists = lists.compact([headList, middleList, lastList]);
                  external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(rootLists, function (idx, rootList) {
                    var listNodes = [rootList].concat(dom.listDescendant(rootList, dom.isList));
                    external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(listNodes.reverse(), function (idx, listNode) {
                      if (!dom.nodeLength(listNode)) {
                        dom.remove(listNode, true);
                      }
                    });
                  });
                }

                releasedParas = releasedParas.concat(paras);
              });
              return releasedParas;
            }
            /**
             * @method appendToPrevious
             *
             * Appends list to previous list item, if
             * none exist it wraps the list in a new list item.
             *
             * @param {HTMLNode} ListItem
             * @return {HTMLNode}
             */

          }, {
            key: "appendToPrevious",
            value: function appendToPrevious(node) {
              return node.previousSibling ? dom.appendChildNodes(node.previousSibling, [node]) : this.wrapList([node], 'LI');
            }
            /**
             * @method findList
             *
             * Finds an existing list in list item
             *
             * @param {HTMLNode} ListItem
             * @return {Array[]}
             */

          }, {
            key: "findList",
            value: function findList(node) {
              return node ? lists.find(node.children, function (child) {
                return ['OL', 'UL'].indexOf(child.nodeName) > -1;
              }) : null;
            }
            /**
             * @method findNextSiblings
             *
             * Finds all list item siblings that follow it
             *
             * @param {HTMLNode} ListItem
             * @return {HTMLNode}
             */

          }, {
            key: "findNextSiblings",
            value: function findNextSiblings(node) {
              var siblings = [];

              while (node.nextSibling) {
                siblings.push(node.nextSibling);
                node = node.nextSibling;
              }

              return siblings;
            }
          }]);
          return Bullet;
        }(); // CONCATENATED MODULE: ./src/js/base/editing/Typing.js


        function Typing_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function Typing_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function Typing_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) Typing_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) Typing_defineProperties(Constructor, staticProps);
          return Constructor;
        }
        /**
         * @class editing.Typing
         *
         * Typing
         *
         */


        var Typing_Typing = /*#__PURE__*/function () {
          function Typing(context) {
            Typing_classCallCheck(this, Typing); // a Bullet instance to toggle lists off

            this.bullet = new Bullet_Bullet();
            this.options = context.options;
          }
          /**
           * insert tab
           *
           * @param {WrappedRange} rng
           * @param {Number} tabsize
           */


          Typing_createClass(Typing, [{
            key: "insertTab",
            value: function insertTab(rng, tabsize) {
              var tab = dom.createText(new Array(tabsize + 1).join(dom.NBSP_CHAR));
              rng = rng.deleteContents();
              rng.insertNode(tab, true);
              rng = range.create(tab, tabsize);
              rng.select();
            }
            /**
             * insert paragraph
             *
             * @param {jQuery} $editable
             * @param {WrappedRange} rng Can be used in unit tests to "mock" the range
             *
             * blockquoteBreakingLevel
             *   0 - No break, the new paragraph remains inside the quote
             *   1 - Break the first blockquote in the ancestors list
             *   2 - Break all blockquotes, so that the new paragraph is not quoted (this is the default)
             */

          }, {
            key: "insertParagraph",
            value: function insertParagraph(editable, rng) {
              rng = rng || range.create(editable); // deleteContents on range.

              rng = rng.deleteContents(); // Wrap range if it needs to be wrapped by paragraph

              rng = rng.wrapBodyInlineWithPara(); // finding paragraph

              var splitRoot = dom.ancestor(rng.sc, dom.isPara);
              var nextPara; // on paragraph: split paragraph

              if (splitRoot) {
                // if it is an empty line with li
                if (dom.isLi(splitRoot) && (dom.isEmpty(splitRoot) || dom.deepestChildIsEmpty(splitRoot))) {
                  // toggle UL/OL and escape
                  this.bullet.toggleList(splitRoot.parentNode.nodeName);
                  return;
                } else {
                  var blockquote = null;

                  if (this.options.blockquoteBreakingLevel === 1) {
                    blockquote = dom.ancestor(splitRoot, dom.isBlockquote);
                  } else if (this.options.blockquoteBreakingLevel === 2) {
                    blockquote = dom.lastAncestor(splitRoot, dom.isBlockquote);
                  }

                  if (blockquote) {
                    // We're inside a blockquote and options ask us to break it
                    nextPara = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(dom.emptyPara)[0]; // If the split is right before a <br>, remove it so that there's no "empty line"
                    // after the split in the new blockquote created

                    if (dom.isRightEdgePoint(rng.getStartPoint()) && dom.isBR(rng.sc.nextSibling)) {
                      external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(rng.sc.nextSibling).remove();
                    }

                    var split = dom.splitTree(blockquote, rng.getStartPoint(), {
                      isDiscardEmptySplits: true
                    });

                    if (split) {
                      split.parentNode.insertBefore(nextPara, split);
                    } else {
                      dom.insertAfter(nextPara, blockquote); // There's no split if we were at the end of the blockquote
                    }
                  } else {
                    nextPara = dom.splitTree(splitRoot, rng.getStartPoint()); // not a blockquote, just insert the paragraph

                    var emptyAnchors = dom.listDescendant(splitRoot, dom.isEmptyAnchor);
                    emptyAnchors = emptyAnchors.concat(dom.listDescendant(nextPara, dom.isEmptyAnchor));
                    external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(emptyAnchors, function (idx, anchor) {
                      dom.remove(anchor);
                    }); // replace empty heading, pre or custom-made styleTag with P tag

                    if ((dom.isHeading(nextPara) || dom.isPre(nextPara) || dom.isCustomStyleTag(nextPara)) && dom.isEmpty(nextPara)) {
                      nextPara = dom.replace(nextPara, 'p');
                    }
                  }
                } // no paragraph: insert empty paragraph

              } else {
                var next = rng.sc.childNodes[rng.so];
                nextPara = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(dom.emptyPara)[0];

                if (next) {
                  rng.sc.insertBefore(nextPara, next);
                } else {
                  rng.sc.appendChild(nextPara);
                }
              }

              range.create(nextPara, 0).normalize().select().scrollIntoView(editable);
            }
          }]);
          return Typing;
        }(); // CONCATENATED MODULE: ./src/js/base/editing/Table.js


        function Table_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function Table_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function Table_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) Table_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) Table_defineProperties(Constructor, staticProps);
          return Constructor;
        }
        /**
         * @class Create a virtual table to create what actions to do in change.
         * @param {object} startPoint Cell selected to apply change.
         * @param {enum} where  Where change will be applied Row or Col. Use enum: TableResultAction.where
         * @param {enum} action Action to be applied. Use enum: TableResultAction.requestAction
         * @param {object} domTable Dom element of table to make changes.
         */


        var TableResultAction = function TableResultAction(startPoint, where, action, domTable) {
          var _startPoint = {
            'colPos': 0,
            'rowPos': 0
          };
          var _virtualTable = [];
          var _actionCellList = []; /// ///////////////////////////////////////////
          // Private functions
          /// ///////////////////////////////////////////

          /**
           * Set the startPoint of action.
           */

          function setStartPoint() {
            if (!startPoint || !startPoint.tagName || startPoint.tagName.toLowerCase() !== 'td' && startPoint.tagName.toLowerCase() !== 'th') {
              // Impossible to identify start Cell point
              return;
            }

            _startPoint.colPos = startPoint.cellIndex;

            if (!startPoint.parentElement || !startPoint.parentElement.tagName || startPoint.parentElement.tagName.toLowerCase() !== 'tr') {
              // Impossible to identify start Row point
              return;
            }

            _startPoint.rowPos = startPoint.parentElement.rowIndex;
          }
          /**
           * Define virtual table position info object.
           *
           * @param {int} rowIndex Index position in line of virtual table.
           * @param {int} cellIndex Index position in column of virtual table.
           * @param {object} baseRow Row affected by this position.
           * @param {object} baseCell Cell affected by this position.
           * @param {bool} isSpan Inform if it is an span cell/row.
           */


          function setVirtualTablePosition(rowIndex, cellIndex, baseRow, baseCell, isRowSpan, isColSpan, isVirtualCell) {
            var objPosition = {
              'baseRow': baseRow,
              'baseCell': baseCell,
              'isRowSpan': isRowSpan,
              'isColSpan': isColSpan,
              'isVirtual': isVirtualCell
            };

            if (!_virtualTable[rowIndex]) {
              _virtualTable[rowIndex] = [];
            }

            _virtualTable[rowIndex][cellIndex] = objPosition;
          }
          /**
           * Create action cell object.
           *
           * @param {object} virtualTableCellObj Object of specific position on virtual table.
           * @param {enum} resultAction Action to be applied in that item.
           */


          function getActionCell(virtualTableCellObj, resultAction, virtualRowPosition, virtualColPosition) {
            return {
              'baseCell': virtualTableCellObj.baseCell,
              'action': resultAction,
              'virtualTable': {
                'rowIndex': virtualRowPosition,
                'cellIndex': virtualColPosition
              }
            };
          }
          /**
           * Recover free index of row to append Cell.
           *
           * @param {int} rowIndex Index of row to find free space.
           * @param {int} cellIndex Index of cell to find free space in table.
           */


          function recoverCellIndex(rowIndex, cellIndex) {
            if (!_virtualTable[rowIndex]) {
              return cellIndex;
            }

            if (!_virtualTable[rowIndex][cellIndex]) {
              return cellIndex;
            }

            var newCellIndex = cellIndex;

            while (_virtualTable[rowIndex][newCellIndex]) {
              newCellIndex++;

              if (!_virtualTable[rowIndex][newCellIndex]) {
                return newCellIndex;
              }
            }
          }
          /**
           * Recover info about row and cell and add information to virtual table.
           *
           * @param {object} row Row to recover information.
           * @param {object} cell Cell to recover information.
           */


          function addCellInfoToVirtual(row, cell) {
            var cellIndex = recoverCellIndex(row.rowIndex, cell.cellIndex);
            var cellHasColspan = cell.colSpan > 1;
            var cellHasRowspan = cell.rowSpan > 1;
            var isThisSelectedCell = row.rowIndex === _startPoint.rowPos && cell.cellIndex === _startPoint.colPos;
            setVirtualTablePosition(row.rowIndex, cellIndex, row, cell, cellHasRowspan, cellHasColspan, false); // Add span rows to virtual Table.

            var rowspanNumber = cell.attributes.rowSpan ? parseInt(cell.attributes.rowSpan.value, 10) : 0;

            if (rowspanNumber > 1) {
              for (var rp = 1; rp < rowspanNumber; rp++) {
                var rowspanIndex = row.rowIndex + rp;
                adjustStartPoint(rowspanIndex, cellIndex, cell, isThisSelectedCell);
                setVirtualTablePosition(rowspanIndex, cellIndex, row, cell, true, cellHasColspan, true);
              }
            } // Add span cols to virtual table.


            var colspanNumber = cell.attributes.colSpan ? parseInt(cell.attributes.colSpan.value, 10) : 0;

            if (colspanNumber > 1) {
              for (var cp = 1; cp < colspanNumber; cp++) {
                var cellspanIndex = recoverCellIndex(row.rowIndex, cellIndex + cp);
                adjustStartPoint(row.rowIndex, cellspanIndex, cell, isThisSelectedCell);
                setVirtualTablePosition(row.rowIndex, cellspanIndex, row, cell, cellHasRowspan, true, true);
              }
            }
          }
          /**
           * Process validation and adjust of start point if needed
           *
           * @param {int} rowIndex
           * @param {int} cellIndex
           * @param {object} cell
           * @param {bool} isSelectedCell
           */


          function adjustStartPoint(rowIndex, cellIndex, cell, isSelectedCell) {
            if (rowIndex === _startPoint.rowPos && _startPoint.colPos >= cell.cellIndex && cell.cellIndex <= cellIndex && !isSelectedCell) {
              _startPoint.colPos++;
            }
          }
          /**
           * Create virtual table of cells with all cells, including span cells.
           */


          function createVirtualTable() {
            var rows = domTable.rows;

            for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
              var cells = rows[rowIndex].cells;

              for (var cellIndex = 0; cellIndex < cells.length; cellIndex++) {
                addCellInfoToVirtual(rows[rowIndex], cells[cellIndex]);
              }
            }
          }
          /**
           * Get action to be applied on the cell.
           *
           * @param {object} cell virtual table cell to apply action
           */


          function getDeleteResultActionToCell(cell) {
            switch (where) {
              case TableResultAction.where.Column:
                if (cell.isColSpan) {
                  return TableResultAction.resultAction.SubtractSpanCount;
                }

                break;

              case TableResultAction.where.Row:
                if (!cell.isVirtual && cell.isRowSpan) {
                  return TableResultAction.resultAction.AddCell;
                } else if (cell.isRowSpan) {
                  return TableResultAction.resultAction.SubtractSpanCount;
                }

                break;
            }

            return TableResultAction.resultAction.RemoveCell;
          }
          /**
           * Get action to be applied on the cell.
           *
           * @param {object} cell virtual table cell to apply action
           */


          function getAddResultActionToCell(cell) {
            switch (where) {
              case TableResultAction.where.Column:
                if (cell.isColSpan) {
                  return TableResultAction.resultAction.SumSpanCount;
                } else if (cell.isRowSpan && cell.isVirtual) {
                  return TableResultAction.resultAction.Ignore;
                }

                break;

              case TableResultAction.where.Row:
                if (cell.isRowSpan) {
                  return TableResultAction.resultAction.SumSpanCount;
                } else if (cell.isColSpan && cell.isVirtual) {
                  return TableResultAction.resultAction.Ignore;
                }

                break;
            }

            return TableResultAction.resultAction.AddCell;
          }

          function init() {
            setStartPoint();
            createVirtualTable();
          } /// ///////////////////////////////////////////
          // Public functions
          /// ///////////////////////////////////////////

          /**
           * Recover array os what to do in table.
           */


          this.getActionList = function () {
            var fixedRow = where === TableResultAction.where.Row ? _startPoint.rowPos : -1;
            var fixedCol = where === TableResultAction.where.Column ? _startPoint.colPos : -1;
            var actualPosition = 0;
            var canContinue = true;

            while (canContinue) {
              var rowPosition = fixedRow >= 0 ? fixedRow : actualPosition;
              var colPosition = fixedCol >= 0 ? fixedCol : actualPosition;
              var row = _virtualTable[rowPosition];

              if (!row) {
                canContinue = false;
                return _actionCellList;
              }

              var cell = row[colPosition];

              if (!cell) {
                canContinue = false;
                return _actionCellList;
              } // Define action to be applied in this cell


              var resultAction = TableResultAction.resultAction.Ignore;

              switch (action) {
                case TableResultAction.requestAction.Add:
                  resultAction = getAddResultActionToCell(cell);
                  break;

                case TableResultAction.requestAction.Delete:
                  resultAction = getDeleteResultActionToCell(cell);
                  break;
              }

              _actionCellList.push(getActionCell(cell, resultAction, rowPosition, colPosition));

              actualPosition++;
            }

            return _actionCellList;
          };

          init();
        };
        /**
        *
        * Where action occours enum.
        */


        TableResultAction.where = {
          'Row': 0,
          'Column': 1
        };
        /**
        *
        * Requested action to apply enum.
        */

        TableResultAction.requestAction = {
          'Add': 0,
          'Delete': 1
        };
        /**
        *
        * Result action to be executed enum.
        */

        TableResultAction.resultAction = {
          'Ignore': 0,
          'SubtractSpanCount': 1,
          'RemoveCell': 2,
          'AddCell': 3,
          'SumSpanCount': 4
        };
        /**
         *
         * @class editing.Table
         *
         * Table
         *
         */

        var Table_Table = /*#__PURE__*/function () {
          function Table() {
            Table_classCallCheck(this, Table);
          }

          Table_createClass(Table, [{
            key: "tab",

            /**
             * handle tab key
             *
             * @param {WrappedRange} rng
             * @param {Boolean} isShift
             */
            value: function tab(rng, isShift) {
              var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
              var table = dom.ancestor(cell, dom.isTable);
              var cells = dom.listDescendant(table, dom.isCell);
              var nextCell = lists[isShift ? 'prev' : 'next'](cells, cell);

              if (nextCell) {
                range.create(nextCell, 0).select();
              }
            }
            /**
             * Add a new row
             *
             * @param {WrappedRange} rng
             * @param {String} position (top/bottom)
             * @return {Node}
             */

          }, {
            key: "addRow",
            value: function addRow(rng, position) {
              var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
              var currentTr = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(cell).closest('tr');
              var trAttributes = this.recoverAttributes(currentTr);
              var html = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<tr' + trAttributes + '></tr>');
              var vTable = new TableResultAction(cell, TableResultAction.where.Row, TableResultAction.requestAction.Add, external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(currentTr).closest('table')[0]);
              var actions = vTable.getActionList();

              for (var idCell = 0; idCell < actions.length; idCell++) {
                var currentCell = actions[idCell];
                var tdAttributes = this.recoverAttributes(currentCell.baseCell);

                switch (currentCell.action) {
                  case TableResultAction.resultAction.AddCell:
                    html.append('<td' + tdAttributes + '>' + dom.blank + '</td>');
                    break;

                  case TableResultAction.resultAction.SumSpanCount:
                    {
                      if (position === 'top') {
                        var baseCellTr = currentCell.baseCell.parent;
                        var isTopFromRowSpan = (!baseCellTr ? 0 : currentCell.baseCell.closest('tr').rowIndex) <= currentTr[0].rowIndex;

                        if (isTopFromRowSpan) {
                          var newTd = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<div></div>').append(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<td' + tdAttributes + '>' + dom.blank + '</td>').removeAttr('rowspan')).html();
                          html.append(newTd);
                          break;
                        }
                      }

                      var rowspanNumber = parseInt(currentCell.baseCell.rowSpan, 10);
                      rowspanNumber++;
                      currentCell.baseCell.setAttribute('rowSpan', rowspanNumber);
                    }
                    break;
                }
              }

              if (position === 'top') {
                currentTr.before(html);
              } else {
                var cellHasRowspan = cell.rowSpan > 1;

                if (cellHasRowspan) {
                  var lastTrIndex = currentTr[0].rowIndex + (cell.rowSpan - 2);
                  external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(currentTr).parent().find('tr')[lastTrIndex]).after(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(html));
                  return;
                }

                currentTr.after(html);
              }
            }
            /**
             * Add a new col
             *
             * @param {WrappedRange} rng
             * @param {String} position (left/right)
             * @return {Node}
             */

          }, {
            key: "addCol",
            value: function addCol(rng, position) {
              var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
              var row = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(cell).closest('tr');
              var rowsGroup = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(row).siblings();
              rowsGroup.push(row);
              var vTable = new TableResultAction(cell, TableResultAction.where.Column, TableResultAction.requestAction.Add, external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(row).closest('table')[0]);
              var actions = vTable.getActionList();

              for (var actionIndex = 0; actionIndex < actions.length; actionIndex++) {
                var currentCell = actions[actionIndex];
                var tdAttributes = this.recoverAttributes(currentCell.baseCell);

                switch (currentCell.action) {
                  case TableResultAction.resultAction.AddCell:
                    if (position === 'right') {
                      external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(currentCell.baseCell).after('<td' + tdAttributes + '>' + dom.blank + '</td>');
                    } else {
                      external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(currentCell.baseCell).before('<td' + tdAttributes + '>' + dom.blank + '</td>');
                    }

                    break;

                  case TableResultAction.resultAction.SumSpanCount:
                    if (position === 'right') {
                      var colspanNumber = parseInt(currentCell.baseCell.colSpan, 10);
                      colspanNumber++;
                      currentCell.baseCell.setAttribute('colSpan', colspanNumber);
                    } else {
                      external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(currentCell.baseCell).before('<td' + tdAttributes + '>' + dom.blank + '</td>');
                    }

                    break;
                }
              }
            }
            /*
            * Copy attributes from element.
            *
            * @param {object} Element to recover attributes.
            * @return {string} Copied string elements.
            */

          }, {
            key: "recoverAttributes",
            value: function recoverAttributes(el) {
              var resultStr = '';

              if (!el) {
                return resultStr;
              }

              var attrList = el.attributes || [];

              for (var i = 0; i < attrList.length; i++) {
                if (attrList[i].name.toLowerCase() === 'id') {
                  continue;
                }

                if (attrList[i].specified) {
                  resultStr += ' ' + attrList[i].name + '=\'' + attrList[i].value + '\'';
                }
              }

              return resultStr;
            }
            /**
             * Delete current row
             *
             * @param {WrappedRange} rng
             * @return {Node}
             */

          }, {
            key: "deleteRow",
            value: function deleteRow(rng) {
              var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
              var row = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(cell).closest('tr');
              var cellPos = row.children('td, th').index(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(cell));
              var rowPos = row[0].rowIndex;
              var vTable = new TableResultAction(cell, TableResultAction.where.Row, TableResultAction.requestAction.Delete, external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(row).closest('table')[0]);
              var actions = vTable.getActionList();

              for (var actionIndex = 0; actionIndex < actions.length; actionIndex++) {
                if (!actions[actionIndex]) {
                  continue;
                }

                var baseCell = actions[actionIndex].baseCell;
                var virtualPosition = actions[actionIndex].virtualTable;
                var hasRowspan = baseCell.rowSpan && baseCell.rowSpan > 1;
                var rowspanNumber = hasRowspan ? parseInt(baseCell.rowSpan, 10) : 0;

                switch (actions[actionIndex].action) {
                  case TableResultAction.resultAction.Ignore:
                    continue;

                  case TableResultAction.resultAction.AddCell:
                    {
                      var nextRow = row.next('tr')[0];

                      if (!nextRow) {
                        continue;
                      }

                      var cloneRow = row[0].cells[cellPos];

                      if (hasRowspan) {
                        if (rowspanNumber > 2) {
                          rowspanNumber--;
                          nextRow.insertBefore(cloneRow, nextRow.cells[cellPos]);
                          nextRow.cells[cellPos].setAttribute('rowSpan', rowspanNumber);
                          nextRow.cells[cellPos].innerHTML = '';
                        } else if (rowspanNumber === 2) {
                          nextRow.insertBefore(cloneRow, nextRow.cells[cellPos]);
                          nextRow.cells[cellPos].removeAttribute('rowSpan');
                          nextRow.cells[cellPos].innerHTML = '';
                        }
                      }
                    }
                    continue;

                  case TableResultAction.resultAction.SubtractSpanCount:
                    if (hasRowspan) {
                      if (rowspanNumber > 2) {
                        rowspanNumber--;
                        baseCell.setAttribute('rowSpan', rowspanNumber);

                        if (virtualPosition.rowIndex !== rowPos && baseCell.cellIndex === cellPos) {
                          baseCell.innerHTML = '';
                        }
                      } else if (rowspanNumber === 2) {
                        baseCell.removeAttribute('rowSpan');

                        if (virtualPosition.rowIndex !== rowPos && baseCell.cellIndex === cellPos) {
                          baseCell.innerHTML = '';
                        }
                      }
                    }

                    continue;

                  case TableResultAction.resultAction.RemoveCell:
                    // Do not need remove cell because row will be deleted.
                    continue;
                }
              }

              row.remove();
            }
            /**
             * Delete current col
             *
             * @param {WrappedRange} rng
             * @return {Node}
             */

          }, {
            key: "deleteCol",
            value: function deleteCol(rng) {
              var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
              var row = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(cell).closest('tr');
              var cellPos = row.children('td, th').index(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(cell));
              var vTable = new TableResultAction(cell, TableResultAction.where.Column, TableResultAction.requestAction.Delete, external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(row).closest('table')[0]);
              var actions = vTable.getActionList();

              for (var actionIndex = 0; actionIndex < actions.length; actionIndex++) {
                if (!actions[actionIndex]) {
                  continue;
                }

                switch (actions[actionIndex].action) {
                  case TableResultAction.resultAction.Ignore:
                    continue;

                  case TableResultAction.resultAction.SubtractSpanCount:
                    {
                      var baseCell = actions[actionIndex].baseCell;
                      var hasColspan = baseCell.colSpan && baseCell.colSpan > 1;

                      if (hasColspan) {
                        var colspanNumber = baseCell.colSpan ? parseInt(baseCell.colSpan, 10) : 0;

                        if (colspanNumber > 2) {
                          colspanNumber--;
                          baseCell.setAttribute('colSpan', colspanNumber);

                          if (baseCell.cellIndex === cellPos) {
                            baseCell.innerHTML = '';
                          }
                        } else if (colspanNumber === 2) {
                          baseCell.removeAttribute('colSpan');

                          if (baseCell.cellIndex === cellPos) {
                            baseCell.innerHTML = '';
                          }
                        }
                      }
                    }
                    continue;

                  case TableResultAction.resultAction.RemoveCell:
                    dom.remove(actions[actionIndex].baseCell, true);
                    continue;
                }
              }
            }
            /**
             * create empty table element
             *
             * @param {Number} rowCount
             * @param {Number} colCount
             * @return {Node}
             */

          }, {
            key: "createTable",
            value: function createTable(colCount, rowCount, options) {
              var tds = [];
              var tdHTML;

              for (var idxCol = 0; idxCol < colCount; idxCol++) {
                tds.push('<td>' + dom.blank + '</td>');
              }

              tdHTML = tds.join('');
              var trs = [];
              var trHTML;

              for (var idxRow = 0; idxRow < rowCount; idxRow++) {
                trs.push('<tr>' + tdHTML + '</tr>');
              }

              trHTML = trs.join('');
              var $table = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<table>' + trHTML + '</table>');

              if (options && options.tableClassName) {
                $table.addClass(options.tableClassName);
              }

              return $table[0];
            }
            /**
             * Delete current table
             *
             * @param {WrappedRange} rng
             * @return {Node}
             */

          }, {
            key: "deleteTable",
            value: function deleteTable(rng) {
              var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
              external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(cell).closest('table').remove();
            }
          }]);
          return Table;
        }(); // CONCATENATED MODULE: ./src/js/base/module/Editor.js


        function Editor_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function Editor_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function Editor_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) Editor_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) Editor_defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var KEY_BOGUS = 'bogus';
        /**
         * @class Editor
         */

        var Editor_Editor = /*#__PURE__*/function () {
          function Editor(context) {
            var _this = this;

            Editor_classCallCheck(this, Editor);
            this.context = context;
            this.$note = context.layoutInfo.note;
            this.$editor = context.layoutInfo.editor;
            this.$editable = context.layoutInfo.editable;
            this.options = context.options;
            this.lang = this.options.langInfo;
            this.editable = this.$editable[0];
            this.lastRange = null;
            this.snapshot = null;
            this.style = new Style_Style();
            this.table = new Table_Table();
            this.typing = new Typing_Typing(context);
            this.bullet = new Bullet_Bullet();
            this.history = new History_History(context);
            this.context.memo('help.escape', this.lang.help.escape);
            this.context.memo('help.undo', this.lang.help.undo);
            this.context.memo('help.redo', this.lang.help.redo);
            this.context.memo('help.tab', this.lang.help.tab);
            this.context.memo('help.untab', this.lang.help.untab);
            this.context.memo('help.insertParagraph', this.lang.help.insertParagraph);
            this.context.memo('help.insertOrderedList', this.lang.help.insertOrderedList);
            this.context.memo('help.insertUnorderedList', this.lang.help.insertUnorderedList);
            this.context.memo('help.indent', this.lang.help.indent);
            this.context.memo('help.outdent', this.lang.help.outdent);
            this.context.memo('help.formatPara', this.lang.help.formatPara);
            this.context.memo('help.insertHorizontalRule', this.lang.help.insertHorizontalRule);
            this.context.memo('help.fontName', this.lang.help.fontName); // native commands(with execCommand), generate function for execCommand

            var commands = ['bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript', 'justifyLeft', 'justifyCenter', 'justifyRight', 'justifyFull', 'formatBlock', 'removeFormat', 'backColor'];

            for (var idx = 0, len = commands.length; idx < len; idx++) {
              this[commands[idx]] = function (sCmd) {
                return function (value) {
                  _this.beforeCommand();

                  document.execCommand(sCmd, false, value);

                  _this.afterCommand(true);
                };
              }(commands[idx]);

              this.context.memo('help.' + commands[idx], this.lang.help[commands[idx]]);
            }

            this.fontName = this.wrapCommand(function (value) {
              return _this.fontStyling('font-family', env.validFontName(value));
            });
            this.fontSize = this.wrapCommand(function (value) {
              var unit = _this.currentStyle()['font-size-unit'];

              return _this.fontStyling('font-size', value + unit);
            });
            this.fontSizeUnit = this.wrapCommand(function (value) {
              var size = _this.currentStyle()['font-size'];

              return _this.fontStyling('font-size', size + value);
            });

            for (var _idx = 1; _idx <= 6; _idx++) {
              this['formatH' + _idx] = function (idx) {
                return function () {
                  _this.formatBlock('H' + idx);
                };
              }(_idx);

              this.context.memo('help.formatH' + _idx, this.lang.help['formatH' + _idx]);
            }

            this.insertParagraph = this.wrapCommand(function () {
              _this.typing.insertParagraph(_this.editable);
            });
            this.insertOrderedList = this.wrapCommand(function () {
              _this.bullet.insertOrderedList(_this.editable);
            });
            this.insertUnorderedList = this.wrapCommand(function () {
              _this.bullet.insertUnorderedList(_this.editable);
            });
            this.indent = this.wrapCommand(function () {
              _this.bullet.indent(_this.editable);
            });
            this.outdent = this.wrapCommand(function () {
              _this.bullet.outdent(_this.editable);
            });
            /**
             * insertNode
             * insert node
             * @param {Node} node
             */

            this.insertNode = this.wrapCommand(function (node) {
              if (_this.isLimited(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(node).text().length)) {
                return;
              }

              var rng = _this.getLastRange();

              rng.insertNode(node);

              _this.setLastRange(range.createFromNodeAfter(node).select());
            });
            /**
             * insert text
             * @param {String} text
             */

            this.insertText = this.wrapCommand(function (text) {
              if (_this.isLimited(text.length)) {
                return;
              }

              var rng = _this.getLastRange();

              var textNode = rng.insertNode(dom.createText(text));

              _this.setLastRange(range.create(textNode, dom.nodeLength(textNode)).select());
            });
            /**
             * paste HTML
             * @param {String} markup
             */

            this.pasteHTML = this.wrapCommand(function (markup) {
              if (_this.isLimited(markup.length)) {
                return;
              }

              markup = _this.context.invoke('codeview.purify', markup);

              var contents = _this.getLastRange().pasteHTML(markup);

              _this.setLastRange(range.createFromNodeAfter(lists.last(contents)).select());
            });
            /**
             * formatBlock
             *
             * @param {String} tagName
             */

            this.formatBlock = this.wrapCommand(function (tagName, $target) {
              var onApplyCustomStyle = _this.options.callbacks.onApplyCustomStyle;

              if (onApplyCustomStyle) {
                onApplyCustomStyle.call(_this, $target, _this.context, _this.onFormatBlock);
              } else {
                _this.onFormatBlock(tagName, $target);
              }
            });
            /**
             * insert horizontal rule
             */

            this.insertHorizontalRule = this.wrapCommand(function () {
              var hrNode = _this.getLastRange().insertNode(dom.create('HR'));

              if (hrNode.nextSibling) {
                _this.setLastRange(range.create(hrNode.nextSibling, 0).normalize().select());
              }
            });
            /**
             * lineHeight
             * @param {String} value
             */

            this.lineHeight = this.wrapCommand(function (value) {
              _this.style.stylePara(_this.getLastRange(), {
                lineHeight: value
              });
            });
            /**
             * create link (command)
             *
             * @param {Object} linkInfo
             */

            this.createLink = this.wrapCommand(function (linkInfo) {
              var linkUrl = linkInfo.url;
              var linkText = linkInfo.text;
              var isNewWindow = linkInfo.isNewWindow;
              var checkProtocol = linkInfo.checkProtocol;

              var rng = linkInfo.range || _this.getLastRange();

              var additionalTextLength = linkText.length - rng.toString().length;

              if (additionalTextLength > 0 && _this.isLimited(additionalTextLength)) {
                return;
              }

              var isTextChanged = rng.toString() !== linkText; // handle spaced urls from input

              if (typeof linkUrl === 'string') {
                linkUrl = linkUrl.trim();
              }

              if (_this.options.onCreateLink) {
                linkUrl = _this.options.onCreateLink(linkUrl);
              } else if (checkProtocol) {
                // if url doesn't have any protocol and not even a relative or a label, use http:// as default
                linkUrl = /^([A-Za-z][A-Za-z0-9+-.]*\:|#|\/)/.test(linkUrl) ? linkUrl : _this.options.defaultProtocol + linkUrl;
              }

              var anchors = [];

              if (isTextChanged) {
                rng = rng.deleteContents();
                var anchor = rng.insertNode(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<A>' + linkText + '</A>')[0]);
                anchors.push(anchor);
              } else {
                anchors = _this.style.styleNodes(rng, {
                  nodeName: 'A',
                  expandClosestSibling: true,
                  onlyPartialContains: true
                });
              }

              external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(anchors, function (idx, anchor) {
                external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(anchor).attr('href', linkUrl);

                if (isNewWindow) {
                  external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(anchor).attr('target', '_blank');
                } else {
                  external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(anchor).removeAttr('target');
                }
              });

              _this.setLastRange(_this.createRangeFromList(anchors).select());
            });
            /**
             * setting color
             *
             * @param {Object} sObjColor  color code
             * @param {String} sObjColor.foreColor foreground color
             * @param {String} sObjColor.backColor background color
             */

            this.color = this.wrapCommand(function (colorInfo) {
              var foreColor = colorInfo.foreColor;
              var backColor = colorInfo.backColor;

              if (foreColor) {
                document.execCommand('foreColor', false, foreColor);
              }

              if (backColor) {
                document.execCommand('backColor', false, backColor);
              }
            });
            /**
             * Set foreground color
             *
             * @param {String} colorCode foreground color code
             */

            this.foreColor = this.wrapCommand(function (colorInfo) {
              document.execCommand('foreColor', false, colorInfo);
            });
            /**
             * insert Table
             *
             * @param {String} dimension of table (ex : "5x5")
             */

            this.insertTable = this.wrapCommand(function (dim) {
              var dimension = dim.split('x');

              var rng = _this.getLastRange().deleteContents();

              rng.insertNode(_this.table.createTable(dimension[0], dimension[1], _this.options));
            });
            /**
             * remove media object and Figure Elements if media object is img with Figure.
             */

            this.removeMedia = this.wrapCommand(function () {
              var $target = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(_this.restoreTarget()).parent();

              if ($target.closest('figure').length) {
                $target.closest('figure').remove();
              } else {
                $target = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(_this.restoreTarget()).detach();
              }

              _this.context.triggerEvent('media.delete', $target, _this.$editable);
            });
            /**
             * float me
             *
             * @param {String} value
             */

            this.floatMe = this.wrapCommand(function (value) {
              var $target = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(_this.restoreTarget());
              $target.toggleClass('note-float-left', value === 'left');
              $target.toggleClass('note-float-right', value === 'right');
              $target.css('float', value === 'none' ? '' : value);
            });
            /**
             * resize overlay element
             * @param {String} value
             */

            this.resize = this.wrapCommand(function (value) {
              var $target = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(_this.restoreTarget());
              value = parseFloat(value);

              if (value === 0) {
                $target.css('width', '');
              } else {
                $target.css({
                  width: value * 100 + '%',
                  height: ''
                });
              }
            });
          }

          Editor_createClass(Editor, [{
            key: "initialize",
            value: function initialize() {
              var _this2 = this; // bind custom events


              this.$editable.on('keydown', function (event) {
                if (event.keyCode === core_key.code.ENTER) {
                  _this2.context.triggerEvent('enter', event);
                }

                _this2.context.triggerEvent('keydown', event); // keep a snapshot to limit text on input event


                _this2.snapshot = _this2.history.makeSnapshot();
                _this2.hasKeyShortCut = false;

                if (!event.isDefaultPrevented()) {
                  if (_this2.options.shortcuts) {
                    _this2.hasKeyShortCut = _this2.handleKeyMap(event);
                  } else {
                    _this2.preventDefaultEditableShortCuts(event);
                  }
                }

                if (_this2.isLimited(1, event)) {
                  var lastRange = _this2.getLastRange();

                  if (lastRange.eo - lastRange.so === 0) {
                    return false;
                  }
                }

                _this2.setLastRange(); // record undo in the key event except keyMap.


                if (_this2.options.recordEveryKeystroke) {
                  if (_this2.hasKeyShortCut === false) {
                    _this2.history.recordUndo();
                  }
                }
              }).on('keyup', function (event) {
                _this2.setLastRange();

                _this2.context.triggerEvent('keyup', event);
              }).on('focus', function (event) {
                _this2.setLastRange();

                _this2.context.triggerEvent('focus', event);
              }).on('blur', function (event) {
                _this2.context.triggerEvent('blur', event);
              }).on('mousedown', function (event) {
                _this2.context.triggerEvent('mousedown', event);
              }).on('mouseup', function (event) {
                _this2.setLastRange();

                _this2.history.recordUndo();

                _this2.context.triggerEvent('mouseup', event);
              }).on('scroll', function (event) {
                _this2.context.triggerEvent('scroll', event);
              }).on('paste', function (event) {
                _this2.setLastRange();

                _this2.context.triggerEvent('paste', event);
              }).on('input', function () {
                // To limit composition characters (e.g. Korean)
                if (_this2.isLimited(0) && _this2.snapshot) {
                  _this2.history.applySnapshot(_this2.snapshot);
                }
              });
              this.$editable.attr('spellcheck', this.options.spellCheck);
              this.$editable.attr('autocorrect', this.options.spellCheck);

              if (this.options.disableGrammar) {
                this.$editable.attr('data-gramm', false);
              } // init content before set event


              this.$editable.html(dom.html(this.$note) || dom.emptyPara);
              this.$editable.on(env.inputEventName, func.debounce(function () {
                _this2.context.triggerEvent('change', _this2.$editable.html(), _this2.$editable);
              }, 10));
              this.$editable.on('focusin', function (event) {
                _this2.context.triggerEvent('focusin', event);
              }).on('focusout', function (event) {
                _this2.context.triggerEvent('focusout', event);
              });

              if (this.options.airMode) {
                if (this.options.overrideContextMenu) {
                  this.$editor.on('contextmenu', function (event) {
                    _this2.context.triggerEvent('contextmenu', event);

                    return false;
                  });
                }
              } else {
                if (this.options.width) {
                  this.$editor.outerWidth(this.options.width);
                }

                if (this.options.height) {
                  this.$editable.outerHeight(this.options.height);
                }

                if (this.options.maxHeight) {
                  this.$editable.css('max-height', this.options.maxHeight);
                }

                if (this.options.minHeight) {
                  this.$editable.css('min-height', this.options.minHeight);
                }
              }

              this.history.recordUndo();
              this.setLastRange();
            }
          }, {
            key: "destroy",
            value: function destroy() {
              this.$editable.off();
            }
          }, {
            key: "handleKeyMap",
            value: function handleKeyMap(event) {
              var keyMap = this.options.keyMap[env.isMac ? 'mac' : 'pc'];
              var keys = [];

              if (event.metaKey) {
                keys.push('CMD');
              }

              if (event.ctrlKey && !event.altKey) {
                keys.push('CTRL');
              }

              if (event.shiftKey) {
                keys.push('SHIFT');
              }

              var keyName = core_key.nameFromCode[event.keyCode];

              if (keyName) {
                keys.push(keyName);
              }

              var eventName = keyMap[keys.join('+')];

              if (keyName === 'TAB' && !this.options.tabDisable) {
                this.afterCommand();
              } else if (eventName) {
                if (this.context.invoke(eventName) !== false) {
                  event.preventDefault(); // if keyMap action was invoked

                  return true;
                }
              } else if (core_key.isEdit(event.keyCode)) {
                this.afterCommand();
              }

              return false;
            }
          }, {
            key: "preventDefaultEditableShortCuts",
            value: function preventDefaultEditableShortCuts(event) {
              // B(Bold, 66) / I(Italic, 73) / U(Underline, 85)
              if ((event.ctrlKey || event.metaKey) && lists.contains([66, 73, 85], event.keyCode)) {
                event.preventDefault();
              }
            }
          }, {
            key: "isLimited",
            value: function isLimited(pad, event) {
              pad = pad || 0;

              if (typeof event !== 'undefined') {
                if (core_key.isMove(event.keyCode) || core_key.isNavigation(event.keyCode) || event.ctrlKey || event.metaKey || lists.contains([core_key.code.BACKSPACE, core_key.code.DELETE], event.keyCode)) {
                  return false;
                }
              }

              if (this.options.maxTextLength > 0) {
                if (this.$editable.text().length + pad > this.options.maxTextLength) {
                  return true;
                }
              }

              return false;
            }
            /**
             * create range
             * @return {WrappedRange}
             */

          }, {
            key: "createRange",
            value: function createRange() {
              this.focus();
              this.setLastRange();
              return this.getLastRange();
            }
            /**
             * create a new range from the list of elements
             *
             * @param {list} dom element list
             * @return {WrappedRange}
             */

          }, {
            key: "createRangeFromList",
            value: function createRangeFromList(lst) {
              var startRange = range.createFromNodeBefore(lists.head(lst));
              var startPoint = startRange.getStartPoint();
              var endRange = range.createFromNodeAfter(lists.last(lst));
              var endPoint = endRange.getEndPoint();
              return range.create(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset);
            }
            /**
             * set the last range
             *
             * if given rng is exist, set rng as the last range
             * or create a new range at the end of the document
             *
             * @param {WrappedRange} rng
             */

          }, {
            key: "setLastRange",
            value: function setLastRange(rng) {
              if (rng) {
                this.lastRange = rng;
              } else {
                this.lastRange = range.create(this.editable);

                if (external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(this.lastRange.sc).closest('.note-editable').length === 0) {
                  this.lastRange = range.createFromBodyElement(this.editable);
                }
              }
            }
            /**
             * get the last range
             *
             * if there is a saved last range, return it
             * or create a new range and return it
             *
             * @return {WrappedRange}
             */

          }, {
            key: "getLastRange",
            value: function getLastRange() {
              if (!this.lastRange) {
                this.setLastRange();
              }

              return this.lastRange;
            }
            /**
             * saveRange
             *
             * save current range
             *
             * @param {Boolean} [thenCollapse=false]
             */

          }, {
            key: "saveRange",
            value: function saveRange(thenCollapse) {
              if (thenCollapse) {
                this.getLastRange().collapse().select();
              }
            }
            /**
             * restoreRange
             *
             * restore lately range
             */

          }, {
            key: "restoreRange",
            value: function restoreRange() {
              if (this.lastRange) {
                this.lastRange.select();
                this.focus();
              }
            }
          }, {
            key: "saveTarget",
            value: function saveTarget(node) {
              this.$editable.data('target', node);
            }
          }, {
            key: "clearTarget",
            value: function clearTarget() {
              this.$editable.removeData('target');
            }
          }, {
            key: "restoreTarget",
            value: function restoreTarget() {
              return this.$editable.data('target');
            }
            /**
             * currentStyle
             *
             * current style
             * @return {Object|Boolean} unfocus
             */

          }, {
            key: "currentStyle",
            value: function currentStyle() {
              var rng = range.create();

              if (rng) {
                rng = rng.normalize();
              }

              return rng ? this.style.current(rng) : this.style.fromNode(this.$editable);
            }
            /**
             * style from node
             *
             * @param {jQuery} $node
             * @return {Object}
             */

          }, {
            key: "styleFromNode",
            value: function styleFromNode($node) {
              return this.style.fromNode($node);
            }
            /**
             * undo
             */

          }, {
            key: "undo",
            value: function undo() {
              this.context.triggerEvent('before.command', this.$editable.html());
              this.history.undo();
              this.context.triggerEvent('change', this.$editable.html(), this.$editable);
            }
            /*
            * commit
            */

          }, {
            key: "commit",
            value: function commit() {
              this.context.triggerEvent('before.command', this.$editable.html());
              this.history.commit();
              this.context.triggerEvent('change', this.$editable.html(), this.$editable);
            }
            /**
             * redo
             */

          }, {
            key: "redo",
            value: function redo() {
              this.context.triggerEvent('before.command', this.$editable.html());
              this.history.redo();
              this.context.triggerEvent('change', this.$editable.html(), this.$editable);
            }
            /**
             * before command
             */

          }, {
            key: "beforeCommand",
            value: function beforeCommand() {
              this.context.triggerEvent('before.command', this.$editable.html()); // Set styleWithCSS before run a command

              document.execCommand('styleWithCSS', false, this.options.styleWithCSS); // keep focus on editable before command execution

              this.focus();
            }
            /**
             * after command
             * @param {Boolean} isPreventTrigger
             */

          }, {
            key: "afterCommand",
            value: function afterCommand(isPreventTrigger) {
              this.normalizeContent();
              this.history.recordUndo();

              if (!isPreventTrigger) {
                this.context.triggerEvent('change', this.$editable.html(), this.$editable);
              }
            }
            /**
             * handle tab key
             */

          }, {
            key: "tab",
            value: function tab() {
              var rng = this.getLastRange();

              if (rng.isCollapsed() && rng.isOnCell()) {
                this.table.tab(rng);
              } else {
                if (this.options.tabSize === 0) {
                  return false;
                }

                if (!this.isLimited(this.options.tabSize)) {
                  this.beforeCommand();
                  this.typing.insertTab(rng, this.options.tabSize);
                  this.afterCommand();
                }
              }
            }
            /**
             * handle shift+tab key
             */

          }, {
            key: "untab",
            value: function untab() {
              var rng = this.getLastRange();

              if (rng.isCollapsed() && rng.isOnCell()) {
                this.table.tab(rng, true);
              } else {
                if (this.options.tabSize === 0) {
                  return false;
                }
              }
            }
            /**
             * run given function between beforeCommand and afterCommand
             */

          }, {
            key: "wrapCommand",
            value: function wrapCommand(fn) {
              return function () {
                this.beforeCommand();
                fn.apply(this, arguments);
                this.afterCommand();
              };
            }
            /**
             * insert image
             *
             * @param {String} src
             * @param {String|Function} param
             * @return {Promise}
             */

          }, {
            key: "insertImage",
            value: function insertImage(src, param) {
              var _this3 = this;

              return createImage(src, param).then(function ($image) {
                _this3.beforeCommand();

                if (typeof param === 'function') {
                  param($image);
                } else {
                  if (typeof param === 'string') {
                    $image.attr('data-filename', param);
                  }

                  $image.css('width', Math.min(_this3.$editable.width(), $image.width()));
                }

                $image.show();

                _this3.getLastRange().insertNode($image[0]);

                _this3.setLastRange(range.createFromNodeAfter($image[0]).select());

                _this3.afterCommand();
              }).fail(function (e) {
                _this3.context.triggerEvent('image.upload.error', e);
              });
            }
            /**
             * insertImages
             * @param {File[]} files
             */

          }, {
            key: "insertImagesAsDataURL",
            value: function insertImagesAsDataURL(files) {
              var _this4 = this;

              external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(files, function (idx, file) {
                var filename = file.name;

                if (_this4.options.maximumImageFileSize && _this4.options.maximumImageFileSize < file.size) {
                  _this4.context.triggerEvent('image.upload.error', _this4.lang.image.maximumFileSizeError);
                } else {
                  readFileAsDataURL(file).then(function (dataURL) {
                    return _this4.insertImage(dataURL, filename);
                  }).fail(function () {
                    _this4.context.triggerEvent('image.upload.error');
                  });
                }
              });
            }
            /**
             * insertImagesOrCallback
             * @param {File[]} files
             */

          }, {
            key: "insertImagesOrCallback",
            value: function insertImagesOrCallback(files) {
              var callbacks = this.options.callbacks; // If onImageUpload set,

              if (callbacks.onImageUpload) {
                this.context.triggerEvent('image.upload', files); // else insert Image as dataURL
              } else {
                this.insertImagesAsDataURL(files);
              }
            }
            /**
             * return selected plain text
             * @return {String} text
             */

          }, {
            key: "getSelectedText",
            value: function getSelectedText() {
              var rng = this.getLastRange(); // if range on anchor, expand range with anchor

              if (rng.isOnAnchor()) {
                rng = range.createFromNode(dom.ancestor(rng.sc, dom.isAnchor));
              }

              return rng.toString();
            }
          }, {
            key: "onFormatBlock",
            value: function onFormatBlock(tagName, $target) {
              // [workaround] for MSIE, IE need `<`
              document.execCommand('FormatBlock', false, env.isMSIE ? '<' + tagName + '>' : tagName); // support custom class

              if ($target && $target.length) {
                // find the exact element has given tagName
                if ($target[0].tagName.toUpperCase() !== tagName.toUpperCase()) {
                  $target = $target.find(tagName);
                }

                if ($target && $target.length) {
                  var className = $target[0].className || '';

                  if (className) {
                    var currentRange = this.createRange();
                    var $parent = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()([currentRange.sc, currentRange.ec]).closest(tagName);
                    $parent.addClass(className);
                  }
                }
              }
            }
          }, {
            key: "formatPara",
            value: function formatPara() {
              this.formatBlock('P');
            }
          }, {
            key: "fontStyling",
            value: function fontStyling(target, value) {
              var rng = this.getLastRange();

              if (rng !== '') {
                var spans = this.style.styleNodes(rng);
                this.$editor.find('.note-status-output').html('');
                external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(spans).css(target, value); // [workaround] added styled bogus span for style
                //  - also bogus character needed for cursor position

                if (rng.isCollapsed()) {
                  var firstSpan = lists.head(spans);

                  if (firstSpan && !dom.nodeLength(firstSpan)) {
                    firstSpan.innerHTML = dom.ZERO_WIDTH_NBSP_CHAR;
                    range.createFromNode(firstSpan.firstChild).select();
                    this.setLastRange();
                    this.$editable.data(KEY_BOGUS, firstSpan);
                  }
                } else {
                  this.setLastRange(this.createRangeFromList(spans).select());
                }
              } else {
                var noteStatusOutput = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.now();
                this.$editor.find('.note-status-output').html('<div id="note-status-output-' + noteStatusOutput + '" class="alert alert-info">' + this.lang.output.noSelection + '</div>');
                setTimeout(function () {
                  external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('#note-status-output-' + noteStatusOutput).remove();
                }, 5000);
              }
            }
            /**
             * unlink
             *
             * @type command
             */

          }, {
            key: "unlink",
            value: function unlink() {
              var rng = this.getLastRange();

              if (rng.isOnAnchor()) {
                var anchor = dom.ancestor(rng.sc, dom.isAnchor);
                rng = range.createFromNode(anchor);
                rng.select();
                this.setLastRange();
                this.beforeCommand();
                document.execCommand('unlink');
                this.afterCommand();
              }
            }
            /**
             * returns link info
             *
             * @return {Object}
             * @return {WrappedRange} return.range
             * @return {String} return.text
             * @return {Boolean} [return.isNewWindow=true]
             * @return {String} [return.url=""]
             */

          }, {
            key: "getLinkInfo",
            value: function getLinkInfo() {
              var rng = this.getLastRange().expand(dom.isAnchor); // Get the first anchor on range(for edit).

              var $anchor = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(lists.head(rng.nodes(dom.isAnchor)));
              var linkInfo = {
                range: rng,
                text: rng.toString(),
                url: $anchor.length ? $anchor.attr('href') : ''
              }; // When anchor exists,

              if ($anchor.length) {
                // Set isNewWindow by checking its target.
                linkInfo.isNewWindow = $anchor.attr('target') === '_blank';
              }

              return linkInfo;
            }
          }, {
            key: "addRow",
            value: function addRow(position) {
              var rng = this.getLastRange(this.$editable);

              if (rng.isCollapsed() && rng.isOnCell()) {
                this.beforeCommand();
                this.table.addRow(rng, position);
                this.afterCommand();
              }
            }
          }, {
            key: "addCol",
            value: function addCol(position) {
              var rng = this.getLastRange(this.$editable);

              if (rng.isCollapsed() && rng.isOnCell()) {
                this.beforeCommand();
                this.table.addCol(rng, position);
                this.afterCommand();
              }
            }
          }, {
            key: "deleteRow",
            value: function deleteRow() {
              var rng = this.getLastRange(this.$editable);

              if (rng.isCollapsed() && rng.isOnCell()) {
                this.beforeCommand();
                this.table.deleteRow(rng);
                this.afterCommand();
              }
            }
          }, {
            key: "deleteCol",
            value: function deleteCol() {
              var rng = this.getLastRange(this.$editable);

              if (rng.isCollapsed() && rng.isOnCell()) {
                this.beforeCommand();
                this.table.deleteCol(rng);
                this.afterCommand();
              }
            }
          }, {
            key: "deleteTable",
            value: function deleteTable() {
              var rng = this.getLastRange(this.$editable);

              if (rng.isCollapsed() && rng.isOnCell()) {
                this.beforeCommand();
                this.table.deleteTable(rng);
                this.afterCommand();
              }
            }
            /**
             * @param {Position} pos
             * @param {jQuery} $target - target element
             * @param {Boolean} [bKeepRatio] - keep ratio
             */

          }, {
            key: "resizeTo",
            value: function resizeTo(pos, $target, bKeepRatio) {
              var imageSize;

              if (bKeepRatio) {
                var newRatio = pos.y / pos.x;
                var ratio = $target.data('ratio');
                imageSize = {
                  width: ratio > newRatio ? pos.x : pos.y / ratio,
                  height: ratio > newRatio ? pos.x * ratio : pos.y
                };
              } else {
                imageSize = {
                  width: pos.x,
                  height: pos.y
                };
              }

              $target.css(imageSize);
            }
            /**
             * returns whether editable area has focus or not.
             */

          }, {
            key: "hasFocus",
            value: function hasFocus() {
              return this.$editable.is(':focus');
            }
            /**
             * set focus
             */

          }, {
            key: "focus",
            value: function focus() {
              // [workaround] Screen will move when page is scolled in IE.
              //  - do focus when not focused
              if (!this.hasFocus()) {
                this.$editable.focus();
              }
            }
            /**
             * returns whether contents is empty or not.
             * @return {Boolean}
             */

          }, {
            key: "isEmpty",
            value: function isEmpty() {
              return dom.isEmpty(this.$editable[0]) || dom.emptyPara === this.$editable.html();
            }
            /**
             * Removes all contents and restores the editable instance to an _emptyPara_.
             */

          }, {
            key: "empty",
            value: function empty() {
              this.context.invoke('code', dom.emptyPara);
            }
            /**
             * normalize content
             */

          }, {
            key: "normalizeContent",
            value: function normalizeContent() {
              this.$editable[0].normalize();
            }
          }]);
          return Editor;
        }(); // CONCATENATED MODULE: ./src/js/base/module/Clipboard.js


        function Clipboard_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function Clipboard_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function Clipboard_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) Clipboard_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) Clipboard_defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var Clipboard_Clipboard = /*#__PURE__*/function () {
          function Clipboard(context) {
            Clipboard_classCallCheck(this, Clipboard);
            this.context = context;
            this.$editable = context.layoutInfo.editable;
          }

          Clipboard_createClass(Clipboard, [{
            key: "initialize",
            value: function initialize() {
              this.$editable.on('paste', this.pasteByEvent.bind(this));
            }
            /**
             * paste by clipboard event
             *
             * @param {Event} event
             */

          }, {
            key: "pasteByEvent",
            value: function pasteByEvent(event) {
              var _this = this;

              var clipboardData = event.originalEvent.clipboardData;

              if (clipboardData && clipboardData.items && clipboardData.items.length) {
                var item = clipboardData.items.length > 1 ? clipboardData.items[1] : lists.head(clipboardData.items);

                if (item.kind === 'file' && item.type.indexOf('image/') !== -1) {
                  // paste img file
                  this.context.invoke('editor.insertImagesOrCallback', [item.getAsFile()]);
                  event.preventDefault();
                } else if (item.kind === 'string') {
                  // paste text with maxTextLength check
                  if (this.context.invoke('editor.isLimited', clipboardData.getData('Text').length)) {
                    event.preventDefault();
                  }
                }
              } else if (window.clipboardData) {
                // for IE
                var text = window.clipboardData.getData('text');

                if (this.context.invoke('editor.isLimited', text.length)) {
                  event.preventDefault();
                }
              } // Call editor.afterCommand after proceeding default event handler


              setTimeout(function () {
                _this.context.invoke('editor.afterCommand');
              }, 10);
            }
          }]);
          return Clipboard;
        }(); // CONCATENATED MODULE: ./src/js/base/module/Dropzone.js


        function Dropzone_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function Dropzone_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function Dropzone_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) Dropzone_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) Dropzone_defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var Dropzone_Dropzone = /*#__PURE__*/function () {
          function Dropzone(context) {
            Dropzone_classCallCheck(this, Dropzone);
            this.context = context;
            this.$eventListener = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(document);
            this.$editor = context.layoutInfo.editor;
            this.$editable = context.layoutInfo.editable;
            this.options = context.options;
            this.lang = this.options.langInfo;
            this.documentEventHandlers = {};
            this.$dropzone = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(['<div class="note-dropzone">', '<div class="note-dropzone-message"></div>', '</div>'].join('')).prependTo(this.$editor);
          }
          /**
           * attach Drag and Drop Events
           */


          Dropzone_createClass(Dropzone, [{
            key: "initialize",
            value: function initialize() {
              if (this.options.disableDragAndDrop) {
                // prevent default drop event
                this.documentEventHandlers.onDrop = function (e) {
                  e.preventDefault();
                }; // do not consider outside of dropzone


                this.$eventListener = this.$dropzone;
                this.$eventListener.on('drop', this.documentEventHandlers.onDrop);
              } else {
                this.attachDragAndDropEvent();
              }
            }
            /**
             * attach Drag and Drop Events
             */

          }, {
            key: "attachDragAndDropEvent",
            value: function attachDragAndDropEvent() {
              var _this = this;

              var collection = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()();
              var $dropzoneMessage = this.$dropzone.find('.note-dropzone-message');

              this.documentEventHandlers.onDragenter = function (e) {
                var isCodeview = _this.context.invoke('codeview.isActivated');

                var hasEditorSize = _this.$editor.width() > 0 && _this.$editor.height() > 0;

                if (!isCodeview && !collection.length && hasEditorSize) {
                  _this.$editor.addClass('dragover');

                  _this.$dropzone.width(_this.$editor.width());

                  _this.$dropzone.height(_this.$editor.height());

                  $dropzoneMessage.text(_this.lang.image.dragImageHere);
                }

                collection = collection.add(e.target);
              };

              this.documentEventHandlers.onDragleave = function (e) {
                collection = collection.not(e.target); // If nodeName is BODY, then just make it over (fix for IE)

                if (!collection.length || e.target.nodeName === 'BODY') {
                  collection = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()();

                  _this.$editor.removeClass('dragover');
                }
              };

              this.documentEventHandlers.onDrop = function () {
                collection = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()();

                _this.$editor.removeClass('dragover');
              }; // show dropzone on dragenter when dragging a object to document
              // -but only if the editor is visible, i.e. has a positive width and height


              this.$eventListener.on('dragenter', this.documentEventHandlers.onDragenter).on('dragleave', this.documentEventHandlers.onDragleave).on('drop', this.documentEventHandlers.onDrop); // change dropzone's message on hover.

              this.$dropzone.on('dragenter', function () {
                _this.$dropzone.addClass('hover');

                $dropzoneMessage.text(_this.lang.image.dropImage);
              }).on('dragleave', function () {
                _this.$dropzone.removeClass('hover');

                $dropzoneMessage.text(_this.lang.image.dragImageHere);
              }); // attach dropImage

              this.$dropzone.on('drop', function (event) {
                var dataTransfer = event.originalEvent.dataTransfer; // stop the browser from opening the dropped content

                event.preventDefault();

                if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
                  _this.$editable.focus();

                  _this.context.invoke('editor.insertImagesOrCallback', dataTransfer.files);
                } else {
                  external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(dataTransfer.types, function (idx, type) {
                    // skip moz-specific types
                    if (type.toLowerCase().indexOf('_moz_') > -1) {
                      return;
                    }

                    var content = dataTransfer.getData(type);

                    if (type.toLowerCase().indexOf('text') > -1) {
                      _this.context.invoke('editor.pasteHTML', content);
                    } else {
                      external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(content).each(function (idx, item) {
                        _this.context.invoke('editor.insertNode', item);
                      });
                    }
                  });
                }
              }).on('dragover', false); // prevent default dragover event
            }
          }, {
            key: "destroy",
            value: function destroy() {
              var _this2 = this;

              Object.keys(this.documentEventHandlers).forEach(function (key) {
                _this2.$eventListener.off(key.substr(2).toLowerCase(), _this2.documentEventHandlers[key]);
              });
              this.documentEventHandlers = {};
            }
          }]);
          return Dropzone;
        }(); // CONCATENATED MODULE: ./src/js/base/module/Codeview.js


        function _createForOfIteratorHelper(o) {
          if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
            if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {
              var i = 0;

              var F = function F() {};

              return {
                s: F,
                n: function n() {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                },
                e: function e(_e) {
                  throw _e;
                },
                f: F
              };
            }

            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }

          var it,
              normalCompletion = true,
              didErr = false,
              err;
          return {
            s: function s() {
              it = o[Symbol.iterator]();
            },
            n: function n() {
              var step = it.next();
              normalCompletion = step.done;
              return step;
            },
            e: function e(_e2) {
              didErr = true;
              err = _e2;
            },
            f: function f() {
              try {
                if (!normalCompletion && it["return"] != null) it["return"]();
              } finally {
                if (didErr) throw err;
              }
            }
          };
        }

        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(n);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }

        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;

          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }

          return arr2;
        }

        function Codeview_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function Codeview_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function Codeview_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) Codeview_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) Codeview_defineProperties(Constructor, staticProps);
          return Constructor;
        }
        /**
         * @class Codeview
         */


        var Codeview_CodeView = /*#__PURE__*/function () {
          function CodeView(context) {
            Codeview_classCallCheck(this, CodeView);
            this.context = context;
            this.$editor = context.layoutInfo.editor;
            this.$editable = context.layoutInfo.editable;
            this.$codable = context.layoutInfo.codable;
            this.options = context.options;
            this.CodeMirrorConstructor = window.CodeMirror;

            if (this.options.codemirror.CodeMirrorConstructor) {
              this.CodeMirrorConstructor = this.options.codemirror.CodeMirrorConstructor;
            }
          }

          Codeview_createClass(CodeView, [{
            key: "sync",
            value: function sync(html) {
              var isCodeview = this.isActivated();
              var CodeMirror = this.CodeMirrorConstructor;

              if (isCodeview) {
                if (html) {
                  if (CodeMirror) {
                    this.$codable.data('cmEditor').getDoc().setValue(html);
                  } else {
                    this.$codable.val(html);
                  }
                } else {
                  if (CodeMirror) {
                    this.$codable.data('cmEditor').save();
                  }
                }
              }
            }
          }, {
            key: "initialize",
            value: function initialize() {
              var _this = this;

              this.$codable.on('keyup', function (event) {
                if (event.keyCode === core_key.code.ESCAPE) {
                  _this.deactivate();
                }
              });
            }
            /**
             * @return {Boolean}
             */

          }, {
            key: "isActivated",
            value: function isActivated() {
              return this.$editor.hasClass('codeview');
            }
            /**
             * toggle codeview
             */

          }, {
            key: "toggle",
            value: function toggle() {
              if (this.isActivated()) {
                this.deactivate();
              } else {
                this.activate();
              }

              this.context.triggerEvent('codeview.toggled');
            }
            /**
             * purify input value
             * @param value
             * @returns {*}
             */

          }, {
            key: "purify",
            value: function purify(value) {
              if (this.options.codeviewFilter) {
                // filter code view regex
                value = value.replace(this.options.codeviewFilterRegex, ''); // allow specific iframe tag

                if (this.options.codeviewIframeFilter) {
                  var whitelist = this.options.codeviewIframeWhitelistSrc.concat(this.options.codeviewIframeWhitelistSrcBase);
                  value = value.replace(/(<iframe.*?>.*?(?:<\/iframe>)?)/gi, function (tag) {
                    // remove if src attribute is duplicated
                    if (/<.+src(?==?('|"|\s)?)[\s\S]+src(?=('|"|\s)?)[^>]*?>/i.test(tag)) {
                      return '';
                    }

                    var _iterator = _createForOfIteratorHelper(whitelist),
                        _step;

                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done;) {
                        var src = _step.value; // pass if src is trusted

                        if (new RegExp('src="(https?:)?\/\/' + src.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + '\/(.+)"').test(tag)) {
                          return tag;
                        }
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }

                    return '';
                  });
                }
              }

              return value;
            }
            /**
             * activate code view
             */

          }, {
            key: "activate",
            value: function activate() {
              var _this2 = this;

              var CodeMirror = this.CodeMirrorConstructor;
              this.$codable.val(dom.html(this.$editable, this.options.prettifyHtml));
              this.$codable.height(this.$editable.height());
              this.context.invoke('toolbar.updateCodeview', true);
              this.context.invoke('airPopover.updateCodeview', true);
              this.$editor.addClass('codeview');
              this.$codable.focus(); // activate CodeMirror as codable

              if (CodeMirror) {
                var cmEditor = CodeMirror.fromTextArea(this.$codable[0], this.options.codemirror); // CodeMirror TernServer

                if (this.options.codemirror.tern) {
                  var server = new CodeMirror.TernServer(this.options.codemirror.tern);
                  cmEditor.ternServer = server;
                  cmEditor.on('cursorActivity', function (cm) {
                    server.updateArgHints(cm);
                  });
                }

                cmEditor.on('blur', function (event) {
                  _this2.context.triggerEvent('blur.codeview', cmEditor.getValue(), event);
                });
                cmEditor.on('change', function () {
                  _this2.context.triggerEvent('change.codeview', cmEditor.getValue(), cmEditor);
                }); // CodeMirror hasn't Padding.

                cmEditor.setSize(null, this.$editable.outerHeight());
                this.$codable.data('cmEditor', cmEditor);
              } else {
                this.$codable.on('blur', function (event) {
                  _this2.context.triggerEvent('blur.codeview', _this2.$codable.val(), event);
                });
                this.$codable.on('input', function () {
                  _this2.context.triggerEvent('change.codeview', _this2.$codable.val(), _this2.$codable);
                });
              }
            }
            /**
             * deactivate code view
             */

          }, {
            key: "deactivate",
            value: function deactivate() {
              var CodeMirror = this.CodeMirrorConstructor; // deactivate CodeMirror as codable

              if (CodeMirror) {
                var cmEditor = this.$codable.data('cmEditor');
                this.$codable.val(cmEditor.getValue());
                cmEditor.toTextArea();
              }

              var value = this.purify(dom.value(this.$codable, this.options.prettifyHtml) || dom.emptyPara);
              var isChange = this.$editable.html() !== value;
              this.$editable.html(value);
              this.$editable.height(this.options.height ? this.$codable.height() : 'auto');
              this.$editor.removeClass('codeview');

              if (isChange) {
                this.context.triggerEvent('change', this.$editable.html(), this.$editable);
              }

              this.$editable.focus();
              this.context.invoke('toolbar.updateCodeview', false);
              this.context.invoke('airPopover.updateCodeview', false);
            }
          }, {
            key: "destroy",
            value: function destroy() {
              if (this.isActivated()) {
                this.deactivate();
              }
            }
          }]);
          return CodeView;
        }(); // CONCATENATED MODULE: ./src/js/base/module/Statusbar.js


        function Statusbar_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function Statusbar_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function Statusbar_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) Statusbar_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) Statusbar_defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var EDITABLE_PADDING = 24;

        var Statusbar_Statusbar = /*#__PURE__*/function () {
          function Statusbar(context) {
            Statusbar_classCallCheck(this, Statusbar);
            this.$document = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(document);
            this.$statusbar = context.layoutInfo.statusbar;
            this.$editable = context.layoutInfo.editable;
            this.options = context.options;
          }

          Statusbar_createClass(Statusbar, [{
            key: "initialize",
            value: function initialize() {
              var _this = this;

              if (this.options.airMode || this.options.disableResizeEditor) {
                this.destroy();
                return;
              }

              this.$statusbar.on('mousedown', function (event) {
                event.preventDefault();
                event.stopPropagation();

                var editableTop = _this.$editable.offset().top - _this.$document.scrollTop();

                var onMouseMove = function onMouseMove(event) {
                  var height = event.clientY - (editableTop + EDITABLE_PADDING);
                  height = _this.options.minheight > 0 ? Math.max(height, _this.options.minheight) : height;
                  height = _this.options.maxHeight > 0 ? Math.min(height, _this.options.maxHeight) : height;

                  _this.$editable.height(height);
                };

                _this.$document.on('mousemove', onMouseMove).one('mouseup', function () {
                  _this.$document.off('mousemove', onMouseMove);
                });
              });
            }
          }, {
            key: "destroy",
            value: function destroy() {
              this.$statusbar.off();
              this.$statusbar.addClass('locked');
            }
          }]);
          return Statusbar;
        }(); // CONCATENATED MODULE: ./src/js/base/module/Fullscreen.js


        function Fullscreen_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function Fullscreen_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function Fullscreen_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) Fullscreen_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) Fullscreen_defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var Fullscreen_Fullscreen = /*#__PURE__*/function () {
          function Fullscreen(context) {
            var _this = this;

            Fullscreen_classCallCheck(this, Fullscreen);
            this.context = context;
            this.$editor = context.layoutInfo.editor;
            this.$toolbar = context.layoutInfo.toolbar;
            this.$editable = context.layoutInfo.editable;
            this.$codable = context.layoutInfo.codable;
            this.$window = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(window);
            this.$scrollbar = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('html, body');

            this.onResize = function () {
              _this.resizeTo({
                h: _this.$window.height() - _this.$toolbar.outerHeight()
              });
            };
          }

          Fullscreen_createClass(Fullscreen, [{
            key: "resizeTo",
            value: function resizeTo(size) {
              this.$editable.css('height', size.h);
              this.$codable.css('height', size.h);

              if (this.$codable.data('cmeditor')) {
                this.$codable.data('cmeditor').setsize(null, size.h);
              }
            }
            /**
             * toggle fullscreen
             */

          }, {
            key: "toggle",
            value: function toggle() {
              this.$editor.toggleClass('fullscreen');

              if (this.isFullscreen()) {
                this.$editable.data('orgHeight', this.$editable.css('height'));
                this.$editable.data('orgMaxHeight', this.$editable.css('maxHeight'));
                this.$editable.css('maxHeight', '');
                this.$window.on('resize', this.onResize).trigger('resize');
                this.$scrollbar.css('overflow', 'hidden');
              } else {
                this.$window.off('resize', this.onResize);
                this.resizeTo({
                  h: this.$editable.data('orgHeight')
                });
                this.$editable.css('maxHeight', this.$editable.css('orgMaxHeight'));
                this.$scrollbar.css('overflow', 'visible');
              }

              this.context.invoke('toolbar.updateFullscreen', this.isFullscreen());
            }
          }, {
            key: "isFullscreen",
            value: function isFullscreen() {
              return this.$editor.hasClass('fullscreen');
            }
          }]);
          return Fullscreen;
        }(); // CONCATENATED MODULE: ./src/js/base/module/Handle.js


        function Handle_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function Handle_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function Handle_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) Handle_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) Handle_defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var Handle_Handle = /*#__PURE__*/function () {
          function Handle(context) {
            var _this = this;

            Handle_classCallCheck(this, Handle);
            this.context = context;
            this.$document = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(document);
            this.$editingArea = context.layoutInfo.editingArea;
            this.options = context.options;
            this.lang = this.options.langInfo;
            this.events = {
              'summernote.mousedown': function summernoteMousedown(we, e) {
                if (_this.update(e.target, e)) {
                  e.preventDefault();
                }
              },
              'summernote.keyup summernote.scroll summernote.change summernote.dialog.shown': function summernoteKeyupSummernoteScrollSummernoteChangeSummernoteDialogShown() {
                _this.update();
              },
              'summernote.disable summernote.blur': function summernoteDisableSummernoteBlur() {
                _this.hide();
              },
              'summernote.codeview.toggled': function summernoteCodeviewToggled() {
                _this.update();
              }
            };
          }

          Handle_createClass(Handle, [{
            key: "initialize",
            value: function initialize() {
              var _this2 = this;

              this.$handle = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(['<div class="note-handle">', '<div class="note-control-selection">', '<div class="note-control-selection-bg"></div>', '<div class="note-control-holder note-control-nw"></div>', '<div class="note-control-holder note-control-ne"></div>', '<div class="note-control-holder note-control-sw"></div>', '<div class="', this.options.disableResizeImage ? 'note-control-holder' : 'note-control-sizing', ' note-control-se"></div>', this.options.disableResizeImage ? '' : '<div class="note-control-selection-info"></div>', '</div>', '</div>'].join('')).prependTo(this.$editingArea);
              this.$handle.on('mousedown', function (event) {
                if (dom.isControlSizing(event.target)) {
                  event.preventDefault();
                  event.stopPropagation();

                  var $target = _this2.$handle.find('.note-control-selection').data('target');

                  var posStart = $target.offset();

                  var scrollTop = _this2.$document.scrollTop();

                  var onMouseMove = function onMouseMove(event) {
                    _this2.context.invoke('editor.resizeTo', {
                      x: event.clientX - posStart.left,
                      y: event.clientY - (posStart.top - scrollTop)
                    }, $target, !event.shiftKey);

                    _this2.update($target[0], event);
                  };

                  _this2.$document.on('mousemove', onMouseMove).one('mouseup', function (e) {
                    e.preventDefault();

                    _this2.$document.off('mousemove', onMouseMove);

                    _this2.context.invoke('editor.afterCommand');
                  });

                  if (!$target.data('ratio')) {
                    // original ratio.
                    $target.data('ratio', $target.height() / $target.width());
                  }
                }
              }); // Listen for scrolling on the handle overlay.

              this.$handle.on('wheel', function (e) {
                e.preventDefault();

                _this2.update();
              });
            }
          }, {
            key: "destroy",
            value: function destroy() {
              this.$handle.remove();
            }
          }, {
            key: "update",
            value: function update(target, event) {
              if (this.context.isDisabled()) {
                return false;
              }

              var isImage = dom.isImg(target);
              var $selection = this.$handle.find('.note-control-selection');
              this.context.invoke('imagePopover.update', target, event);

              if (isImage) {
                var $image = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(target);
                var position = $image.position();
                var pos = {
                  left: position.left + parseInt($image.css('marginLeft'), 10),
                  top: position.top + parseInt($image.css('marginTop'), 10)
                }; // exclude margin

                var imageSize = {
                  w: $image.outerWidth(false),
                  h: $image.outerHeight(false)
                };
                $selection.css({
                  display: 'block',
                  left: pos.left,
                  top: pos.top,
                  width: imageSize.w,
                  height: imageSize.h
                }).data('target', $image); // save current image element.

                var origImageObj = new Image();
                origImageObj.src = $image.attr('src');
                var sizingText = imageSize.w + 'x' + imageSize.h + ' (' + this.lang.image.original + ': ' + origImageObj.width + 'x' + origImageObj.height + ')';
                $selection.find('.note-control-selection-info').text(sizingText);
                this.context.invoke('editor.saveTarget', target);
              } else {
                this.hide();
              }

              return isImage;
            }
            /**
             * hide
             *
             * @param {jQuery} $handle
             */

          }, {
            key: "hide",
            value: function hide() {
              this.context.invoke('editor.clearTarget');
              this.$handle.children().hide();
            }
          }]);
          return Handle;
        }(); // CONCATENATED MODULE: ./src/js/base/module/AutoLink.js


        function AutoLink_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function AutoLink_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function AutoLink_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) AutoLink_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) AutoLink_defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var defaultScheme = 'http://';
        var linkPattern = /^([A-Za-z][A-Za-z0-9+-.]*\:[\/]{2}|tel:|mailto:[A-Z0-9._%+-]+@)?(www\.)?(.+)$/i;

        var AutoLink_AutoLink = /*#__PURE__*/function () {
          function AutoLink(context) {
            var _this = this;

            AutoLink_classCallCheck(this, AutoLink);
            this.context = context;
            this.options = context.options;
            this.events = {
              'summernote.keyup': function summernoteKeyup(we, e) {
                if (!e.isDefaultPrevented()) {
                  _this.handleKeyup(e);
                }
              },
              'summernote.keydown': function summernoteKeydown(we, e) {
                _this.handleKeydown(e);
              }
            };
          }

          AutoLink_createClass(AutoLink, [{
            key: "initialize",
            value: function initialize() {
              this.lastWordRange = null;
            }
          }, {
            key: "destroy",
            value: function destroy() {
              this.lastWordRange = null;
            }
          }, {
            key: "replace",
            value: function replace() {
              if (!this.lastWordRange) {
                return;
              }

              var keyword = this.lastWordRange.toString();
              var match = keyword.match(linkPattern);

              if (match && (match[1] || match[2])) {
                var link = match[1] ? keyword : defaultScheme + keyword;
                var urlText = this.options.showDomainOnlyForAutolink ? keyword.replace(/^(?:https?:\/\/)?(?:tel?:?)?(?:mailto?:?)?(?:www\.)?/i, '').split('/')[0] : keyword;
                var node = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<a />').html(urlText).attr('href', link)[0];

                if (this.context.options.linkTargetBlank) {
                  external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(node).attr('target', '_blank');
                }

                this.lastWordRange.insertNode(node);
                this.lastWordRange = null;
                this.context.invoke('editor.focus');
              }
            }
          }, {
            key: "handleKeydown",
            value: function handleKeydown(e) {
              if (lists.contains([core_key.code.ENTER, core_key.code.SPACE], e.keyCode)) {
                var wordRange = this.context.invoke('editor.createRange').getWordRange();
                this.lastWordRange = wordRange;
              }
            }
          }, {
            key: "handleKeyup",
            value: function handleKeyup(e) {
              if (lists.contains([core_key.code.ENTER, core_key.code.SPACE], e.keyCode)) {
                this.replace();
              }
            }
          }]);
          return AutoLink;
        }(); // CONCATENATED MODULE: ./src/js/base/module/AutoSync.js


        function AutoSync_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function AutoSync_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function AutoSync_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) AutoSync_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) AutoSync_defineProperties(Constructor, staticProps);
          return Constructor;
        }
        /**
         * textarea auto sync.
         */


        var AutoSync_AutoSync = /*#__PURE__*/function () {
          function AutoSync(context) {
            var _this = this;

            AutoSync_classCallCheck(this, AutoSync);
            this.$note = context.layoutInfo.note;
            this.events = {
              'summernote.change': function summernoteChange() {
                _this.$note.val(context.invoke('code'));
              }
            };
          }

          AutoSync_createClass(AutoSync, [{
            key: "shouldInitialize",
            value: function shouldInitialize() {
              return dom.isTextarea(this.$note[0]);
            }
          }]);
          return AutoSync;
        }(); // CONCATENATED MODULE: ./src/js/base/module/AutoReplace.js


        function AutoReplace_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function AutoReplace_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function AutoReplace_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) AutoReplace_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) AutoReplace_defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var AutoReplace_AutoReplace = /*#__PURE__*/function () {
          function AutoReplace(context) {
            var _this = this;

            AutoReplace_classCallCheck(this, AutoReplace);
            this.context = context;
            this.options = context.options.replace || {};
            this.keys = [core_key.code.ENTER, core_key.code.SPACE, core_key.code.PERIOD, core_key.code.COMMA, core_key.code.SEMICOLON, core_key.code.SLASH];
            this.previousKeydownCode = null;
            this.events = {
              'summernote.keyup': function summernoteKeyup(we, e) {
                if (!e.isDefaultPrevented()) {
                  _this.handleKeyup(e);
                }
              },
              'summernote.keydown': function summernoteKeydown(we, e) {
                _this.handleKeydown(e);
              }
            };
          }

          AutoReplace_createClass(AutoReplace, [{
            key: "shouldInitialize",
            value: function shouldInitialize() {
              return !!this.options.match;
            }
          }, {
            key: "initialize",
            value: function initialize() {
              this.lastWord = null;
            }
          }, {
            key: "destroy",
            value: function destroy() {
              this.lastWord = null;
            }
          }, {
            key: "replace",
            value: function replace() {
              if (!this.lastWord) {
                return;
              }

              var self = this;
              var keyword = this.lastWord.toString();
              this.options.match(keyword, function (match) {
                if (match) {
                  var node = '';

                  if (typeof match === 'string') {
                    node = dom.createText(match);
                  } else if (match instanceof jQuery) {
                    node = match[0];
                  } else if (match instanceof Node) {
                    node = match;
                  }

                  if (!node) return;
                  self.lastWord.insertNode(node);
                  self.lastWord = null;
                  self.context.invoke('editor.focus');
                }
              });
            }
          }, {
            key: "handleKeydown",
            value: function handleKeydown(e) {
              // this forces it to remember the last whole word, even if multiple termination keys are pressed
              // before the previous key is let go.
              if (this.previousKeydownCode && lists.contains(this.keys, this.previousKeydownCode)) {
                this.previousKeydownCode = e.keyCode;
                return;
              }

              if (lists.contains(this.keys, e.keyCode)) {
                var wordRange = this.context.invoke('editor.createRange').getWordRange();
                this.lastWord = wordRange;
              }

              this.previousKeydownCode = e.keyCode;
            }
          }, {
            key: "handleKeyup",
            value: function handleKeyup(e) {
              if (lists.contains(this.keys, e.keyCode)) {
                this.replace();
              }
            }
          }]);
          return AutoReplace;
        }(); // CONCATENATED MODULE: ./src/js/base/module/Placeholder.js


        function Placeholder_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function Placeholder_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function Placeholder_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) Placeholder_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) Placeholder_defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var Placeholder_Placeholder = /*#__PURE__*/function () {
          function Placeholder(context) {
            var _this = this;

            Placeholder_classCallCheck(this, Placeholder);
            this.context = context;
            this.$editingArea = context.layoutInfo.editingArea;
            this.options = context.options;

            if (this.options.inheritPlaceholder === true) {
              // get placeholder value from the original element
              this.options.placeholder = this.context.$note.attr('placeholder') || this.options.placeholder;
            }

            this.events = {
              'summernote.init summernote.change': function summernoteInitSummernoteChange() {
                _this.update();
              },
              'summernote.codeview.toggled': function summernoteCodeviewToggled() {
                _this.update();
              }
            };
          }

          Placeholder_createClass(Placeholder, [{
            key: "shouldInitialize",
            value: function shouldInitialize() {
              return !!this.options.placeholder;
            }
          }, {
            key: "initialize",
            value: function initialize() {
              var _this2 = this;

              this.$placeholder = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<div class="note-placeholder">');
              this.$placeholder.on('click', function () {
                _this2.context.invoke('focus');
              }).html(this.options.placeholder).prependTo(this.$editingArea);
              this.update();
            }
          }, {
            key: "destroy",
            value: function destroy() {
              this.$placeholder.remove();
            }
          }, {
            key: "update",
            value: function update() {
              var isShow = !this.context.invoke('codeview.isActivated') && this.context.invoke('editor.isEmpty');
              this.$placeholder.toggle(isShow);
            }
          }]);
          return Placeholder;
        }(); // CONCATENATED MODULE: ./src/js/base/module/Buttons.js


        function Buttons_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function Buttons_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function Buttons_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) Buttons_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) Buttons_defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var Buttons_Buttons = /*#__PURE__*/function () {
          function Buttons(context) {
            Buttons_classCallCheck(this, Buttons);
            this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
            this.context = context;
            this.$toolbar = context.layoutInfo.toolbar;
            this.options = context.options;
            this.lang = this.options.langInfo;
            this.invertedKeyMap = func.invertObject(this.options.keyMap[env.isMac ? 'mac' : 'pc']);
          }

          Buttons_createClass(Buttons, [{
            key: "representShortcut",
            value: function representShortcut(editorMethod) {
              var shortcut = this.invertedKeyMap[editorMethod];

              if (!this.options.shortcuts || !shortcut) {
                return '';
              }

              if (env.isMac) {
                shortcut = shortcut.replace('CMD', '⌘').replace('SHIFT', '⇧');
              }

              shortcut = shortcut.replace('BACKSLASH', '\\').replace('SLASH', '/').replace('LEFTBRACKET', '[').replace('RIGHTBRACKET', ']');
              return ' (' + shortcut + ')';
            }
          }, {
            key: "button",
            value: function button(o) {
              if (!this.options.tooltip && o.tooltip) {
                delete o.tooltip;
              }

              o.container = this.options.container;
              return this.ui.button(o);
            }
          }, {
            key: "initialize",
            value: function initialize() {
              this.addToolbarButtons();
              this.addImagePopoverButtons();
              this.addLinkPopoverButtons();
              this.addTablePopoverButtons();
              this.fontInstalledMap = {};
            }
          }, {
            key: "destroy",
            value: function destroy() {
              delete this.fontInstalledMap;
            }
          }, {
            key: "isFontInstalled",
            value: function isFontInstalled(name) {
              if (!Object.prototype.hasOwnProperty.call(this.fontInstalledMap, name)) {
                this.fontInstalledMap[name] = env.isFontInstalled(name) || lists.contains(this.options.fontNamesIgnoreCheck, name);
              }

              return this.fontInstalledMap[name];
            }
          }, {
            key: "isFontDeservedToAdd",
            value: function isFontDeservedToAdd(name) {
              name = name.toLowerCase();
              return name !== '' && this.isFontInstalled(name) && env.genericFontFamilies.indexOf(name) === -1;
            }
          }, {
            key: "colorPalette",
            value: function colorPalette(className, tooltip, backColor, foreColor) {
              var _this = this;

              return this.ui.buttonGroup({
                className: 'note-color ' + className,
                children: [this.button({
                  className: 'note-current-color-button',
                  contents: this.ui.icon(this.options.icons.font + ' note-recent-color'),
                  tooltip: tooltip,
                  click: function click(e) {
                    var $button = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(e.currentTarget);

                    if (backColor && foreColor) {
                      _this.context.invoke('editor.color', {
                        backColor: $button.attr('data-backColor'),
                        foreColor: $button.attr('data-foreColor')
                      });
                    } else if (backColor) {
                      _this.context.invoke('editor.color', {
                        backColor: $button.attr('data-backColor')
                      });
                    } else if (foreColor) {
                      _this.context.invoke('editor.color', {
                        foreColor: $button.attr('data-foreColor')
                      });
                    }
                  },
                  callback: function callback($button) {
                    var $recentColor = $button.find('.note-recent-color');

                    if (backColor) {
                      $recentColor.css('background-color', _this.options.colorButton.backColor);
                      $button.attr('data-backColor', _this.options.colorButton.backColor);
                    }

                    if (foreColor) {
                      $recentColor.css('color', _this.options.colorButton.foreColor);
                      $button.attr('data-foreColor', _this.options.colorButton.foreColor);
                    } else {
                      $recentColor.css('color', 'transparent');
                    }
                  }
                }), this.button({
                  className: 'dropdown-toggle',
                  contents: this.ui.dropdownButtonContents('', this.options),
                  tooltip: this.lang.color.more,
                  data: {
                    toggle: 'dropdown'
                  }
                }), this.ui.dropdown({
                  items: (backColor ? ['<div class="note-palette">', '<div class="note-palette-title">' + this.lang.color.background + '</div>', '<div>', '<button type="button" class="note-color-reset btn btn-light btn-default" data-event="backColor" data-value="transparent">', this.lang.color.transparent, '</button>', '</div>', '<div class="note-holder" data-event="backColor"><!-- back colors --></div>', '<div>', '<button type="button" class="note-color-select btn btn-light btn-default" data-event="openPalette" data-value="backColorPicker">', this.lang.color.cpSelect, '</button>', '<input type="color" id="backColorPicker" class="note-btn note-color-select-btn" value="' + this.options.colorButton.backColor + '" data-event="backColorPalette">', '</div>', '<div class="note-holder-custom" id="backColorPalette" data-event="backColor"></div>', '</div>'].join('') : '') + (foreColor ? ['<div class="note-palette">', '<div class="note-palette-title">' + this.lang.color.foreground + '</div>', '<div>', '<button type="button" class="note-color-reset btn btn-light btn-default" data-event="removeFormat" data-value="foreColor">', this.lang.color.resetToDefault, '</button>', '</div>', '<div class="note-holder" data-event="foreColor"><!-- fore colors --></div>', '<div>', '<button type="button" class="note-color-select btn btn-light btn-default" data-event="openPalette" data-value="foreColorPicker">', this.lang.color.cpSelect, '</button>', '<input type="color" id="foreColorPicker" class="note-btn note-color-select-btn" value="' + this.options.colorButton.foreColor + '" data-event="foreColorPalette">', '</div>', // Fix missing Div, Commented to find easily if it's wrong
                  '<div class="note-holder-custom" id="foreColorPalette" data-event="foreColor"></div>', '</div>'].join('') : ''),
                  callback: function callback($dropdown) {
                    $dropdown.find('.note-holder').each(function (idx, item) {
                      var $holder = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(item);
                      $holder.append(_this.ui.palette({
                        colors: _this.options.colors,
                        colorsName: _this.options.colorsName,
                        eventName: $holder.data('event'),
                        container: _this.options.container,
                        tooltip: _this.options.tooltip
                      }).render());
                    });
                    /* TODO: do we have to record recent custom colors within cookies? */

                    var customColors = [['#FFFFFF', '#FFFFFF', '#FFFFFF', '#FFFFFF', '#FFFFFF', '#FFFFFF', '#FFFFFF', '#FFFFFF']];
                    $dropdown.find('.note-holder-custom').each(function (idx, item) {
                      var $holder = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(item);
                      $holder.append(_this.ui.palette({
                        colors: customColors,
                        colorsName: customColors,
                        eventName: $holder.data('event'),
                        container: _this.options.container,
                        tooltip: _this.options.tooltip
                      }).render());
                    });
                    $dropdown.find('input[type=color]').each(function (idx, item) {
                      external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(item).change(function () {
                        var $chip = $dropdown.find('#' + external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(this).data('event')).find('.note-color-btn').first();
                        var color = this.value.toUpperCase();
                        $chip.css('background-color', color).attr('aria-label', color).attr('data-value', color).attr('data-original-title', color);
                        $chip.click();
                      });
                    });
                  },
                  click: function click(event) {
                    event.stopPropagation();
                    var $parent = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('.' + className).find('.note-dropdown-menu');
                    var $button = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(event.target);
                    var eventName = $button.data('event');
                    var value = $button.attr('data-value');

                    if (eventName === 'openPalette') {
                      var $picker = $parent.find('#' + value);
                      var $palette = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()($parent.find('#' + $picker.data('event')).find('.note-color-row')[0]); // Shift palette chips

                      var $chip = $palette.find('.note-color-btn').last().detach(); // Set chip attributes

                      var color = $picker.val();
                      $chip.css('background-color', color).attr('aria-label', color).attr('data-value', color).attr('data-original-title', color);
                      $palette.prepend($chip);
                      $picker.click();
                    } else {
                      if (lists.contains(['backColor', 'foreColor'], eventName)) {
                        var key = eventName === 'backColor' ? 'background-color' : 'color';
                        var $color = $button.closest('.note-color').find('.note-recent-color');
                        var $currentButton = $button.closest('.note-color').find('.note-current-color-button');
                        $color.css(key, value);
                        $currentButton.attr('data-' + eventName, value);
                      }

                      _this.context.invoke('editor.' + eventName, value);
                    }
                  }
                })]
              }).render();
            }
          }, {
            key: "addToolbarButtons",
            value: function addToolbarButtons() {
              var _this2 = this;

              this.context.memo('button.style', function () {
                return _this2.ui.buttonGroup([_this2.button({
                  className: 'dropdown-toggle',
                  contents: _this2.ui.dropdownButtonContents(_this2.ui.icon(_this2.options.icons.magic), _this2.options),
                  tooltip: _this2.lang.style.style,
                  data: {
                    toggle: 'dropdown'
                  }
                }), _this2.ui.dropdown({
                  className: 'dropdown-style',
                  items: _this2.options.styleTags,
                  title: _this2.lang.style.style,
                  template: function template(item) {
                    // TBD: need to be simplified
                    if (typeof item === 'string') {
                      item = {
                        tag: item,
                        title: Object.prototype.hasOwnProperty.call(_this2.lang.style, item) ? _this2.lang.style[item] : item
                      };
                    }

                    var tag = item.tag;
                    var title = item.title;
                    var style = item.style ? ' style="' + item.style + '" ' : '';
                    var className = item.className ? ' class="' + item.className + '"' : '';
                    return '<' + tag + style + className + '>' + title + '</' + tag + '>';
                  },
                  click: _this2.context.createInvokeHandler('editor.formatBlock')
                })]).render();
              });

              var _loop = function _loop(styleIdx, styleLen) {
                var item = _this2.options.styleTags[styleIdx];

                _this2.context.memo('button.style.' + item, function () {
                  return _this2.button({
                    className: 'note-btn-style-' + item,
                    contents: '<div data-value="' + item + '">' + item.toUpperCase() + '</div>',
                    tooltip: _this2.lang.style[item],
                    click: _this2.context.createInvokeHandler('editor.formatBlock')
                  }).render();
                });
              };

              for (var styleIdx = 0, styleLen = this.options.styleTags.length; styleIdx < styleLen; styleIdx++) {
                _loop(styleIdx, styleLen);
              }

              this.context.memo('button.bold', function () {
                return _this2.button({
                  className: 'note-btn-bold',
                  contents: _this2.ui.icon(_this2.options.icons.bold),
                  tooltip: _this2.lang.font.bold + _this2.representShortcut('bold'),
                  click: _this2.context.createInvokeHandlerAndUpdateState('editor.bold')
                }).render();
              });
              this.context.memo('button.italic', function () {
                return _this2.button({
                  className: 'note-btn-italic',
                  contents: _this2.ui.icon(_this2.options.icons.italic),
                  tooltip: _this2.lang.font.italic + _this2.representShortcut('italic'),
                  click: _this2.context.createInvokeHandlerAndUpdateState('editor.italic')
                }).render();
              });
              this.context.memo('button.underline', function () {
                return _this2.button({
                  className: 'note-btn-underline',
                  contents: _this2.ui.icon(_this2.options.icons.underline),
                  tooltip: _this2.lang.font.underline + _this2.representShortcut('underline'),
                  click: _this2.context.createInvokeHandlerAndUpdateState('editor.underline')
                }).render();
              });
              this.context.memo('button.clear', function () {
                return _this2.button({
                  contents: _this2.ui.icon(_this2.options.icons.eraser),
                  tooltip: _this2.lang.font.clear + _this2.representShortcut('removeFormat'),
                  click: _this2.context.createInvokeHandler('editor.removeFormat')
                }).render();
              });
              this.context.memo('button.strikethrough', function () {
                return _this2.button({
                  className: 'note-btn-strikethrough',
                  contents: _this2.ui.icon(_this2.options.icons.strikethrough),
                  tooltip: _this2.lang.font.strikethrough + _this2.representShortcut('strikethrough'),
                  click: _this2.context.createInvokeHandlerAndUpdateState('editor.strikethrough')
                }).render();
              });
              this.context.memo('button.superscript', function () {
                return _this2.button({
                  className: 'note-btn-superscript',
                  contents: _this2.ui.icon(_this2.options.icons.superscript),
                  tooltip: _this2.lang.font.superscript,
                  click: _this2.context.createInvokeHandlerAndUpdateState('editor.superscript')
                }).render();
              });
              this.context.memo('button.subscript', function () {
                return _this2.button({
                  className: 'note-btn-subscript',
                  contents: _this2.ui.icon(_this2.options.icons.subscript),
                  tooltip: _this2.lang.font.subscript,
                  click: _this2.context.createInvokeHandlerAndUpdateState('editor.subscript')
                }).render();
              });
              this.context.memo('button.fontname', function () {
                var styleInfo = _this2.context.invoke('editor.currentStyle');

                if (_this2.options.addDefaultFonts) {
                  // Add 'default' fonts into the fontnames array if not exist
                  external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(styleInfo['font-family'].split(','), function (idx, fontname) {
                    fontname = fontname.trim().replace(/['"]+/g, '');

                    if (_this2.isFontDeservedToAdd(fontname)) {
                      if (_this2.options.fontNames.indexOf(fontname) === -1) {
                        _this2.options.fontNames.push(fontname);
                      }
                    }
                  });
                }

                return _this2.ui.buttonGroup([_this2.button({
                  className: 'dropdown-toggle',
                  contents: _this2.ui.dropdownButtonContents('<span class="note-current-fontname"></span>', _this2.options),
                  tooltip: _this2.lang.font.name,
                  data: {
                    toggle: 'dropdown'
                  }
                }), _this2.ui.dropdownCheck({
                  className: 'dropdown-fontname',
                  checkClassName: _this2.options.icons.menuCheck,
                  items: _this2.options.fontNames.filter(_this2.isFontInstalled.bind(_this2)),
                  title: _this2.lang.font.name,
                  template: function template(item) {
                    return '<span style="font-family: ' + env.validFontName(item) + '">' + item + '</span>';
                  },
                  click: _this2.context.createInvokeHandlerAndUpdateState('editor.fontName')
                })]).render();
              });
              this.context.memo('button.fontsize', function () {
                return _this2.ui.buttonGroup([_this2.button({
                  className: 'dropdown-toggle',
                  contents: _this2.ui.dropdownButtonContents('<span class="note-current-fontsize"></span>', _this2.options),
                  tooltip: _this2.lang.font.size,
                  data: {
                    toggle: 'dropdown'
                  }
                }), _this2.ui.dropdownCheck({
                  className: 'dropdown-fontsize',
                  checkClassName: _this2.options.icons.menuCheck,
                  items: _this2.options.fontSizes,
                  title: _this2.lang.font.size,
                  click: _this2.context.createInvokeHandlerAndUpdateState('editor.fontSize')
                })]).render();
              });
              this.context.memo('button.fontsizeunit', function () {
                return _this2.ui.buttonGroup([_this2.button({
                  className: 'dropdown-toggle',
                  contents: _this2.ui.dropdownButtonContents('<span class="note-current-fontsizeunit"></span>', _this2.options),
                  tooltip: _this2.lang.font.sizeunit,
                  data: {
                    toggle: 'dropdown'
                  }
                }), _this2.ui.dropdownCheck({
                  className: 'dropdown-fontsizeunit',
                  checkClassName: _this2.options.icons.menuCheck,
                  items: _this2.options.fontSizeUnits,
                  title: _this2.lang.font.sizeunit,
                  click: _this2.context.createInvokeHandlerAndUpdateState('editor.fontSizeUnit')
                })]).render();
              });
              this.context.memo('button.color', function () {
                return _this2.colorPalette('note-color-all', _this2.lang.color.recent, true, true);
              });
              this.context.memo('button.forecolor', function () {
                return _this2.colorPalette('note-color-fore', _this2.lang.color.foreground, false, true);
              });
              this.context.memo('button.backcolor', function () {
                return _this2.colorPalette('note-color-back', _this2.lang.color.background, true, false);
              });
              this.context.memo('button.ul', function () {
                return _this2.button({
                  contents: _this2.ui.icon(_this2.options.icons.unorderedlist),
                  tooltip: _this2.lang.lists.unordered + _this2.representShortcut('insertUnorderedList'),
                  click: _this2.context.createInvokeHandler('editor.insertUnorderedList')
                }).render();
              });
              this.context.memo('button.ol', function () {
                return _this2.button({
                  contents: _this2.ui.icon(_this2.options.icons.orderedlist),
                  tooltip: _this2.lang.lists.ordered + _this2.representShortcut('insertOrderedList'),
                  click: _this2.context.createInvokeHandler('editor.insertOrderedList')
                }).render();
              });
              var justifyLeft = this.button({
                contents: this.ui.icon(this.options.icons.alignLeft),
                tooltip: this.lang.paragraph.left + this.representShortcut('justifyLeft'),
                click: this.context.createInvokeHandler('editor.justifyLeft')
              });
              var justifyCenter = this.button({
                contents: this.ui.icon(this.options.icons.alignCenter),
                tooltip: this.lang.paragraph.center + this.representShortcut('justifyCenter'),
                click: this.context.createInvokeHandler('editor.justifyCenter')
              });
              var justifyRight = this.button({
                contents: this.ui.icon(this.options.icons.alignRight),
                tooltip: this.lang.paragraph.right + this.representShortcut('justifyRight'),
                click: this.context.createInvokeHandler('editor.justifyRight')
              });
              var justifyFull = this.button({
                contents: this.ui.icon(this.options.icons.alignJustify),
                tooltip: this.lang.paragraph.justify + this.representShortcut('justifyFull'),
                click: this.context.createInvokeHandler('editor.justifyFull')
              });
              var outdent = this.button({
                contents: this.ui.icon(this.options.icons.outdent),
                tooltip: this.lang.paragraph.outdent + this.representShortcut('outdent'),
                click: this.context.createInvokeHandler('editor.outdent')
              });
              var indent = this.button({
                contents: this.ui.icon(this.options.icons.indent),
                tooltip: this.lang.paragraph.indent + this.representShortcut('indent'),
                click: this.context.createInvokeHandler('editor.indent')
              });
              this.context.memo('button.justifyLeft', func.invoke(justifyLeft, 'render'));
              this.context.memo('button.justifyCenter', func.invoke(justifyCenter, 'render'));
              this.context.memo('button.justifyRight', func.invoke(justifyRight, 'render'));
              this.context.memo('button.justifyFull', func.invoke(justifyFull, 'render'));
              this.context.memo('button.outdent', func.invoke(outdent, 'render'));
              this.context.memo('button.indent', func.invoke(indent, 'render'));
              this.context.memo('button.paragraph', function () {
                return _this2.ui.buttonGroup([_this2.button({
                  className: 'dropdown-toggle',
                  contents: _this2.ui.dropdownButtonContents(_this2.ui.icon(_this2.options.icons.alignLeft), _this2.options),
                  tooltip: _this2.lang.paragraph.paragraph,
                  data: {
                    toggle: 'dropdown'
                  }
                }), _this2.ui.dropdown([_this2.ui.buttonGroup({
                  className: 'note-align',
                  children: [justifyLeft, justifyCenter, justifyRight, justifyFull]
                }), _this2.ui.buttonGroup({
                  className: 'note-list',
                  children: [outdent, indent]
                })])]).render();
              });
              this.context.memo('button.height', function () {
                return _this2.ui.buttonGroup([_this2.button({
                  className: 'dropdown-toggle',
                  contents: _this2.ui.dropdownButtonContents(_this2.ui.icon(_this2.options.icons.textHeight), _this2.options),
                  tooltip: _this2.lang.font.height,
                  data: {
                    toggle: 'dropdown'
                  }
                }), _this2.ui.dropdownCheck({
                  items: _this2.options.lineHeights,
                  checkClassName: _this2.options.icons.menuCheck,
                  className: 'dropdown-line-height',
                  title: _this2.lang.font.height,
                  click: _this2.context.createInvokeHandler('editor.lineHeight')
                })]).render();
              });
              this.context.memo('button.table', function () {
                return _this2.ui.buttonGroup([_this2.button({
                  className: 'dropdown-toggle',
                  contents: _this2.ui.dropdownButtonContents(_this2.ui.icon(_this2.options.icons.table), _this2.options),
                  tooltip: _this2.lang.table.table,
                  data: {
                    toggle: 'dropdown'
                  }
                }), _this2.ui.dropdown({
                  title: _this2.lang.table.table,
                  className: 'note-table',
                  items: ['<div class="note-dimension-picker">', '<div class="note-dimension-picker-mousecatcher" data-event="insertTable" data-value="1x1"></div>', '<div class="note-dimension-picker-highlighted"></div>', '<div class="note-dimension-picker-unhighlighted"></div>', '</div>', '<div class="note-dimension-display">1 x 1</div>'].join('')
                })], {
                  callback: function callback($node) {
                    var $catcher = $node.find('.note-dimension-picker-mousecatcher');
                    $catcher.css({
                      width: _this2.options.insertTableMaxSize.col + 'em',
                      height: _this2.options.insertTableMaxSize.row + 'em'
                    }).mousedown(_this2.context.createInvokeHandler('editor.insertTable')).on('mousemove', _this2.tableMoveHandler.bind(_this2));
                  }
                }).render();
              });
              this.context.memo('button.link', function () {
                return _this2.button({
                  contents: _this2.ui.icon(_this2.options.icons.link),
                  tooltip: _this2.lang.link.link + _this2.representShortcut('linkDialog.show'),
                  click: _this2.context.createInvokeHandler('linkDialog.show')
                }).render();
              });
              this.context.memo('button.picture', function () {
                return _this2.button({
                  contents: _this2.ui.icon(_this2.options.icons.picture),
                  tooltip: _this2.lang.image.image,
                  click: _this2.context.createInvokeHandler('imageDialog.show')
                }).render();
              });
              this.context.memo('button.video', function () {
                return _this2.button({
                  contents: _this2.ui.icon(_this2.options.icons.video),
                  tooltip: _this2.lang.video.video,
                  click: _this2.context.createInvokeHandler('videoDialog.show')
                }).render();
              });
              this.context.memo('button.hr', function () {
                return _this2.button({
                  contents: _this2.ui.icon(_this2.options.icons.minus),
                  tooltip: _this2.lang.hr.insert + _this2.representShortcut('insertHorizontalRule'),
                  click: _this2.context.createInvokeHandler('editor.insertHorizontalRule')
                }).render();
              });
              this.context.memo('button.fullscreen', function () {
                return _this2.button({
                  className: 'btn-fullscreen note-codeview-keep',
                  contents: _this2.ui.icon(_this2.options.icons.arrowsAlt),
                  tooltip: _this2.lang.options.fullscreen,
                  click: _this2.context.createInvokeHandler('fullscreen.toggle')
                }).render();
              });
              this.context.memo('button.codeview', function () {
                return _this2.button({
                  className: 'btn-codeview note-codeview-keep',
                  contents: _this2.ui.icon(_this2.options.icons.code),
                  tooltip: _this2.lang.options.codeview,
                  click: _this2.context.createInvokeHandler('codeview.toggle')
                }).render();
              });
              this.context.memo('button.redo', function () {
                return _this2.button({
                  contents: _this2.ui.icon(_this2.options.icons.redo),
                  tooltip: _this2.lang.history.redo + _this2.representShortcut('redo'),
                  click: _this2.context.createInvokeHandler('editor.redo')
                }).render();
              });
              this.context.memo('button.undo', function () {
                return _this2.button({
                  contents: _this2.ui.icon(_this2.options.icons.undo),
                  tooltip: _this2.lang.history.undo + _this2.representShortcut('undo'),
                  click: _this2.context.createInvokeHandler('editor.undo')
                }).render();
              });
              this.context.memo('button.help', function () {
                return _this2.button({
                  contents: _this2.ui.icon(_this2.options.icons.question),
                  tooltip: _this2.lang.options.help,
                  click: _this2.context.createInvokeHandler('helpDialog.show')
                }).render();
              });
            }
            /**
             * image: [
             *   ['imageResize', ['resizeFull', 'resizeHalf', 'resizeQuarter', 'resizeNone']],
             *   ['float', ['floatLeft', 'floatRight', 'floatNone']],
             *   ['remove', ['removeMedia']],
             * ],
             */

          }, {
            key: "addImagePopoverButtons",
            value: function addImagePopoverButtons() {
              var _this3 = this; // Image Size Buttons


              this.context.memo('button.resizeFull', function () {
                return _this3.button({
                  contents: '<span class="note-fontsize-10">100%</span>',
                  tooltip: _this3.lang.image.resizeFull,
                  click: _this3.context.createInvokeHandler('editor.resize', '1')
                }).render();
              });
              this.context.memo('button.resizeHalf', function () {
                return _this3.button({
                  contents: '<span class="note-fontsize-10">50%</span>',
                  tooltip: _this3.lang.image.resizeHalf,
                  click: _this3.context.createInvokeHandler('editor.resize', '0.5')
                }).render();
              });
              this.context.memo('button.resizeQuarter', function () {
                return _this3.button({
                  contents: '<span class="note-fontsize-10">25%</span>',
                  tooltip: _this3.lang.image.resizeQuarter,
                  click: _this3.context.createInvokeHandler('editor.resize', '0.25')
                }).render();
              });
              this.context.memo('button.resizeNone', function () {
                return _this3.button({
                  contents: _this3.ui.icon(_this3.options.icons.rollback),
                  tooltip: _this3.lang.image.resizeNone,
                  click: _this3.context.createInvokeHandler('editor.resize', '0')
                }).render();
              }); // Float Buttons

              this.context.memo('button.floatLeft', function () {
                return _this3.button({
                  contents: _this3.ui.icon(_this3.options.icons.floatLeft),
                  tooltip: _this3.lang.image.floatLeft,
                  click: _this3.context.createInvokeHandler('editor.floatMe', 'left')
                }).render();
              });
              this.context.memo('button.floatRight', function () {
                return _this3.button({
                  contents: _this3.ui.icon(_this3.options.icons.floatRight),
                  tooltip: _this3.lang.image.floatRight,
                  click: _this3.context.createInvokeHandler('editor.floatMe', 'right')
                }).render();
              });
              this.context.memo('button.floatNone', function () {
                return _this3.button({
                  contents: _this3.ui.icon(_this3.options.icons.rollback),
                  tooltip: _this3.lang.image.floatNone,
                  click: _this3.context.createInvokeHandler('editor.floatMe', 'none')
                }).render();
              }); // Remove Buttons

              this.context.memo('button.removeMedia', function () {
                return _this3.button({
                  contents: _this3.ui.icon(_this3.options.icons.trash),
                  tooltip: _this3.lang.image.remove,
                  click: _this3.context.createInvokeHandler('editor.removeMedia')
                }).render();
              });
            }
          }, {
            key: "addLinkPopoverButtons",
            value: function addLinkPopoverButtons() {
              var _this4 = this;

              this.context.memo('button.linkDialogShow', function () {
                return _this4.button({
                  contents: _this4.ui.icon(_this4.options.icons.link),
                  tooltip: _this4.lang.link.edit,
                  click: _this4.context.createInvokeHandler('linkDialog.show')
                }).render();
              });
              this.context.memo('button.unlink', function () {
                return _this4.button({
                  contents: _this4.ui.icon(_this4.options.icons.unlink),
                  tooltip: _this4.lang.link.unlink,
                  click: _this4.context.createInvokeHandler('editor.unlink')
                }).render();
              });
            }
            /**
             * table : [
             *  ['add', ['addRowDown', 'addRowUp', 'addColLeft', 'addColRight']],
             *  ['delete', ['deleteRow', 'deleteCol', 'deleteTable']]
             * ],
             */

          }, {
            key: "addTablePopoverButtons",
            value: function addTablePopoverButtons() {
              var _this5 = this;

              this.context.memo('button.addRowUp', function () {
                return _this5.button({
                  className: 'btn-md',
                  contents: _this5.ui.icon(_this5.options.icons.rowAbove),
                  tooltip: _this5.lang.table.addRowAbove,
                  click: _this5.context.createInvokeHandler('editor.addRow', 'top')
                }).render();
              });
              this.context.memo('button.addRowDown', function () {
                return _this5.button({
                  className: 'btn-md',
                  contents: _this5.ui.icon(_this5.options.icons.rowBelow),
                  tooltip: _this5.lang.table.addRowBelow,
                  click: _this5.context.createInvokeHandler('editor.addRow', 'bottom')
                }).render();
              });
              this.context.memo('button.addColLeft', function () {
                return _this5.button({
                  className: 'btn-md',
                  contents: _this5.ui.icon(_this5.options.icons.colBefore),
                  tooltip: _this5.lang.table.addColLeft,
                  click: _this5.context.createInvokeHandler('editor.addCol', 'left')
                }).render();
              });
              this.context.memo('button.addColRight', function () {
                return _this5.button({
                  className: 'btn-md',
                  contents: _this5.ui.icon(_this5.options.icons.colAfter),
                  tooltip: _this5.lang.table.addColRight,
                  click: _this5.context.createInvokeHandler('editor.addCol', 'right')
                }).render();
              });
              this.context.memo('button.deleteRow', function () {
                return _this5.button({
                  className: 'btn-md',
                  contents: _this5.ui.icon(_this5.options.icons.rowRemove),
                  tooltip: _this5.lang.table.delRow,
                  click: _this5.context.createInvokeHandler('editor.deleteRow')
                }).render();
              });
              this.context.memo('button.deleteCol', function () {
                return _this5.button({
                  className: 'btn-md',
                  contents: _this5.ui.icon(_this5.options.icons.colRemove),
                  tooltip: _this5.lang.table.delCol,
                  click: _this5.context.createInvokeHandler('editor.deleteCol')
                }).render();
              });
              this.context.memo('button.deleteTable', function () {
                return _this5.button({
                  className: 'btn-md',
                  contents: _this5.ui.icon(_this5.options.icons.trash),
                  tooltip: _this5.lang.table.delTable,
                  click: _this5.context.createInvokeHandler('editor.deleteTable')
                }).render();
              });
            }
          }, {
            key: "build",
            value: function build($container, groups) {
              for (var groupIdx = 0, groupLen = groups.length; groupIdx < groupLen; groupIdx++) {
                var group = groups[groupIdx];
                var groupName = Array.isArray(group) ? group[0] : group;
                var buttons = Array.isArray(group) ? group.length === 1 ? [group[0]] : group[1] : [group];
                var $group = this.ui.buttonGroup({
                  className: 'note-' + groupName
                }).render();

                for (var idx = 0, len = buttons.length; idx < len; idx++) {
                  var btn = this.context.memo('button.' + buttons[idx]);

                  if (btn) {
                    $group.append(typeof btn === 'function' ? btn(this.context) : btn);
                  }
                }

                $group.appendTo($container);
              }
            }
            /**
             * @param {jQuery} [$container]
             */

          }, {
            key: "updateCurrentStyle",
            value: function updateCurrentStyle($container) {
              var _this6 = this;

              var $cont = $container || this.$toolbar;
              var styleInfo = this.context.invoke('editor.currentStyle');
              this.updateBtnStates($cont, {
                '.note-btn-bold': function noteBtnBold() {
                  return styleInfo['font-bold'] === 'bold';
                },
                '.note-btn-italic': function noteBtnItalic() {
                  return styleInfo['font-italic'] === 'italic';
                },
                '.note-btn-underline': function noteBtnUnderline() {
                  return styleInfo['font-underline'] === 'underline';
                },
                '.note-btn-subscript': function noteBtnSubscript() {
                  return styleInfo['font-subscript'] === 'subscript';
                },
                '.note-btn-superscript': function noteBtnSuperscript() {
                  return styleInfo['font-superscript'] === 'superscript';
                },
                '.note-btn-strikethrough': function noteBtnStrikethrough() {
                  return styleInfo['font-strikethrough'] === 'strikethrough';
                }
              });

              if (styleInfo['font-family']) {
                var fontNames = styleInfo['font-family'].split(',').map(function (name) {
                  return name.replace(/[\'\"]/g, '').replace(/\s+$/, '').replace(/^\s+/, '');
                });
                var fontName = lists.find(fontNames, this.isFontInstalled.bind(this));
                $cont.find('.dropdown-fontname a').each(function (idx, item) {
                  var $item = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(item); // always compare string to avoid creating another func.

                  var isChecked = $item.data('value') + '' === fontName + '';
                  $item.toggleClass('checked', isChecked);
                });
                $cont.find('.note-current-fontname').text(fontName).css('font-family', fontName);
              }

              if (styleInfo['font-size']) {
                var fontSize = styleInfo['font-size'];
                $cont.find('.dropdown-fontsize a').each(function (idx, item) {
                  var $item = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(item); // always compare with string to avoid creating another func.

                  var isChecked = $item.data('value') + '' === fontSize + '';
                  $item.toggleClass('checked', isChecked);
                });
                $cont.find('.note-current-fontsize').text(fontSize);
                var fontSizeUnit = styleInfo['font-size-unit'];
                $cont.find('.dropdown-fontsizeunit a').each(function (idx, item) {
                  var $item = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(item);
                  var isChecked = $item.data('value') + '' === fontSizeUnit + '';
                  $item.toggleClass('checked', isChecked);
                });
                $cont.find('.note-current-fontsizeunit').text(fontSizeUnit);
              }

              if (styleInfo['line-height']) {
                var lineHeight = styleInfo['line-height'];
                $cont.find('.dropdown-line-height li a').each(function (idx, item) {
                  // always compare with string to avoid creating another func.
                  var isChecked = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(item).data('value') + '' === lineHeight + '';
                  _this6.className = isChecked ? 'checked' : '';
                });
              }
            }
          }, {
            key: "updateBtnStates",
            value: function updateBtnStates($container, infos) {
              var _this7 = this;

              external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.each(infos, function (selector, pred) {
                _this7.ui.toggleBtnActive($container.find(selector), pred());
              });
            }
          }, {
            key: "tableMoveHandler",
            value: function tableMoveHandler(event) {
              var PX_PER_EM = 18;
              var $picker = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(event.target.parentNode); // target is mousecatcher

              var $dimensionDisplay = $picker.next();
              var $catcher = $picker.find('.note-dimension-picker-mousecatcher');
              var $highlighted = $picker.find('.note-dimension-picker-highlighted');
              var $unhighlighted = $picker.find('.note-dimension-picker-unhighlighted');
              var posOffset; // HTML5 with jQuery - e.offsetX is undefined in Firefox

              if (event.offsetX === undefined) {
                var posCatcher = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(event.target).offset();
                posOffset = {
                  x: event.pageX - posCatcher.left,
                  y: event.pageY - posCatcher.top
                };
              } else {
                posOffset = {
                  x: event.offsetX,
                  y: event.offsetY
                };
              }

              var dim = {
                c: Math.ceil(posOffset.x / PX_PER_EM) || 1,
                r: Math.ceil(posOffset.y / PX_PER_EM) || 1
              };
              $highlighted.css({
                width: dim.c + 'em',
                height: dim.r + 'em'
              });
              $catcher.data('value', dim.c + 'x' + dim.r);

              if (dim.c > 3 && dim.c < this.options.insertTableMaxSize.col) {
                $unhighlighted.css({
                  width: dim.c + 1 + 'em'
                });
              }

              if (dim.r > 3 && dim.r < this.options.insertTableMaxSize.row) {
                $unhighlighted.css({
                  height: dim.r + 1 + 'em'
                });
              }

              $dimensionDisplay.html(dim.c + ' x ' + dim.r);
            }
          }]);
          return Buttons;
        }(); // CONCATENATED MODULE: ./src/js/base/module/Toolbar.js


        function Toolbar_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function Toolbar_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function Toolbar_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) Toolbar_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) Toolbar_defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var Toolbar_Toolbar = /*#__PURE__*/function () {
          function Toolbar(context) {
            Toolbar_classCallCheck(this, Toolbar);
            this.context = context;
            this.$window = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(window);
            this.$document = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(document);
            this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
            this.$note = context.layoutInfo.note;
            this.$editor = context.layoutInfo.editor;
            this.$toolbar = context.layoutInfo.toolbar;
            this.$editable = context.layoutInfo.editable;
            this.$statusbar = context.layoutInfo.statusbar;
            this.options = context.options;
            this.isFollowing = false;
            this.followScroll = this.followScroll.bind(this);
          }

          Toolbar_createClass(Toolbar, [{
            key: "shouldInitialize",
            value: function shouldInitialize() {
              return !this.options.airMode;
            }
          }, {
            key: "initialize",
            value: function initialize() {
              var _this = this;

              this.options.toolbar = this.options.toolbar || [];

              if (!this.options.toolbar.length) {
                this.$toolbar.hide();
              } else {
                this.context.invoke('buttons.build', this.$toolbar, this.options.toolbar);
              }

              if (this.options.toolbarContainer) {
                this.$toolbar.appendTo(this.options.toolbarContainer);
              }

              this.changeContainer(false);
              this.$note.on('summernote.keyup summernote.mouseup summernote.change', function () {
                _this.context.invoke('buttons.updateCurrentStyle');
              });
              this.context.invoke('buttons.updateCurrentStyle');

              if (this.options.followingToolbar) {
                this.$window.on('scroll resize', this.followScroll);
              }
            }
          }, {
            key: "destroy",
            value: function destroy() {
              this.$toolbar.children().remove();

              if (this.options.followingToolbar) {
                this.$window.off('scroll resize', this.followScroll);
              }
            }
          }, {
            key: "followScroll",
            value: function followScroll() {
              if (this.$editor.hasClass('fullscreen')) {
                return false;
              }

              var editorHeight = this.$editor.outerHeight();
              var editorWidth = this.$editor.width();
              var toolbarHeight = this.$toolbar.height();
              var statusbarHeight = this.$statusbar.height(); // check if the web app is currently using another static bar

              var otherBarHeight = 0;

              if (this.options.otherStaticBar) {
                otherBarHeight = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(this.options.otherStaticBar).outerHeight();
              }

              var currentOffset = this.$document.scrollTop();
              var editorOffsetTop = this.$editor.offset().top;
              var editorOffsetBottom = editorOffsetTop + editorHeight;
              var activateOffset = editorOffsetTop - otherBarHeight;
              var deactivateOffsetBottom = editorOffsetBottom - otherBarHeight - toolbarHeight - statusbarHeight;

              if (!this.isFollowing && currentOffset > activateOffset && currentOffset < deactivateOffsetBottom - toolbarHeight) {
                this.isFollowing = true;
                this.$editable.css({
                  marginTop: this.$toolbar.outerHeight()
                });
                this.$toolbar.css({
                  position: 'fixed',
                  top: otherBarHeight,
                  width: editorWidth,
                  zIndex: 1000
                });
              } else if (this.isFollowing && (currentOffset < activateOffset || currentOffset > deactivateOffsetBottom)) {
                this.isFollowing = false;
                this.$toolbar.css({
                  position: 'relative',
                  top: 0,
                  width: '100%',
                  zIndex: 'auto'
                });
                this.$editable.css({
                  marginTop: ''
                });
              }
            }
          }, {
            key: "changeContainer",
            value: function changeContainer(isFullscreen) {
              if (isFullscreen) {
                this.$toolbar.prependTo(this.$editor);
              } else {
                if (this.options.toolbarContainer) {
                  this.$toolbar.appendTo(this.options.toolbarContainer);
                }
              }

              if (this.options.followingToolbar) {
                this.followScroll();
              }
            }
          }, {
            key: "updateFullscreen",
            value: function updateFullscreen(isFullscreen) {
              this.ui.toggleBtnActive(this.$toolbar.find('.btn-fullscreen'), isFullscreen);
              this.changeContainer(isFullscreen);
            }
          }, {
            key: "updateCodeview",
            value: function updateCodeview(isCodeview) {
              this.ui.toggleBtnActive(this.$toolbar.find('.btn-codeview'), isCodeview);

              if (isCodeview) {
                this.deactivate();
              } else {
                this.activate();
              }
            }
          }, {
            key: "activate",
            value: function activate(isIncludeCodeview) {
              var $btn = this.$toolbar.find('button');

              if (!isIncludeCodeview) {
                $btn = $btn.not('.note-codeview-keep');
              }

              this.ui.toggleBtn($btn, true);
            }
          }, {
            key: "deactivate",
            value: function deactivate(isIncludeCodeview) {
              var $btn = this.$toolbar.find('button');

              if (!isIncludeCodeview) {
                $btn = $btn.not('.note-codeview-keep');
              }

              this.ui.toggleBtn($btn, false);
            }
          }]);
          return Toolbar;
        }(); // CONCATENATED MODULE: ./src/js/base/module/LinkDialog.js


        function LinkDialog_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function LinkDialog_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function LinkDialog_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) LinkDialog_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) LinkDialog_defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var LinkDialog_LinkDialog = /*#__PURE__*/function () {
          function LinkDialog(context) {
            LinkDialog_classCallCheck(this, LinkDialog);
            this.context = context;
            this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
            this.$body = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(document.body);
            this.$editor = context.layoutInfo.editor;
            this.options = context.options;
            this.lang = this.options.langInfo;
            context.memo('help.linkDialog.show', this.options.langInfo.help['linkDialog.show']);
          }

          LinkDialog_createClass(LinkDialog, [{
            key: "initialize",
            value: function initialize() {
              var $container = this.options.dialogsInBody ? this.$body : this.options.container;
              var body = ['<div class="form-group note-form-group">', "<label for=\"note-dialog-link-txt-".concat(this.options.id, "\" class=\"note-form-label\">").concat(this.lang.link.textToDisplay, "</label>"), "<input id=\"note-dialog-link-txt-".concat(this.options.id, "\" class=\"note-link-text form-control note-form-control note-input\" type=\"text\"/>"), '</div>', '<div class="form-group note-form-group">', "<label for=\"note-dialog-link-url-".concat(this.options.id, "\" class=\"note-form-label\">").concat(this.lang.link.url, "</label>"), "<input id=\"note-dialog-link-url-".concat(this.options.id, "\" class=\"note-link-url form-control note-form-control note-input\" type=\"text\" value=\"http://\"/>"), '</div>', !this.options.disableLinkTarget ? external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<div/>').append(this.ui.checkbox({
                className: 'sn-checkbox-open-in-new-window',
                text: this.lang.link.openInNewWindow,
                checked: true
              }).render()).html() : '', external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<div/>').append(this.ui.checkbox({
                className: 'sn-checkbox-use-protocol',
                text: this.lang.link.useProtocol,
                checked: true
              }).render()).html()].join('');
              var buttonClass = 'btn btn-primary note-btn note-btn-primary note-link-btn';
              var footer = "<input type=\"button\" href=\"#\" class=\"".concat(buttonClass, "\" value=\"").concat(this.lang.link.insert, "\" disabled>");
              this.$dialog = this.ui.dialog({
                className: 'link-dialog',
                title: this.lang.link.insert,
                fade: this.options.dialogsFade,
                body: body,
                footer: footer
              }).render().appendTo($container);
            }
          }, {
            key: "destroy",
            value: function destroy() {
              this.ui.hideDialog(this.$dialog);
              this.$dialog.remove();
            }
          }, {
            key: "bindEnterKey",
            value: function bindEnterKey($input, $btn) {
              $input.on('keypress', function (event) {
                if (event.keyCode === core_key.code.ENTER) {
                  event.preventDefault();
                  $btn.trigger('click');
                }
              });
            }
            /**
             * toggle update button
             */

          }, {
            key: "toggleLinkBtn",
            value: function toggleLinkBtn($linkBtn, $linkText, $linkUrl) {
              this.ui.toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());
            }
            /**
             * Show link dialog and set event handlers on dialog controls.
             *
             * @param {Object} linkInfo
             * @return {Promise}
             */

          }, {
            key: "showLinkDialog",
            value: function showLinkDialog(linkInfo) {
              var _this = this;

              return external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.Deferred(function (deferred) {
                var $linkText = _this.$dialog.find('.note-link-text');

                var $linkUrl = _this.$dialog.find('.note-link-url');

                var $linkBtn = _this.$dialog.find('.note-link-btn');

                var $openInNewWindow = _this.$dialog.find('.sn-checkbox-open-in-new-window input[type=checkbox]');

                var $useProtocol = _this.$dialog.find('.sn-checkbox-use-protocol input[type=checkbox]');

                _this.ui.onDialogShown(_this.$dialog, function () {
                  _this.context.triggerEvent('dialog.shown'); // If no url was given and given text is valid URL then copy that into URL Field


                  if (!linkInfo.url && func.isValidUrl(linkInfo.text)) {
                    linkInfo.url = linkInfo.text;
                  }

                  $linkText.on('input paste propertychange', function () {
                    // If linktext was modified by input events,
                    // cloning text from linkUrl will be stopped.
                    linkInfo.text = $linkText.val();

                    _this.toggleLinkBtn($linkBtn, $linkText, $linkUrl);
                  }).val(linkInfo.text);
                  $linkUrl.on('input paste propertychange', function () {
                    // Display same text on `Text to display` as default
                    // when linktext has no text
                    if (!linkInfo.text) {
                      $linkText.val($linkUrl.val());
                    }

                    _this.toggleLinkBtn($linkBtn, $linkText, $linkUrl);
                  }).val(linkInfo.url);

                  if (!env.isSupportTouch) {
                    $linkUrl.trigger('focus');
                  }

                  _this.toggleLinkBtn($linkBtn, $linkText, $linkUrl);

                  _this.bindEnterKey($linkUrl, $linkBtn);

                  _this.bindEnterKey($linkText, $linkBtn);

                  var isNewWindowChecked = linkInfo.isNewWindow !== undefined ? linkInfo.isNewWindow : _this.context.options.linkTargetBlank;
                  $openInNewWindow.prop('checked', isNewWindowChecked);
                  var useProtocolChecked = linkInfo.url ? false : _this.context.options.useProtocol;
                  $useProtocol.prop('checked', useProtocolChecked);
                  $linkBtn.one('click', function (event) {
                    event.preventDefault();
                    deferred.resolve({
                      range: linkInfo.range,
                      url: $linkUrl.val(),
                      text: $linkText.val(),
                      isNewWindow: $openInNewWindow.is(':checked'),
                      checkProtocol: $useProtocol.is(':checked')
                    });

                    _this.ui.hideDialog(_this.$dialog);
                  });
                });

                _this.ui.onDialogHidden(_this.$dialog, function () {
                  // detach events
                  $linkText.off();
                  $linkUrl.off();
                  $linkBtn.off();

                  if (deferred.state() === 'pending') {
                    deferred.reject();
                  }
                });

                _this.ui.showDialog(_this.$dialog);
              }).promise();
            }
            /**
             * @param {Object} layoutInfo
             */

          }, {
            key: "show",
            value: function show() {
              var _this2 = this;

              var linkInfo = this.context.invoke('editor.getLinkInfo');
              this.context.invoke('editor.saveRange');
              this.showLinkDialog(linkInfo).then(function (linkInfo) {
                _this2.context.invoke('editor.restoreRange');

                _this2.context.invoke('editor.createLink', linkInfo);
              }).fail(function () {
                _this2.context.invoke('editor.restoreRange');
              });
            }
          }]);
          return LinkDialog;
        }(); // CONCATENATED MODULE: ./src/js/base/module/LinkPopover.js


        function LinkPopover_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function LinkPopover_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function LinkPopover_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) LinkPopover_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) LinkPopover_defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var LinkPopover_LinkPopover = /*#__PURE__*/function () {
          function LinkPopover(context) {
            var _this = this;

            LinkPopover_classCallCheck(this, LinkPopover);
            this.context = context;
            this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
            this.options = context.options;
            this.events = {
              'summernote.keyup summernote.mouseup summernote.change summernote.scroll': function summernoteKeyupSummernoteMouseupSummernoteChangeSummernoteScroll() {
                _this.update();
              },
              'summernote.disable summernote.dialog.shown summernote.blur': function summernoteDisableSummernoteDialogShownSummernoteBlur() {
                _this.hide();
              }
            };
          }

          LinkPopover_createClass(LinkPopover, [{
            key: "shouldInitialize",
            value: function shouldInitialize() {
              return !lists.isEmpty(this.options.popover.link);
            }
          }, {
            key: "initialize",
            value: function initialize() {
              this.$popover = this.ui.popover({
                className: 'note-link-popover',
                callback: function callback($node) {
                  var $content = $node.find('.popover-content,.note-popover-content');
                  $content.prepend('<span><a target="_blank"></a>&nbsp;</span>');
                }
              }).render().appendTo(this.options.container);
              var $content = this.$popover.find('.popover-content,.note-popover-content');
              this.context.invoke('buttons.build', $content, this.options.popover.link);
              this.$popover.on('mousedown', function (e) {
                e.preventDefault();
              });
            }
          }, {
            key: "destroy",
            value: function destroy() {
              this.$popover.remove();
            }
          }, {
            key: "update",
            value: function update() {
              // Prevent focusing on editable when invoke('code') is executed
              if (!this.context.invoke('editor.hasFocus')) {
                this.hide();
                return;
              }

              var rng = this.context.invoke('editor.getLastRange');

              if (rng.isCollapsed() && rng.isOnAnchor()) {
                var anchor = dom.ancestor(rng.sc, dom.isAnchor);
                var href = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(anchor).attr('href');
                this.$popover.find('a').attr('href', href).text(href);
                var pos = dom.posFromPlaceholder(anchor);
                var containerOffset = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(this.options.container).offset();
                pos.top -= containerOffset.top;
                pos.left -= containerOffset.left;
                this.$popover.css({
                  display: 'block',
                  left: pos.left,
                  top: pos.top
                });
              } else {
                this.hide();
              }
            }
          }, {
            key: "hide",
            value: function hide() {
              this.$popover.hide();
            }
          }]);
          return LinkPopover;
        }(); // CONCATENATED MODULE: ./src/js/base/module/ImageDialog.js


        function ImageDialog_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function ImageDialog_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function ImageDialog_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) ImageDialog_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) ImageDialog_defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var ImageDialog_ImageDialog = /*#__PURE__*/function () {
          function ImageDialog(context) {
            ImageDialog_classCallCheck(this, ImageDialog);
            this.context = context;
            this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
            this.$body = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(document.body);
            this.$editor = context.layoutInfo.editor;
            this.options = context.options;
            this.lang = this.options.langInfo;
          }

          ImageDialog_createClass(ImageDialog, [{
            key: "initialize",
            value: function initialize() {
              var imageLimitation = '';

              if (this.options.maximumImageFileSize) {
                var unit = Math.floor(Math.log(this.options.maximumImageFileSize) / Math.log(1024));
                var readableSize = (this.options.maximumImageFileSize / Math.pow(1024, unit)).toFixed(2) * 1 + ' ' + ' KMGTP'[unit] + 'B';
                imageLimitation = "<small>".concat(this.lang.image.maximumFileSize + ' : ' + readableSize, "</small>");
              }

              var $container = this.options.dialogsInBody ? this.$body : this.options.container;
              var body = ['<div class="form-group note-form-group note-group-select-from-files">', '<label for="note-dialog-image-file-' + this.options.id + '" class="note-form-label">' + this.lang.image.selectFromFiles + '</label>', '<input id="note-dialog-image-file-' + this.options.id + '" class="note-image-input form-control-file note-form-control note-input" ', ' type="file" name="files" accept="image/*" multiple="multiple"/>', imageLimitation, '</div>', '<div class="form-group note-group-image-url">', '<label for="note-dialog-image-url-' + this.options.id + '" class="note-form-label">' + this.lang.image.url + '</label>', '<input id="note-dialog-image-url-' + this.options.id + '" class="note-image-url form-control note-form-control note-input" type="text"/>', '</div>'].join('');
              var buttonClass = 'btn btn-primary note-btn note-btn-primary note-image-btn';
              var footer = "<input type=\"button\" href=\"#\" class=\"".concat(buttonClass, "\" value=\"").concat(this.lang.image.insert, "\" disabled>");
              this.$dialog = this.ui.dialog({
                title: this.lang.image.insert,
                fade: this.options.dialogsFade,
                body: body,
                footer: footer
              }).render().appendTo($container);
            }
          }, {
            key: "destroy",
            value: function destroy() {
              this.ui.hideDialog(this.$dialog);
              this.$dialog.remove();
            }
          }, {
            key: "bindEnterKey",
            value: function bindEnterKey($input, $btn) {
              $input.on('keypress', function (event) {
                if (event.keyCode === core_key.code.ENTER) {
                  event.preventDefault();
                  $btn.trigger('click');
                }
              });
            }
          }, {
            key: "show",
            value: function show() {
              var _this = this;

              this.context.invoke('editor.saveRange');
              this.showImageDialog().then(function (data) {
                // [workaround] hide dialog before restore range for IE range focus
                _this.ui.hideDialog(_this.$dialog);

                _this.context.invoke('editor.restoreRange');

                if (typeof data === 'string') {
                  // image url
                  // If onImageLinkInsert set,
                  if (_this.options.callbacks.onImageLinkInsert) {
                    _this.context.triggerEvent('image.link.insert', data);
                  } else {
                    _this.context.invoke('editor.insertImage', data);
                  }
                } else {
                  // array of files
                  _this.context.invoke('editor.insertImagesOrCallback', data);
                }
              }).fail(function () {
                _this.context.invoke('editor.restoreRange');
              });
            }
            /**
             * show image dialog
             *
             * @param {jQuery} $dialog
             * @return {Promise}
             */

          }, {
            key: "showImageDialog",
            value: function showImageDialog() {
              var _this2 = this;

              return external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.Deferred(function (deferred) {
                var $imageInput = _this2.$dialog.find('.note-image-input');

                var $imageUrl = _this2.$dialog.find('.note-image-url');

                var $imageBtn = _this2.$dialog.find('.note-image-btn');

                _this2.ui.onDialogShown(_this2.$dialog, function () {
                  _this2.context.triggerEvent('dialog.shown'); // Cloning imageInput to clear element.


                  $imageInput.replaceWith($imageInput.clone().on('change', function (event) {
                    deferred.resolve(event.target.files || event.target.value);
                  }).val(''));
                  $imageUrl.on('input paste propertychange', function () {
                    _this2.ui.toggleBtn($imageBtn, $imageUrl.val());
                  }).val('');

                  if (!env.isSupportTouch) {
                    $imageUrl.trigger('focus');
                  }

                  $imageBtn.click(function (event) {
                    event.preventDefault();
                    deferred.resolve($imageUrl.val());
                  });

                  _this2.bindEnterKey($imageUrl, $imageBtn);
                });

                _this2.ui.onDialogHidden(_this2.$dialog, function () {
                  $imageInput.off();
                  $imageUrl.off();
                  $imageBtn.off();

                  if (deferred.state() === 'pending') {
                    deferred.reject();
                  }
                });

                _this2.ui.showDialog(_this2.$dialog);
              });
            }
          }]);
          return ImageDialog;
        }(); // CONCATENATED MODULE: ./src/js/base/module/ImagePopover.js


        function ImagePopover_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function ImagePopover_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function ImagePopover_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) ImagePopover_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) ImagePopover_defineProperties(Constructor, staticProps);
          return Constructor;
        }
        /**
         * Image popover module
         *  mouse events that show/hide popover will be handled by Handle.js.
         *  Handle.js will receive the events and invoke 'imagePopover.update'.
         */


        var ImagePopover_ImagePopover = /*#__PURE__*/function () {
          function ImagePopover(context) {
            var _this = this;

            ImagePopover_classCallCheck(this, ImagePopover);
            this.context = context;
            this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
            this.editable = context.layoutInfo.editable[0];
            this.options = context.options;
            this.events = {
              'summernote.disable summernote.blur': function summernoteDisableSummernoteBlur() {
                _this.hide();
              }
            };
          }

          ImagePopover_createClass(ImagePopover, [{
            key: "shouldInitialize",
            value: function shouldInitialize() {
              return !lists.isEmpty(this.options.popover.image);
            }
          }, {
            key: "initialize",
            value: function initialize() {
              this.$popover = this.ui.popover({
                className: 'note-image-popover'
              }).render().appendTo(this.options.container);
              var $content = this.$popover.find('.popover-content,.note-popover-content');
              this.context.invoke('buttons.build', $content, this.options.popover.image);
              this.$popover.on('mousedown', function (e) {
                e.preventDefault();
              });
            }
          }, {
            key: "destroy",
            value: function destroy() {
              this.$popover.remove();
            }
          }, {
            key: "update",
            value: function update(target, event) {
              if (dom.isImg(target)) {
                var position = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(target).offset();
                var containerOffset = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(this.options.container).offset();
                var pos = {};

                if (this.options.popatmouse) {
                  pos.left = event.pageX - 20;
                  pos.top = event.pageY;
                } else {
                  pos = position;
                }

                pos.top -= containerOffset.top;
                pos.left -= containerOffset.left;
                this.$popover.css({
                  display: 'block',
                  left: pos.left,
                  top: pos.top
                });
              } else {
                this.hide();
              }
            }
          }, {
            key: "hide",
            value: function hide() {
              this.$popover.hide();
            }
          }]);
          return ImagePopover;
        }(); // CONCATENATED MODULE: ./src/js/base/module/TablePopover.js


        function TablePopover_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function TablePopover_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function TablePopover_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) TablePopover_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) TablePopover_defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var TablePopover_TablePopover = /*#__PURE__*/function () {
          function TablePopover(context) {
            var _this = this;

            TablePopover_classCallCheck(this, TablePopover);
            this.context = context;
            this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
            this.options = context.options;
            this.events = {
              'summernote.mousedown': function summernoteMousedown(we, e) {
                _this.update(e.target);
              },
              'summernote.keyup summernote.scroll summernote.change': function summernoteKeyupSummernoteScrollSummernoteChange() {
                _this.update();
              },
              'summernote.disable summernote.blur': function summernoteDisableSummernoteBlur() {
                _this.hide();
              }
            };
          }

          TablePopover_createClass(TablePopover, [{
            key: "shouldInitialize",
            value: function shouldInitialize() {
              return !lists.isEmpty(this.options.popover.table);
            }
          }, {
            key: "initialize",
            value: function initialize() {
              this.$popover = this.ui.popover({
                className: 'note-table-popover'
              }).render().appendTo(this.options.container);
              var $content = this.$popover.find('.popover-content,.note-popover-content');
              this.context.invoke('buttons.build', $content, this.options.popover.table); // [workaround] Disable Firefox's default table editor

              if (env.isFF) {
                document.execCommand('enableInlineTableEditing', false, false);
              }

              this.$popover.on('mousedown', function (e) {
                e.preventDefault();
              });
            }
          }, {
            key: "destroy",
            value: function destroy() {
              this.$popover.remove();
            }
          }, {
            key: "update",
            value: function update(target) {
              if (this.context.isDisabled()) {
                return false;
              }

              var isCell = dom.isCell(target);

              if (isCell) {
                var pos = dom.posFromPlaceholder(target);
                var containerOffset = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(this.options.container).offset();
                pos.top -= containerOffset.top;
                pos.left -= containerOffset.left;
                this.$popover.css({
                  display: 'block',
                  left: pos.left,
                  top: pos.top
                });
              } else {
                this.hide();
              }

              return isCell;
            }
          }, {
            key: "hide",
            value: function hide() {
              this.$popover.hide();
            }
          }]);
          return TablePopover;
        }(); // CONCATENATED MODULE: ./src/js/base/module/VideoDialog.js


        function VideoDialog_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function VideoDialog_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function VideoDialog_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) VideoDialog_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) VideoDialog_defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var VideoDialog_VideoDialog = /*#__PURE__*/function () {
          function VideoDialog(context) {
            VideoDialog_classCallCheck(this, VideoDialog);
            this.context = context;
            this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
            this.$body = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(document.body);
            this.$editor = context.layoutInfo.editor;
            this.options = context.options;
            this.lang = this.options.langInfo;
          }

          VideoDialog_createClass(VideoDialog, [{
            key: "initialize",
            value: function initialize() {
              var $container = this.options.dialogsInBody ? this.$body : this.options.container;
              var body = ['<div class="form-group note-form-group row-fluid">', "<label for=\"note-dialog-video-url-".concat(this.options.id, "\" class=\"note-form-label\">").concat(this.lang.video.url, " <small class=\"text-muted\">").concat(this.lang.video.providers, "</small></label>"), "<input id=\"note-dialog-video-url-".concat(this.options.id, "\" class=\"note-video-url form-control note-form-control note-input\" type=\"text\"/>"), '</div>'].join('');
              var buttonClass = 'btn btn-primary note-btn note-btn-primary note-video-btn';
              var footer = "<input type=\"button\" href=\"#\" class=\"".concat(buttonClass, "\" value=\"").concat(this.lang.video.insert, "\" disabled>");
              this.$dialog = this.ui.dialog({
                title: this.lang.video.insert,
                fade: this.options.dialogsFade,
                body: body,
                footer: footer
              }).render().appendTo($container);
            }
          }, {
            key: "destroy",
            value: function destroy() {
              this.ui.hideDialog(this.$dialog);
              this.$dialog.remove();
            }
          }, {
            key: "bindEnterKey",
            value: function bindEnterKey($input, $btn) {
              $input.on('keypress', function (event) {
                if (event.keyCode === core_key.code.ENTER) {
                  event.preventDefault();
                  $btn.trigger('click');
                }
              });
            }
          }, {
            key: "createVideoNode",
            value: function createVideoNode(url) {
              // video url patterns(youtube, instagram, vimeo, dailymotion, youku, mp4, ogg, webm)
              var ytRegExp = /\/\/(?:(?:www|m)\.)?(?:youtu\.be\/|youtube\.com\/(?:embed\/|v\/|watch\?v=|watch\?.+&v=))([\w|-]{11})(?:(?:[\?&]t=)(\S+))?$/;
              var ytRegExpForStart = /^(?:(\d+)h)?(?:(\d+)m)?(?:(\d+)s)?$/;
              var ytMatch = url.match(ytRegExp);
              var igRegExp = /(?:www\.|\/\/)instagram\.com\/p\/(.[a-zA-Z0-9_-]*)/;
              var igMatch = url.match(igRegExp);
              var vRegExp = /\/\/vine\.co\/v\/([a-zA-Z0-9]+)/;
              var vMatch = url.match(vRegExp);
              var vimRegExp = /\/\/(player\.)?vimeo\.com\/([a-z]*\/)*(\d+)[?]?.*/;
              var vimMatch = url.match(vimRegExp);
              var dmRegExp = /.+dailymotion.com\/(video|hub)\/([^_]+)[^#]*(#video=([^_&]+))?/;
              var dmMatch = url.match(dmRegExp);
              var youkuRegExp = /\/\/v\.youku\.com\/v_show\/id_(\w+)=*\.html/;
              var youkuMatch = url.match(youkuRegExp);
              var qqRegExp = /\/\/v\.qq\.com.*?vid=(.+)/;
              var qqMatch = url.match(qqRegExp);
              var qqRegExp2 = /\/\/v\.qq\.com\/x?\/?(page|cover).*?\/([^\/]+)\.html\??.*/;
              var qqMatch2 = url.match(qqRegExp2);
              var mp4RegExp = /^.+.(mp4|m4v)$/;
              var mp4Match = url.match(mp4RegExp);
              var oggRegExp = /^.+.(ogg|ogv)$/;
              var oggMatch = url.match(oggRegExp);
              var webmRegExp = /^.+.(webm)$/;
              var webmMatch = url.match(webmRegExp);
              var fbRegExp = /(?:www\.|\/\/)facebook\.com\/([^\/]+)\/videos\/([0-9]+)/;
              var fbMatch = url.match(fbRegExp);
              var $video;

              if (ytMatch && ytMatch[1].length === 11) {
                var youtubeId = ytMatch[1];
                var start = 0;

                if (typeof ytMatch[2] !== 'undefined') {
                  var ytMatchForStart = ytMatch[2].match(ytRegExpForStart);

                  if (ytMatchForStart) {
                    for (var n = [3600, 60, 1], i = 0, r = n.length; i < r; i++) {
                      start += typeof ytMatchForStart[i + 1] !== 'undefined' ? n[i] * parseInt(ytMatchForStart[i + 1], 10) : 0;
                    }
                  }
                }

                $video = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<iframe>').attr('frameborder', 0).attr('src', '//www.youtube.com/embed/' + youtubeId + (start > 0 ? '?start=' + start : '')).attr('width', '640').attr('height', '360');
              } else if (igMatch && igMatch[0].length) {
                $video = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<iframe>').attr('frameborder', 0).attr('src', 'https://instagram.com/p/' + igMatch[1] + '/embed/').attr('width', '612').attr('height', '710').attr('scrolling', 'no').attr('allowtransparency', 'true');
              } else if (vMatch && vMatch[0].length) {
                $video = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<iframe>').attr('frameborder', 0).attr('src', vMatch[0] + '/embed/simple').attr('width', '600').attr('height', '600').attr('class', 'vine-embed');
              } else if (vimMatch && vimMatch[3].length) {
                $video = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>').attr('frameborder', 0).attr('src', '//player.vimeo.com/video/' + vimMatch[3]).attr('width', '640').attr('height', '360');
              } else if (dmMatch && dmMatch[2].length) {
                $video = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<iframe>').attr('frameborder', 0).attr('src', '//www.dailymotion.com/embed/video/' + dmMatch[2]).attr('width', '640').attr('height', '360');
              } else if (youkuMatch && youkuMatch[1].length) {
                $video = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>').attr('frameborder', 0).attr('height', '498').attr('width', '510').attr('src', '//player.youku.com/embed/' + youkuMatch[1]);
              } else if (qqMatch && qqMatch[1].length || qqMatch2 && qqMatch2[2].length) {
                var vid = qqMatch && qqMatch[1].length ? qqMatch[1] : qqMatch2[2];
                $video = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>').attr('frameborder', 0).attr('height', '310').attr('width', '500').attr('src', 'https://v.qq.com/txp/iframe/player.html?vid=' + vid + '&amp;auto=0');
              } else if (mp4Match || oggMatch || webmMatch) {
                $video = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<video controls>').attr('src', url).attr('width', '640').attr('height', '360');
              } else if (fbMatch && fbMatch[0].length) {
                $video = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<iframe>').attr('frameborder', 0).attr('src', 'https://www.facebook.com/plugins/video.php?href=' + encodeURIComponent(fbMatch[0]) + '&show_text=0&width=560').attr('width', '560').attr('height', '301').attr('scrolling', 'no').attr('allowtransparency', 'true');
              } else {
                // this is not a known video link. Now what, Cat? Now what?
                return false;
              }

              $video.addClass('note-video-clip');
              return $video[0];
            }
          }, {
            key: "show",
            value: function show() {
              var _this = this;

              var text = this.context.invoke('editor.getSelectedText');
              this.context.invoke('editor.saveRange');
              this.showVideoDialog(text).then(function (url) {
                // [workaround] hide dialog before restore range for IE range focus
                _this.ui.hideDialog(_this.$dialog);

                _this.context.invoke('editor.restoreRange'); // build node


                var $node = _this.createVideoNode(url);

                if ($node) {
                  // insert video node
                  _this.context.invoke('editor.insertNode', $node);
                }
              }).fail(function () {
                _this.context.invoke('editor.restoreRange');
              });
            }
            /**
             * show video dialog
             *
             * @param {jQuery} $dialog
             * @return {Promise}
             */

          }, {
            key: "showVideoDialog",
            value: function showVideoDialog()
            /* text */
            {
              var _this2 = this;

              return external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.Deferred(function (deferred) {
                var $videoUrl = _this2.$dialog.find('.note-video-url');

                var $videoBtn = _this2.$dialog.find('.note-video-btn');

                _this2.ui.onDialogShown(_this2.$dialog, function () {
                  _this2.context.triggerEvent('dialog.shown');

                  $videoUrl.on('input paste propertychange', function () {
                    _this2.ui.toggleBtn($videoBtn, $videoUrl.val());
                  });

                  if (!env.isSupportTouch) {
                    $videoUrl.trigger('focus');
                  }

                  $videoBtn.click(function (event) {
                    event.preventDefault();
                    deferred.resolve($videoUrl.val());
                  });

                  _this2.bindEnterKey($videoUrl, $videoBtn);
                });

                _this2.ui.onDialogHidden(_this2.$dialog, function () {
                  $videoUrl.off();
                  $videoBtn.off();

                  if (deferred.state() === 'pending') {
                    deferred.reject();
                  }
                });

                _this2.ui.showDialog(_this2.$dialog);
              });
            }
          }]);
          return VideoDialog;
        }(); // CONCATENATED MODULE: ./src/js/base/module/HelpDialog.js


        function HelpDialog_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function HelpDialog_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function HelpDialog_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) HelpDialog_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) HelpDialog_defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var HelpDialog_HelpDialog = /*#__PURE__*/function () {
          function HelpDialog(context) {
            HelpDialog_classCallCheck(this, HelpDialog);
            this.context = context;
            this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
            this.$body = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(document.body);
            this.$editor = context.layoutInfo.editor;
            this.options = context.options;
            this.lang = this.options.langInfo;
          }

          HelpDialog_createClass(HelpDialog, [{
            key: "initialize",
            value: function initialize() {
              var $container = this.options.dialogsInBody ? this.$body : this.options.container;
              var body = ['<p class="text-center">', '<a href="http://summernote.org/" target="_blank">Summernote 0.8.18</a> · ', '<a href="https://github.com/summernote/summernote" target="_blank">Project</a> · ', '<a href="https://github.com/summernote/summernote/issues" target="_blank">Issues</a>', '</p>'].join('');
              this.$dialog = this.ui.dialog({
                title: this.lang.options.help,
                fade: this.options.dialogsFade,
                body: this.createShortcutList(),
                footer: body,
                callback: function callback($node) {
                  $node.find('.modal-body,.note-modal-body').css({
                    'max-height': 300,
                    'overflow': 'scroll'
                  });
                }
              }).render().appendTo($container);
            }
          }, {
            key: "destroy",
            value: function destroy() {
              this.ui.hideDialog(this.$dialog);
              this.$dialog.remove();
            }
          }, {
            key: "createShortcutList",
            value: function createShortcutList() {
              var _this = this;

              var keyMap = this.options.keyMap[env.isMac ? 'mac' : 'pc'];
              return Object.keys(keyMap).map(function (key) {
                var command = keyMap[key];
                var $row = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<div><div class="help-list-item"></div></div>');
                $row.append(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<label><kbd>' + key + '</kdb></label>').css({
                  'width': 180,
                  'margin-right': 10
                })).append(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<span/>').html(_this.context.memo('help.' + command) || command));
                return $row.html();
              }).join('');
            }
            /**
             * show help dialog
             *
             * @return {Promise}
             */

          }, {
            key: "showHelpDialog",
            value: function showHelpDialog() {
              var _this2 = this;

              return external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.Deferred(function (deferred) {
                _this2.ui.onDialogShown(_this2.$dialog, function () {
                  _this2.context.triggerEvent('dialog.shown');

                  deferred.resolve();
                });

                _this2.ui.showDialog(_this2.$dialog);
              }).promise();
            }
          }, {
            key: "show",
            value: function show() {
              var _this3 = this;

              this.context.invoke('editor.saveRange');
              this.showHelpDialog().then(function () {
                _this3.context.invoke('editor.restoreRange');
              });
            }
          }]);
          return HelpDialog;
        }(); // CONCATENATED MODULE: ./src/js/base/module/AirPopover.js


        function AirPopover_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function AirPopover_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function AirPopover_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) AirPopover_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) AirPopover_defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var AIRMODE_POPOVER_X_OFFSET = -5;
        var AIRMODE_POPOVER_Y_OFFSET = 5;

        var AirPopover_AirPopover = /*#__PURE__*/function () {
          function AirPopover(context) {
            var _this = this;

            AirPopover_classCallCheck(this, AirPopover);
            this.context = context;
            this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
            this.options = context.options;
            this.hidable = true;
            this.onContextmenu = false;
            this.pageX = null;
            this.pageY = null;
            this.events = {
              'summernote.contextmenu': function summernoteContextmenu(e) {
                if (_this.options.editing) {
                  e.preventDefault();
                  e.stopPropagation();
                  _this.onContextmenu = true;

                  _this.update(true);
                }
              },
              'summernote.mousedown': function summernoteMousedown(we, e) {
                _this.pageX = e.pageX;
                _this.pageY = e.pageY;
              },
              'summernote.keyup summernote.mouseup summernote.scroll': function summernoteKeyupSummernoteMouseupSummernoteScroll(we, e) {
                if (_this.options.editing && !_this.onContextmenu) {
                  _this.pageX = e.pageX;
                  _this.pageY = e.pageY;

                  _this.update();
                }

                _this.onContextmenu = false;
              },
              'summernote.disable summernote.change summernote.dialog.shown summernote.blur': function summernoteDisableSummernoteChangeSummernoteDialogShownSummernoteBlur() {
                _this.hide();
              },
              'summernote.focusout': function summernoteFocusout() {
                if (!_this.$popover.is(':active,:focus')) {
                  _this.hide();
                }
              }
            };
          }

          AirPopover_createClass(AirPopover, [{
            key: "shouldInitialize",
            value: function shouldInitialize() {
              return this.options.airMode && !lists.isEmpty(this.options.popover.air);
            }
          }, {
            key: "initialize",
            value: function initialize() {
              var _this2 = this;

              this.$popover = this.ui.popover({
                className: 'note-air-popover'
              }).render().appendTo(this.options.container);
              var $content = this.$popover.find('.popover-content');
              this.context.invoke('buttons.build', $content, this.options.popover.air); // disable hiding this popover preemptively by 'summernote.blur' event.

              this.$popover.on('mousedown', function () {
                _this2.hidable = false;
              }); // (re-)enable hiding after 'summernote.blur' has been handled (aka. ignored).

              this.$popover.on('mouseup', function () {
                _this2.hidable = true;
              });
            }
          }, {
            key: "destroy",
            value: function destroy() {
              this.$popover.remove();
            }
          }, {
            key: "update",
            value: function update(forcelyOpen) {
              var styleInfo = this.context.invoke('editor.currentStyle');

              if (styleInfo.range && (!styleInfo.range.isCollapsed() || forcelyOpen)) {
                var rect = {
                  left: this.pageX,
                  top: this.pageY
                };
                var containerOffset = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(this.options.container).offset();
                rect.top -= containerOffset.top;
                rect.left -= containerOffset.left;
                this.$popover.css({
                  display: 'block',
                  left: Math.max(rect.left, 0) + AIRMODE_POPOVER_X_OFFSET,
                  top: rect.top + AIRMODE_POPOVER_Y_OFFSET
                });
                this.context.invoke('buttons.updateCurrentStyle', this.$popover);
              } else {
                this.hide();
              }
            }
          }, {
            key: "updateCodeview",
            value: function updateCodeview(isCodeview) {
              this.ui.toggleBtnActive(this.$popover.find('.btn-codeview'), isCodeview);

              if (isCodeview) {
                this.hide();
              }
            }
          }, {
            key: "hide",
            value: function hide() {
              if (this.hidable) {
                this.$popover.hide();
              }
            }
          }]);
          return AirPopover;
        }(); // CONCATENATED MODULE: ./src/js/base/module/HintPopover.js


        function HintPopover_classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function HintPopover_defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function HintPopover_createClass(Constructor, protoProps, staticProps) {
          if (protoProps) HintPopover_defineProperties(Constructor.prototype, protoProps);
          if (staticProps) HintPopover_defineProperties(Constructor, staticProps);
          return Constructor;
        }

        var POPOVER_DIST = 5;

        var HintPopover_HintPopover = /*#__PURE__*/function () {
          function HintPopover(context) {
            var _this = this;

            HintPopover_classCallCheck(this, HintPopover);
            this.context = context;
            this.ui = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.ui;
            this.$editable = context.layoutInfo.editable;
            this.options = context.options;
            this.hint = this.options.hint || [];
            this.direction = this.options.hintDirection || 'bottom';
            this.hints = Array.isArray(this.hint) ? this.hint : [this.hint];
            this.events = {
              'summernote.keyup': function summernoteKeyup(we, e) {
                if (!e.isDefaultPrevented()) {
                  _this.handleKeyup(e);
                }
              },
              'summernote.keydown': function summernoteKeydown(we, e) {
                _this.handleKeydown(e);
              },
              'summernote.disable summernote.dialog.shown summernote.blur': function summernoteDisableSummernoteDialogShownSummernoteBlur() {
                _this.hide();
              }
            };
          }

          HintPopover_createClass(HintPopover, [{
            key: "shouldInitialize",
            value: function shouldInitialize() {
              return this.hints.length > 0;
            }
          }, {
            key: "initialize",
            value: function initialize() {
              var _this2 = this;

              this.lastWordRange = null;
              this.matchingWord = null;
              this.$popover = this.ui.popover({
                className: 'note-hint-popover',
                hideArrow: true,
                direction: ''
              }).render().appendTo(this.options.container);
              this.$popover.hide();
              this.$content = this.$popover.find('.popover-content,.note-popover-content');
              this.$content.on('click', '.note-hint-item', function (e) {
                _this2.$content.find('.active').removeClass('active');

                external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(e.currentTarget).addClass('active');

                _this2.replace();
              });
              this.$popover.on('mousedown', function (e) {
                e.preventDefault();
              });
            }
          }, {
            key: "destroy",
            value: function destroy() {
              this.$popover.remove();
            }
          }, {
            key: "selectItem",
            value: function selectItem($item) {
              this.$content.find('.active').removeClass('active');
              $item.addClass('active');
              this.$content[0].scrollTop = $item[0].offsetTop - this.$content.innerHeight() / 2;
            }
          }, {
            key: "moveDown",
            value: function moveDown() {
              var $current = this.$content.find('.note-hint-item.active');
              var $next = $current.next();

              if ($next.length) {
                this.selectItem($next);
              } else {
                var $nextGroup = $current.parent().next();

                if (!$nextGroup.length) {
                  $nextGroup = this.$content.find('.note-hint-group').first();
                }

                this.selectItem($nextGroup.find('.note-hint-item').first());
              }
            }
          }, {
            key: "moveUp",
            value: function moveUp() {
              var $current = this.$content.find('.note-hint-item.active');
              var $prev = $current.prev();

              if ($prev.length) {
                this.selectItem($prev);
              } else {
                var $prevGroup = $current.parent().prev();

                if (!$prevGroup.length) {
                  $prevGroup = this.$content.find('.note-hint-group').last();
                }

                this.selectItem($prevGroup.find('.note-hint-item').last());
              }
            }
          }, {
            key: "replace",
            value: function replace() {
              var $item = this.$content.find('.note-hint-item.active');

              if ($item.length) {
                var node = this.nodeFromItem($item); // If matchingWord length = 0 -> capture OK / open hint / but as mention capture "" (\w*)

                if (this.matchingWord !== null && this.matchingWord.length === 0) {
                  this.lastWordRange.so = this.lastWordRange.eo; // Else si > 0 and normal case -> adjust range "before" for correct position of insertion
                } else if (this.matchingWord !== null && this.matchingWord.length > 0 && !this.lastWordRange.isCollapsed()) {
                  var rangeCompute = this.lastWordRange.eo - this.lastWordRange.so - this.matchingWord.length;

                  if (rangeCompute > 0) {
                    this.lastWordRange.so += rangeCompute;
                  }
                }

                this.lastWordRange.insertNode(node);

                if (this.options.hintSelect === 'next') {
                  var blank = document.createTextNode('');
                  external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(node).after(blank);
                  range.createFromNodeBefore(blank).select();
                } else {
                  range.createFromNodeAfter(node).select();
                }

                this.lastWordRange = null;
                this.hide();
                this.context.invoke('editor.focus');
              }
            }
          }, {
            key: "nodeFromItem",
            value: function nodeFromItem($item) {
              var hint = this.hints[$item.data('index')];
              var item = $item.data('item');
              var node = hint.content ? hint.content(item) : item;

              if (typeof node === 'string') {
                node = dom.createText(node);
              }

              return node;
            }
          }, {
            key: "createItemTemplates",
            value: function createItemTemplates(hintIdx, items) {
              var hint = this.hints[hintIdx];
              return items.map(function (item
              /*, idx */
              ) {
                var $item = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<div class="note-hint-item"/>');
                $item.append(hint.template ? hint.template(item) : item + '');
                $item.data({
                  'index': hintIdx,
                  'item': item
                });
                return $item;
              });
            }
          }, {
            key: "handleKeydown",
            value: function handleKeydown(e) {
              if (!this.$popover.is(':visible')) {
                return;
              }

              if (e.keyCode === core_key.code.ENTER) {
                e.preventDefault();
                this.replace();
              } else if (e.keyCode === core_key.code.UP) {
                e.preventDefault();
                this.moveUp();
              } else if (e.keyCode === core_key.code.DOWN) {
                e.preventDefault();
                this.moveDown();
              }
            }
          }, {
            key: "searchKeyword",
            value: function searchKeyword(index, keyword, callback) {
              var hint = this.hints[index];

              if (hint && hint.match.test(keyword) && hint.search) {
                var matches = hint.match.exec(keyword);
                this.matchingWord = matches[0];
                hint.search(matches[1], callback);
              } else {
                callback();
              }
            }
          }, {
            key: "createGroup",
            value: function createGroup(idx, keyword) {
              var _this3 = this;

              var $group = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()('<div class="note-hint-group note-hint-group-' + idx + '"></div>');
              this.searchKeyword(idx, keyword, function (items) {
                items = items || [];

                if (items.length) {
                  $group.html(_this3.createItemTemplates(idx, items));

                  _this3.show();
                }
              });
              return $group;
            }
          }, {
            key: "handleKeyup",
            value: function handleKeyup(e) {
              var _this4 = this;

              if (!lists.contains([core_key.code.ENTER, core_key.code.UP, core_key.code.DOWN], e.keyCode)) {
                var _range = this.context.invoke('editor.getLastRange');

                var wordRange, keyword;

                if (this.options.hintMode === 'words') {
                  wordRange = _range.getWordsRange(_range);
                  keyword = wordRange.toString();
                  this.hints.forEach(function (hint) {
                    if (hint.match.test(keyword)) {
                      wordRange = _range.getWordsMatchRange(hint.match);
                      return false;
                    }
                  });

                  if (!wordRange) {
                    this.hide();
                    return;
                  }

                  keyword = wordRange.toString();
                } else {
                  wordRange = _range.getWordRange();
                  keyword = wordRange.toString();
                }

                if (this.hints.length && keyword) {
                  this.$content.empty();
                  var bnd = func.rect2bnd(lists.last(wordRange.getClientRects()));
                  var containerOffset = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(this.options.container).offset();

                  if (bnd) {
                    bnd.top -= containerOffset.top;
                    bnd.left -= containerOffset.left;
                    this.$popover.hide();
                    this.lastWordRange = wordRange;
                    this.hints.forEach(function (hint, idx) {
                      if (hint.match.test(keyword)) {
                        _this4.createGroup(idx, keyword).appendTo(_this4.$content);
                      }
                    }); // select first .note-hint-item

                    this.$content.find('.note-hint-item:first').addClass('active'); // set position for popover after group is created

                    if (this.direction === 'top') {
                      this.$popover.css({
                        left: bnd.left,
                        top: bnd.top - this.$popover.outerHeight() - POPOVER_DIST
                      });
                    } else {
                      this.$popover.css({
                        left: bnd.left,
                        top: bnd.top + bnd.height + POPOVER_DIST
                      });
                    }
                  }
                } else {
                  this.hide();
                }
              }
            }
          }, {
            key: "show",
            value: function show() {
              this.$popover.show();
            }
          }, {
            key: "hide",
            value: function hide() {
              this.$popover.hide();
            }
          }]);
          return HintPopover;
        }(); // CONCATENATED MODULE: ./src/js/base/settings.js


        external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.extend(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote, {
          version: '0.8.18',
          plugins: {},
          dom: dom,
          range: range,
          lists: lists,
          options: {
            langInfo: external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.lang['en-US'],
            editing: true,
            modules: {
              'editor': Editor_Editor,
              'clipboard': Clipboard_Clipboard,
              'dropzone': Dropzone_Dropzone,
              'codeview': Codeview_CodeView,
              'statusbar': Statusbar_Statusbar,
              'fullscreen': Fullscreen_Fullscreen,
              'handle': Handle_Handle,
              // FIXME: HintPopover must be front of autolink
              //  - Script error about range when Enter key is pressed on hint popover
              'hintPopover': HintPopover_HintPopover,
              'autoLink': AutoLink_AutoLink,
              'autoSync': AutoSync_AutoSync,
              'autoReplace': AutoReplace_AutoReplace,
              'placeholder': Placeholder_Placeholder,
              'buttons': Buttons_Buttons,
              'toolbar': Toolbar_Toolbar,
              'linkDialog': LinkDialog_LinkDialog,
              'linkPopover': LinkPopover_LinkPopover,
              'imageDialog': ImageDialog_ImageDialog,
              'imagePopover': ImagePopover_ImagePopover,
              'tablePopover': TablePopover_TablePopover,
              'videoDialog': VideoDialog_VideoDialog,
              'helpDialog': HelpDialog_HelpDialog,
              'airPopover': AirPopover_AirPopover
            },
            buttons: {},
            lang: 'en-US',
            followingToolbar: false,
            toolbarPosition: 'top',
            otherStaticBar: '',
            // toolbar
            codeviewKeepButton: false,
            toolbar: [['style', ['style']], ['font', ['bold', 'underline', 'clear']], ['fontname', ['fontname']], ['color', ['color']], ['para', ['ul', 'ol', 'paragraph']], ['table', ['table']], ['insert', ['link', 'picture', 'video']], ['view', ['fullscreen', 'codeview', 'help']]],
            // popover
            popatmouse: true,
            popover: {
              image: [['resize', ['resizeFull', 'resizeHalf', 'resizeQuarter', 'resizeNone']], ['float', ['floatLeft', 'floatRight', 'floatNone']], ['remove', ['removeMedia']]],
              link: [['link', ['linkDialogShow', 'unlink']]],
              table: [['add', ['addRowDown', 'addRowUp', 'addColLeft', 'addColRight']], ['delete', ['deleteRow', 'deleteCol', 'deleteTable']]],
              air: [['color', ['color']], ['font', ['bold', 'underline', 'clear']], ['para', ['ul', 'paragraph']], ['table', ['table']], ['insert', ['link', 'picture']], ['view', ['fullscreen', 'codeview']]]
            },
            // air mode: inline editor
            airMode: false,
            overrideContextMenu: false,
            // TBD
            width: null,
            height: null,
            linkTargetBlank: true,
            useProtocol: true,
            defaultProtocol: 'http://',
            focus: false,
            tabDisabled: false,
            tabSize: 4,
            styleWithCSS: false,
            shortcuts: true,
            textareaAutoSync: true,
            tooltip: 'auto',
            container: null,
            maxTextLength: 0,
            blockquoteBreakingLevel: 2,
            spellCheck: true,
            disableGrammar: false,
            placeholder: null,
            inheritPlaceholder: false,
            // TODO: need to be documented
            recordEveryKeystroke: false,
            historyLimit: 200,
            // TODO: need to be documented
            showDomainOnlyForAutolink: false,
            // TODO: need to be documented
            hintMode: 'word',
            hintSelect: 'after',
            hintDirection: 'bottom',
            styleTags: ['p', 'blockquote', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
            fontNames: ['Arial', 'Arial Black', 'Comic Sans MS', 'Courier New', 'Helvetica Neue', 'Helvetica', 'Impact', 'Lucida Grande', 'Tahoma', 'Times New Roman', 'Verdana'],
            fontNamesIgnoreCheck: [],
            addDefaultFonts: true,
            fontSizes: ['8', '9', '10', '11', '12', '14', '18', '24', '36'],
            fontSizeUnits: ['px', 'pt'],
            // pallete colors(n x n)
            colors: [['#000000', '#424242', '#636363', '#9C9C94', '#CEC6CE', '#EFEFEF', '#F7F7F7', '#FFFFFF'], ['#FF0000', '#FF9C00', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#9C00FF', '#FF00FF'], ['#F7C6CE', '#FFE7CE', '#FFEFC6', '#D6EFD6', '#CEDEE7', '#CEE7F7', '#D6D6E7', '#E7D6DE'], ['#E79C9C', '#FFC69C', '#FFE79C', '#B5D6A5', '#A5C6CE', '#9CC6EF', '#B5A5D6', '#D6A5BD'], ['#E76363', '#F7AD6B', '#FFD663', '#94BD7B', '#73A5AD', '#6BADDE', '#8C7BC6', '#C67BA5'], ['#CE0000', '#E79439', '#EFC631', '#6BA54A', '#4A7B8C', '#3984C6', '#634AA5', '#A54A7B'], ['#9C0000', '#B56308', '#BD9400', '#397B21', '#104A5A', '#085294', '#311873', '#731842'], ['#630000', '#7B3900', '#846300', '#295218', '#083139', '#003163', '#21104A', '#4A1031']],
            // http://chir.ag/projects/name-that-color/
            colorsName: [['Black', 'Tundora', 'Dove Gray', 'Star Dust', 'Pale Slate', 'Gallery', 'Alabaster', 'White'], ['Red', 'Orange Peel', 'Yellow', 'Green', 'Cyan', 'Blue', 'Electric Violet', 'Magenta'], ['Azalea', 'Karry', 'Egg White', 'Zanah', 'Botticelli', 'Tropical Blue', 'Mischka', 'Twilight'], ['Tonys Pink', 'Peach Orange', 'Cream Brulee', 'Sprout', 'Casper', 'Perano', 'Cold Purple', 'Careys Pink'], ['Mandy', 'Rajah', 'Dandelion', 'Olivine', 'Gulf Stream', 'Viking', 'Blue Marguerite', 'Puce'], ['Guardsman Red', 'Fire Bush', 'Golden Dream', 'Chelsea Cucumber', 'Smalt Blue', 'Boston Blue', 'Butterfly Bush', 'Cadillac'], ['Sangria', 'Mai Tai', 'Buddha Gold', 'Forest Green', 'Eden', 'Venice Blue', 'Meteorite', 'Claret'], ['Rosewood', 'Cinnamon', 'Olive', 'Parsley', 'Tiber', 'Midnight Blue', 'Valentino', 'Loulou']],
            colorButton: {
              foreColor: '#000000',
              backColor: '#FFFF00'
            },
            lineHeights: ['1.0', '1.2', '1.4', '1.5', '1.6', '1.8', '2.0', '3.0'],
            tableClassName: 'table table-bordered',
            insertTableMaxSize: {
              col: 10,
              row: 10
            },
            // By default, dialogs are attached in container.
            dialogsInBody: false,
            dialogsFade: false,
            maximumImageFileSize: null,
            callbacks: {
              onBeforeCommand: null,
              onBlur: null,
              onBlurCodeview: null,
              onChange: null,
              onChangeCodeview: null,
              onDialogShown: null,
              onEnter: null,
              onFocus: null,
              onImageLinkInsert: null,
              onImageUpload: null,
              onImageUploadError: null,
              onInit: null,
              onKeydown: null,
              onKeyup: null,
              onMousedown: null,
              onMouseup: null,
              onPaste: null,
              onScroll: null
            },
            codemirror: {
              mode: 'text/html',
              htmlMode: true,
              lineNumbers: true
            },
            codeviewFilter: false,
            codeviewFilterRegex: /<\/*(?:applet|b(?:ase|gsound|link)|embed|frame(?:set)?|ilayer|l(?:ayer|ink)|meta|object|s(?:cript|tyle)|t(?:itle|extarea)|xml)[^>]*?>/gi,
            codeviewIframeFilter: true,
            codeviewIframeWhitelistSrc: [],
            codeviewIframeWhitelistSrcBase: ['www.youtube.com', 'www.youtube-nocookie.com', 'www.facebook.com', 'vine.co', 'instagram.com', 'player.vimeo.com', 'www.dailymotion.com', 'player.youku.com', 'v.qq.com'],
            keyMap: {
              pc: {
                'ESC': 'escape',
                'ENTER': 'insertParagraph',
                'CTRL+Z': 'undo',
                'CTRL+Y': 'redo',
                'TAB': 'tab',
                'SHIFT+TAB': 'untab',
                'CTRL+B': 'bold',
                'CTRL+I': 'italic',
                'CTRL+U': 'underline',
                'CTRL+SHIFT+S': 'strikethrough',
                'CTRL+BACKSLASH': 'removeFormat',
                'CTRL+SHIFT+L': 'justifyLeft',
                'CTRL+SHIFT+E': 'justifyCenter',
                'CTRL+SHIFT+R': 'justifyRight',
                'CTRL+SHIFT+J': 'justifyFull',
                'CTRL+SHIFT+NUM7': 'insertUnorderedList',
                'CTRL+SHIFT+NUM8': 'insertOrderedList',
                'CTRL+LEFTBRACKET': 'outdent',
                'CTRL+RIGHTBRACKET': 'indent',
                'CTRL+NUM0': 'formatPara',
                'CTRL+NUM1': 'formatH1',
                'CTRL+NUM2': 'formatH2',
                'CTRL+NUM3': 'formatH3',
                'CTRL+NUM4': 'formatH4',
                'CTRL+NUM5': 'formatH5',
                'CTRL+NUM6': 'formatH6',
                'CTRL+ENTER': 'insertHorizontalRule',
                'CTRL+K': 'linkDialog.show'
              },
              mac: {
                'ESC': 'escape',
                'ENTER': 'insertParagraph',
                'CMD+Z': 'undo',
                'CMD+SHIFT+Z': 'redo',
                'TAB': 'tab',
                'SHIFT+TAB': 'untab',
                'CMD+B': 'bold',
                'CMD+I': 'italic',
                'CMD+U': 'underline',
                'CMD+SHIFT+S': 'strikethrough',
                'CMD+BACKSLASH': 'removeFormat',
                'CMD+SHIFT+L': 'justifyLeft',
                'CMD+SHIFT+E': 'justifyCenter',
                'CMD+SHIFT+R': 'justifyRight',
                'CMD+SHIFT+J': 'justifyFull',
                'CMD+SHIFT+NUM7': 'insertUnorderedList',
                'CMD+SHIFT+NUM8': 'insertOrderedList',
                'CMD+LEFTBRACKET': 'outdent',
                'CMD+RIGHTBRACKET': 'indent',
                'CMD+NUM0': 'formatPara',
                'CMD+NUM1': 'formatH1',
                'CMD+NUM2': 'formatH2',
                'CMD+NUM3': 'formatH3',
                'CMD+NUM4': 'formatH4',
                'CMD+NUM5': 'formatH5',
                'CMD+NUM6': 'formatH6',
                'CMD+ENTER': 'insertHorizontalRule',
                'CMD+K': 'linkDialog.show'
              }
            },
            icons: {
              'align': 'note-icon-align',
              'alignCenter': 'note-icon-align-center',
              'alignJustify': 'note-icon-align-justify',
              'alignLeft': 'note-icon-align-left',
              'alignRight': 'note-icon-align-right',
              'rowBelow': 'note-icon-row-below',
              'colBefore': 'note-icon-col-before',
              'colAfter': 'note-icon-col-after',
              'rowAbove': 'note-icon-row-above',
              'rowRemove': 'note-icon-row-remove',
              'colRemove': 'note-icon-col-remove',
              'indent': 'note-icon-align-indent',
              'outdent': 'note-icon-align-outdent',
              'arrowsAlt': 'note-icon-arrows-alt',
              'bold': 'note-icon-bold',
              'caret': 'note-icon-caret',
              'circle': 'note-icon-circle',
              'close': 'note-icon-close',
              'code': 'note-icon-code',
              'eraser': 'note-icon-eraser',
              'floatLeft': 'note-icon-float-left',
              'floatRight': 'note-icon-float-right',
              'font': 'note-icon-font',
              'frame': 'note-icon-frame',
              'italic': 'note-icon-italic',
              'link': 'note-icon-link',
              'unlink': 'note-icon-chain-broken',
              'magic': 'note-icon-magic',
              'menuCheck': 'note-icon-menu-check',
              'minus': 'note-icon-minus',
              'orderedlist': 'note-icon-orderedlist',
              'pencil': 'note-icon-pencil',
              'picture': 'note-icon-picture',
              'question': 'note-icon-question',
              'redo': 'note-icon-redo',
              'rollback': 'note-icon-rollback',
              'square': 'note-icon-square',
              'strikethrough': 'note-icon-strikethrough',
              'subscript': 'note-icon-subscript',
              'superscript': 'note-icon-superscript',
              'table': 'note-icon-table',
              'textHeight': 'note-icon-text-height',
              'trash': 'note-icon-trash',
              'underline': 'note-icon-underline',
              'undo': 'note-icon-undo',
              'unorderedlist': 'note-icon-unorderedlist',
              'video': 'note-icon-video'
            }
          }
        });
        /***/
      },

      /***/
      5:
      /***/
      function _(module, exports, __webpack_require__) {// extracted by mini-css-extract-plugin

        /***/
      },

      /***/
      53:
      /***/
      function _(module, __webpack_exports__, __webpack_require__) {
        "use strict"; // ESM COMPAT FLAG

        __webpack_require__.r(__webpack_exports__); // EXTERNAL MODULE: external {"root":"jQuery","commonjs2":"jquery","commonjs":"jquery","amd":"jquery"}


        var external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_ = __webpack_require__(0);

        var external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default = /*#__PURE__*/__webpack_require__.n(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_); // EXTERNAL MODULE: ./src/js/base/renderer.js


        var renderer = __webpack_require__(1); // CONCATENATED MODULE: ./src/js/bs4/ui.js


        function _typeof(obj) {
          "@babel/helpers - typeof";

          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
          }

          return _typeof(obj);
        }

        var editor = renderer["a"
        /* default */
        ].create('<div class="note-editor note-frame card"/>');
        var toolbar = renderer["a"
        /* default */
        ].create('<div class="note-toolbar card-header" role="toolbar"/>');
        var editingArea = renderer["a"
        /* default */
        ].create('<div class="note-editing-area"/>');
        var codable = renderer["a"
        /* default */
        ].create('<textarea class="note-codable" aria-multiline="true"/>');
        var editable = renderer["a"
        /* default */
        ].create('<div class="note-editable card-block" contentEditable="true" role="textbox" aria-multiline="true"/>');
        var statusbar = renderer["a"
        /* default */
        ].create(['<output class="note-status-output" role="status" aria-live="polite"></output>', '<div class="note-statusbar" role="status">', '<div class="note-resizebar" aria-label="Resize">', '<div class="note-icon-bar"></div>', '<div class="note-icon-bar"></div>', '<div class="note-icon-bar"></div>', '</div>', '</div>'].join(''));
        var airEditor = renderer["a"
        /* default */
        ].create('<div class="note-editor note-airframe"/>');
        var airEditable = renderer["a"
        /* default */
        ].create(['<div class="note-editable" contentEditable="true" role="textbox" aria-multiline="true"></div>', '<output class="note-status-output" role="status" aria-live="polite"></output>'].join(''));
        var buttonGroup = renderer["a"
        /* default */
        ].create('<div class="note-btn-group btn-group">');
        var dropdown = renderer["a"
        /* default */
        ].create('<div class="note-dropdown-menu dropdown-menu" role="list">', function ($node, options) {
          var markup = Array.isArray(options.items) ? options.items.map(function (item) {
            var value = typeof item === 'string' ? item : item.value || '';
            var content = options.template ? options.template(item) : item;
            var option = _typeof(item) === 'object' ? item.option : undefined;
            var dataValue = 'data-value="' + value + '"';
            var dataOption = option !== undefined ? ' data-option="' + option + '"' : '';
            return '<a class="dropdown-item" href="#" ' + (dataValue + dataOption) + ' role="listitem" aria-label="' + value + '">' + content + '</a>';
          }).join('') : options.items;
          $node.html(markup).attr({
            'aria-label': options.title
          });

          if (options && options.codeviewKeepButton) {
            $node.addClass('note-codeview-keep');
          }
        });

        var dropdownButtonContents = function dropdownButtonContents(contents) {
          return contents;
        };

        var dropdownCheck = renderer["a"
        /* default */
        ].create('<div class="note-dropdown-menu dropdown-menu note-check" role="list">', function ($node, options) {
          var markup = Array.isArray(options.items) ? options.items.map(function (item) {
            var value = typeof item === 'string' ? item : item.value || '';
            var content = options.template ? options.template(item) : item;
            return '<a class="dropdown-item" href="#" data-value="' + value + '" role="listitem" aria-label="' + item + '">' + icon(options.checkClassName) + ' ' + content + '</a>';
          }).join('') : options.items;
          $node.html(markup).attr({
            'aria-label': options.title
          });

          if (options && options.codeviewKeepButton) {
            $node.addClass('note-codeview-keep');
          }
        });
        var dialog = renderer["a"
        /* default */
        ].create('<div class="modal note-modal" aria-hidden="false" tabindex="-1" role="dialog"/>', function ($node, options) {
          if (options.fade) {
            $node.addClass('fade');
          }

          $node.attr({
            'aria-label': options.title
          });
          $node.html(['<div class="modal-dialog">', '<div class="modal-content">', options.title ? '<div class="modal-header">' + '<h4 class="modal-title">' + options.title + '</h4>' + '<button type="button" class="close" data-dismiss="modal" aria-label="Close" aria-hidden="true">&times;</button>' + '</div>' : '', '<div class="modal-body">' + options.body + '</div>', options.footer ? '<div class="modal-footer">' + options.footer + '</div>' : '', '</div>', '</div>'].join(''));
        });
        var popover = renderer["a"
        /* default */
        ].create(['<div class="note-popover popover in">', '<div class="arrow"></div>', '<div class="popover-content note-children-container"></div>', '</div>'].join(''), function ($node, options) {
          var direction = typeof options.direction !== 'undefined' ? options.direction : 'bottom';
          $node.addClass(direction);

          if (options.hideArrow) {
            $node.find('.arrow').hide();
          }
        });
        var ui_checkbox = renderer["a"
        /* default */
        ].create('<div class="form-check"></div>', function ($node, options) {
          $node.html(['<label class="form-check-label"' + (options.id ? ' for="note-' + options.id + '"' : '') + '>', '<input type="checkbox" class="form-check-input"' + (options.id ? ' id="note-' + options.id + '"' : ''), options.checked ? ' checked' : '', ' aria-label="' + (options.text ? options.text : '') + '"', ' aria-checked="' + (options.checked ? 'true' : 'false') + '"/>', ' ' + (options.text ? options.text : '') + '</label>'].join(''));
        });

        var icon = function icon(iconClassName, tagName) {
          tagName = tagName || 'i';
          return '<' + tagName + ' class="' + iconClassName + '"></' + tagName + '>';
        };

        var ui_ui = function ui(editorOptions) {
          return {
            editor: editor,
            toolbar: toolbar,
            editingArea: editingArea,
            codable: codable,
            editable: editable,
            statusbar: statusbar,
            airEditor: airEditor,
            airEditable: airEditable,
            buttonGroup: buttonGroup,
            dropdown: dropdown,
            dropdownButtonContents: dropdownButtonContents,
            dropdownCheck: dropdownCheck,
            dialog: dialog,
            popover: popover,
            icon: icon,
            checkbox: ui_checkbox,
            options: editorOptions,
            palette: function palette($node, options) {
              return renderer["a"
              /* default */
              ].create('<div class="note-color-palette"/>', function ($node, options) {
                var contents = [];

                for (var row = 0, rowSize = options.colors.length; row < rowSize; row++) {
                  var eventName = options.eventName;
                  var colors = options.colors[row];
                  var colorsName = options.colorsName[row];
                  var buttons = [];

                  for (var col = 0, colSize = colors.length; col < colSize; col++) {
                    var color = colors[col];
                    var colorName = colorsName[col];
                    buttons.push(['<button type="button" class="note-color-btn"', 'style="background-color:', color, '" ', 'data-event="', eventName, '" ', 'data-value="', color, '" ', 'title="', colorName, '" ', 'aria-label="', colorName, '" ', 'data-toggle="button" tabindex="-1"></button>'].join(''));
                  }

                  contents.push('<div class="note-color-row">' + buttons.join('') + '</div>');
                }

                $node.html(contents.join(''));

                if (options.tooltip) {
                  $node.find('.note-color-btn').tooltip({
                    container: options.container || editorOptions.container,
                    trigger: 'hover',
                    placement: 'bottom'
                  });
                }
              })($node, options);
            },
            button: function button($node, options) {
              return renderer["a"
              /* default */
              ].create('<button type="button" class="note-btn btn btn-light btn-sm" tabindex="-1">', function ($node, options) {
                if (options && options.tooltip) {
                  $node.attr({
                    title: options.tooltip,
                    'aria-label': options.tooltip
                  }).tooltip({
                    container: options.container || editorOptions.container,
                    trigger: 'hover',
                    placement: 'bottom'
                  }).on('click', function (e) {
                    external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default()(e.currentTarget).tooltip('hide');
                  });
                }

                if (options && options.codeviewButton) {
                  $node.addClass('note-codeview-keep');
                }
              })($node, options);
            },
            toggleBtn: function toggleBtn($btn, isEnable) {
              $btn.toggleClass('disabled', !isEnable);
              $btn.attr('disabled', !isEnable);
            },
            toggleBtnActive: function toggleBtnActive($btn, isActive) {
              $btn.toggleClass('active', isActive);
            },
            onDialogShown: function onDialogShown($dialog, handler) {
              $dialog.one('shown.bs.modal', handler);
            },
            onDialogHidden: function onDialogHidden($dialog, handler) {
              $dialog.one('hidden.bs.modal', handler);
            },
            showDialog: function showDialog($dialog) {
              $dialog.modal('show');
            },
            hideDialog: function hideDialog($dialog) {
              $dialog.modal('hide');
            },
            createLayout: function createLayout($note) {
              var $editor = (editorOptions.airMode ? airEditor([editingArea([codable(), airEditable()])]) : editorOptions.toolbarPosition === 'bottom' ? editor([editingArea([codable(), editable()]), toolbar(), statusbar()]) : editor([toolbar(), editingArea([codable(), editable()]), statusbar()])).render();
              $editor.insertAfter($note);
              return {
                note: $note,
                editor: $editor,
                toolbar: $editor.find('.note-toolbar'),
                editingArea: $editor.find('.note-editing-area'),
                editable: $editor.find('.note-editable'),
                codable: $editor.find('.note-codable'),
                statusbar: $editor.find('.note-statusbar')
              };
            },
            removeLayout: function removeLayout($note, layoutInfo) {
              $note.html(layoutInfo.editable.html());
              layoutInfo.editor.remove();
              $note.show();
            }
          };
        };
        /* harmony default export */


        var bs4_ui = ui_ui; // EXTERNAL MODULE: ./src/js/base/settings.js + 37 modules

        var settings = __webpack_require__(3); // EXTERNAL MODULE: ./src/styles/summernote-bs4.scss


        var summernote_bs4 = __webpack_require__(5); // CONCATENATED MODULE: ./src/js/bs4/settings.js


        external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote = external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.extend(external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote, {
          ui_template: bs4_ui,
          "interface": 'bs4'
        });
        external_root_jQuery_commonjs2_jquery_commonjs_jquery_amd_jquery_default.a.summernote.options.styleTags = ['p', {
          title: 'Blockquote',
          tag: 'blockquote',
          className: 'blockquote',
          value: 'blockquote'
        }, 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
        /***/
      }
      /******/

    })
  );
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./resources/js/app.js":
/*!*****************************!*\
  !*** ./resources/js/app.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * First we will load all of this project's JavaScript dependencies which
 * includes Vue and other libraries. It is a great starting point when
 * building robust, powerful web applications using Vue and Laravel.
 */
__webpack_require__(/*! ./bootstrap */ "./resources/js/bootstrap.js");

__webpack_require__(/*! ../assets/vendors/base/vendor.bundle.base */ "./resources/assets/vendors/base/vendor.bundle.base.js");

__webpack_require__(/*! ../assets/js/off-canvas */ "./resources/assets/js/off-canvas.js");

__webpack_require__(/*! ../assets/js/hoverable-collapse */ "./resources/assets/js/hoverable-collapse.js");

__webpack_require__(/*! ../assets/js/template */ "./resources/assets/js/template.js");

__webpack_require__(/*! ../assets/js/dashboard */ "./resources/assets/js/dashboard.js");

__webpack_require__(/*! ../assets/js/data-table */ "./resources/assets/js/data-table.js");

__webpack_require__(/*! ../assets/js/jquery.dataTables */ "./resources/assets/js/jquery.dataTables.js");

__webpack_require__(/*! ../assets/vendors/summernote/summernote-bs4 */ "./resources/assets/vendors/summernote/summernote-bs4.js");

/***/ }),

/***/ "./resources/js/bootstrap.js":
/*!***********************************!*\
  !*** ./resources/js/bootstrap.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery) {window._ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/**
 * We'll load jQuery and the Bootstrap jQuery plugin which provides support
 * for JavaScript based Bootstrap features such as modals and tabs. This
 * code may be modified to fit the specific needs of your application.
 */

try {
  window.Popper = __webpack_require__(/*! popper.js */ "./node_modules/popper.js/dist/esm/popper.js")["default"];
  window.$ = __webpack_provided_window_dot_jQuery = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");

  __webpack_require__(/*! bootstrap */ "./node_modules/bootstrap/dist/js/bootstrap.js");
} catch (e) {}
/**
 * We'll load the axios HTTP library which allows us to easily issue requests
 * to our Laravel back-end. This library automatically handles sending the
 * CSRF token as a header based on the value of the "XSRF" token cookie.
 */


window.axios = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
window.axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';
/**
 * Echo exposes an expressive API for subscribing to channels and listening
 * for events that are broadcast by Laravel. Echo and event broadcasting
 * allows your team to easily build robust real-time web applications.
 */
// import Echo from 'laravel-echo';
// window.Pusher = require('pusher-js');
// window.Echo = new Echo({
//     broadcaster: 'pusher',
//     key: process.env.MIX_PUSHER_APP_KEY,
//     cluster: process.env.MIX_PUSHER_APP_CLUSTER,
//     forceTLS: true
// });
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./resources/sass/app.scss":
/*!*********************************!*\
  !*** ./resources/sass/app.scss ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "./resources/sass/home.scss":
/*!**********************************!*\
  !*** ./resources/sass/home.scss ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ 0:
/*!****************************************************************************************!*\
  !*** multi ./resources/js/app.js ./resources/sass/home.scss ./resources/sass/app.scss ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! /var/www/html/merorealstate/resources/js/app.js */"./resources/js/app.js");
__webpack_require__(/*! /var/www/html/merorealstate/resources/sass/home.scss */"./resources/sass/home.scss");
module.exports = __webpack_require__(/*! /var/www/html/merorealstate/resources/sass/app.scss */"./resources/sass/app.scss");


/***/ })

},[[0,"/js/manifest","/js/vendor"]]]);